<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <!--
      The Digital Signal Processing with F# (in the Domain of Audio and Music)
 parameters will be replaced with the
      document title extracted from the <h1> element or
      file name, if there is no <h1> heading
    -->
  <title>Digital Signal Processing with F# (in the Domain of Audio and Music)
</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script src="http://code.jquery.com/jquery-1.8.0.js"></script>
  <script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
  <!-- <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

  <!-- <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet"> -->
  <link type="text/css" rel="stylesheet" href="content/style.css" />
  <link type="text/css" rel="stylesheet" href="content/custom_style.css" />

  <script src="content/tips.js" type="text/javascript"></script>

  <script>
    $(document).ready(function () {
      $('hint').prepend("<p><b>Hint</b></p>");
      $('excurs').each(function () {
        var name = $(this).data('name');
        $(this).prepend("<p><b>Excurs: " + name + "</b></p>");
      });
    });

    $(document).ready(function () {
      $(tocList).empty();

      var prevH2Item = null;
      var prevH2List = null;

      var index = 0;
      $("h2, h3").each(function () {

        //insert an anchor to jump to, from the TOC link.            
        var anchor = "<a name='" + index + "'></a>";
        $(this).before(anchor);

        var li = "<li><a href='#" + index + "'>" + $(this).text() + "</a></li>";

        if ($(this).is("h2")) {
          prevH2List = $("<ul></ul>");
          prevH2Item = $(li);
          prevH2Item.append(prevH2List);
          prevH2Item.appendTo("#tocList");
        } else {
          prevH2List.append(li);
        }
        index++;
      });
    }); 
  </script>

  <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body>
  <div class="container markdown-body">

    <div class="row" style="margin-top:30px">
      <div class="span1"></div>
      <div class="span10" id="main">
        <h1>Digital Signal Processing with F# (in the Domain of Audio and Music)</h1>
<div id="tocDiv">
    <ul id="tocList">
    </ul>
</div>
<h2>Introduction</h2>
<h3>Motivation</h3>
<p>Making music with the help of computers is not new. It started with the <a href="https://en.wikipedia.org/wiki/MUSIC-N">MUSIC/MUSIC-N</a> language family, which was already capable of synthesizing sounds, back in the 1950s. There are a lot of graphic tools like <a href="https://puredata.info/">PureData</a>, with which the user can put together signal flows by dragging predefined objects onto a canvas and connecting their inputs/outputs. Some tools focus on controlling, composition and live performance, like <a href="https://sonic-pi.net/">Sonic PI</a> or <a href="https://tidalcycles.org/index.php/Welcome">Tidal</a>, while others can do both, like <a href="https://supercollider.github.io/">SuperCollider</a>. Other languages and tools incorporate interesting concepts to make working with (audio and control) signals easy, like <a href="http://chuck.cs.princeton.edu/">ChucK</a>, which has an interesting way of dealing with time. There is the <a href="https://faust.grame.fr/">FAUST</a> language that makes use of a pure function composition concept quite similar to Haskell's <a href="https://en.wikibooks.org/wiki/Haskell/Understanding_arrows">Arrows</a>. And of course, with the widely used multiparadigm languages like C or C++, the user can do basically everything, as long as he or she knows how to do it. There is way more interesting stuff out there, such as the JavaScript library <a href="http://www.charlie-roberts.com/genish/">genish.js / gibberish</a>, which aims to provide ways by which a user can define a syntax tree that is translated into high performance code.</p>
<p>Because developing software is my profession and my hobby, I wanted to understand why there are so many different tools and languages out there. I started my own work in C#, since this is the main language I work in, with a focus on sample-based generation and processing of audio signals (the code is available <a href="https://archive.codeplex.com/?p=byond">here</a>, but it is not maintained anymore). But I soon began to realize that there are disadvantages: I had to deal with aspects that had nothing to do with describing signal flows, and I had to write a lot more boilerplate code. That all smelled like <a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">accidental complexity</a>, and I asked myself how I could find abstractions that would help me write code that was readable and understandable, and that focused solely on signal processing.</p>
<p>After evaluating several languages, I decided to use F#, mainly due to its "in-built" flexibility without dealing with macros or other hardcore meta programming techniques or compiler hooks (although I find them very interesting). Also, I'm quite familiar with .NET, but that turned out to be not important at all. One thing I can state is that I learned a lot, and I have never regretted my choice to use F#.</p>
<h3>What is DSP?</h3>
<h4>A Brief Definition</h4>
<p>In the analog world, physical quantities like electric currency are used to represent a signal that is finally sent to a speaker. These quantities are created and altered by low-level components like condensers, resistors, magnetic coils, transistors, and diods, which are connected to each others in circuits. They are composed in larger components like operational amplifiers that are used to build modules like filters and oscillators, which synthesizers and effect processors are made of. Digital audio signal processing (Audio DSP) is about modeling these components at different levels of abstraction, resulting in the simulation of circuits similar to their analog counterparts (of course, there is no limit to creating completely new forms of synthesizers and effects).</p>
<h4>Quantization of Time and Values</h4>
<p>Digital signal processing - in contrast to analog signal processing - deals with quantized values over a discrete time. Consider, for instance, an analog synthesizer. It creates and outputs a signal based on electric currency, which is continuous from a physical point of view. A computer cannot process values in a continuous way - it has to <em>quantize</em> two things:</p>
<p><strong>Time:</strong></p>
<p>This is called sampling, and it happens for an audio signal usually at multiples of 44100 times per second (44.1 kHz). Why 44100? Take a look at the <a href="https://en.wikipedia.org/wiki/Nyquist-Shannon_sampling_theorem">Nyquist-Shannon sampling theorem</a> (you do not have to read the Wikipedia article it to understand this article).</p>
<p><strong>Values:</strong></p>
<p>At each sample point, a value must be captured (analog to the electric currency). This happens usually in a number represented by a 16, 32 or 64 bit value. In this article, I use a F# "float" value, which is a 64 bit floating point number between <code>0.0</code> and <code>1.0</code> (normed to 0% .. 100% amplitude).</p>
<p>Having understood this definition, it's easy to define what a signal is.</p>
<statement>A signal is a value that changes over time.</statement>
<p>Sampling these values with constant time intervals results in a sequence of values.</p>
<p><img src="./sinus_wave.png" alt="Sin Wave" /></p>
<p>Here, I have captured a sine wave with the <em>amplitude</em> of 0.5 and a frequency of ca. 150Hz (assuming the x-scale is milliseconds, then I have three cycles in 0.02s = 150Hz). The sample rate is 1kHz because I have captured 20 samples in 0.02s. That makes 1000 samples in 1s. This is 1kHz.</p>
<p>Given that I have a sample rate of 16Hz, I can just a value sequence instead of a time-value sequence:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">[</span> <span class="n">0.0</span><span class="pn">;</span> <span class="n">0.4047782464</span><span class="pn">;</span> <span class="n">0.4752436455</span><span class="pn">;</span> <span class="n">0.1531976936</span><span class="pn">;</span> <span class="o">-</span><span class="n">0.2953766911</span><span class="pn">;</span> <span class="o">-</span><span class="n">0.499994728</span><span class="pn">;</span> <span class="c">(*and so on *)</span> <span class="pn">]</span>
</code></pre>
<p>The point in time of the the n-th value in the sequence can easily be calculated when sample rate and starting time are given. This fact is fundamental and leads to a definition of what <em>processing</em> means:</p>
<statement>DSP is about creating or changing sequence of values.</statement>
<p>That sounds very general - and it indeed is! The techniques introduced here have basically no specialization in terms of "sound" or "audio" - even if they fit well in that domain.</p>
<hint>
<p>For the sake of simplification, please note that the sample code won't use real-world parameters like <code>8000.0Hz</code>. Instead, pseudo values are used to create a comprehensive result and keep the code simple.</p>
</hint>
<h4>Real Time</h4>
<p>"Real Time" originally means that a system is able to react in a predefined timespan. That does not necessarily mean it has to be "fast" in the context of the problem, but only that it is reliable in terms of reaction time. Since making music mostly has a "live" character, this is a huge constraint that affects how computer music is made. An example: You composed a nice synth line, and now you want to apply your handwritten distortion effect to it. While it is playing, you want to tune parameters of your effect - and you expect to hear a change in sound <em>immediately</em>, which usually means in some 10 to 100 ms. When that timespan is longer, IMHO, it's not that fun anymore and is also harder because you are missing the direct feedback of your action.</p>
<p>As a consequence, you have to design systems that work on a per-sample basis instead of having random access to the whole input sequence. This means it is not possible to wait until the whole input signal (the synth line) is available and then apply your effect by mapping values. That amount of latency wouldn't be acceptable for the <em>most</em> use cases. Therefore, signal processing can be seen as some kind of <em>stream processing</em>.</p>
<h3>Distinction</h3>
<p>Audio DSP and computer music are broad fields. This article focuses on some aspects while only touching others or not discussing others. Here, I will list the key concepts and distinctions of this article.</p>
<ul>
<li>The focus is on creating and manipulating samples that finally may result in sounds, rather than on control signals or composition. It also does not discuss libraries for audio playback.</li>
<li>The article focuses on monophonic mono signals, although the concepts allow polyphony and multichannel signals.</li>
<li>There are no performance considerations in this article for the introduced concepts.</li>
<li>Signals are represented in the time domain, not in the frequency domain.</li>
</ul>
<h3>F# Getting Started</h3>
<p>F# is a concise and easy to learn language, since it has only a few, but powerful, key concepts and an easy to understand syntax. If you have never dealt with a language of the ML family, I recommend these sources for getting started with F#.</p>
<ul>
<li><a href="http://dungpa.github.io/fsharp-cheatsheet/">F# Cheat Sheet</a></li>
</ul>
<p>If[SGF16] you are familiar with a modern language like C#, Java, C++, JavaScript, TypeScript, Python (or whatever), this might be a good source for a kick start.</p>
<ul>
<li><a href="https://fsharpforfunandprofit.com/">F# for Fun and Profit (Scott Wlaschin)</a></li>
</ul>
<p>This was my primary source when I  was getting involved with F#, and I can definitely recommend it when you want to learn about the key concepts of functional programming. I recommend reading <a href="https://fsharpforfunandprofit.com/series/expressions-and-syntax.html">this</a>, <a href="https://fsharpforfunandprofit.com/posts/elevated-world-2/">this</a>, and <a href="https://fsharpforfunandprofit.com/posts/currying/#series-toc">this</a>.</p>
<ul>
<li><p>The book <em>Real-World Functional Programming: With Examples in F# and C#</em> by Tomas Petricek.</p></li>
<li><p>The book <em>Expert F# 4.0</em> by Don Syme et al. I especially recommend chapters 2 and 3, which capture the most common functional aspects of F#.</p></li>
</ul>
<h3>Setup and Samples</h3>
<p>A lot of code is presented in this article. Since no one has to believe that the things I'm telling here are true, you can easily reproduce and comprehend them by your own.</p>
<p>I recommend an easy setup consisting of the following tools.</p>
<ul>
<li><strong>Visual Studio Code</strong></li>
</ul>
<p>VS Code is a lightweight and free to use editor. Get it <a href="https://code.visualstudio.com/">here</a>!</p>
<ul>
<li><strong>Ionide</strong></li>
</ul>
<p>Ionide is a VS Code package suite for cross platform F# development. You can get it <a href="http://ionide.io/">here</a>.</p>
<p>On the Ionide homepage, you can see how to install F# for your platform (macOS, Windows, Linux).</p>
<ul>
<li><strong>F# Interactive</strong></li>
</ul>
<p>I recommend making yourself familiar with the concept of <em>interactive development</em>, which is called "F# Interactive". It is a playground for evaluating code snippets that are built upon each other, without setting up a whole development project. The concept and tools are well explained in the reference list above. Using VS Code and Ionide, you have everything you need to get started immediately.</p>
<h4>Article Sources</h4>
<p>There is a <a href="https://github.com/ronaldschlenker/challenge">github repository</a> that you can clone (or view online) with all the samples included.</p>
<p>Now you are equipped with everything you need, so let's get our hands into it!</p>
<h2>Writing Stateless Functions</h2>
<p>Since we now know what a signal is (a value that changes over time), that DSP is easy (dealing with sequences of values), and that we are interested in functions that transform scalar inputs into scalar outputs, let us start directly by writing a processing function. Later on, you will see how to compose these small functions to a larger system.</p>
<h3>Amplifier</h3>
<p>Amplifying signals is a science in itself. You could spend a lot of money buying analog gear that sounds just "right," but "right" is a subjective term based on a user's preferences. For us, a simple solution will be enough. Amplification of a signal in this context means scale values linearly. We can do that this way:</p>
<p><img src="./chart_input_and_amp.png" alt="Before Amp - After Amp" /></p>
<p>Linear scaling of a value is mathematically just a multiplication, so that is indeed very simple. This function does the job:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// float -&gt; float -&gt; float</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="id">amount</span> <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="id">input</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 5)" onmouseover="showTip(event, 'fs3', 5)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs2', 6)" onmouseover="showTip(event, 'fs2', 6)" class="id">amount</span>
</code></pre>
<h3>Another Example: Hard Limiter</h3>
<p>Now that we have our amplifier, we want to have the ability to <em>limit</em> a signal to a certain boundary. Again, there are a lot of ways to do this in a "nice" sounding way, but we will use a very simple technique that leads to a very harsh sounding distortion when the input signal gets limited. The limiter looks like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// float -&gt; float -&gt; float</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs5', 7)" onmouseover="showTip(event, 'fs5', 7)" class="fn">limit</span> <span onmouseout="hideTip(event, 'fs6', 8)" onmouseover="showTip(event, 'fs6', 8)" class="id">threshold</span> <span onmouseout="hideTip(event, 'fs3', 9)" onmouseover="showTip(event, 'fs3', 9)" class="id">input</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 10)" onmouseover="showTip(event, 'fs4', 10)" class="vt">float</span> <span class="o">=</span>
    <span class="k">if</span> <span onmouseout="hideTip(event, 'fs3', 11)" onmouseover="showTip(event, 'fs3', 11)" class="id">input</span> <span class="o">&gt;</span> <span onmouseout="hideTip(event, 'fs6', 12)" onmouseover="showTip(event, 'fs6', 12)" class="id">threshold</span> <span class="k">then</span> <span onmouseout="hideTip(event, 'fs6', 13)" onmouseover="showTip(event, 'fs6', 13)" class="id">threshold</span>
    <span class="k">else</span> <span class="k">if</span> <span onmouseout="hideTip(event, 'fs3', 14)" onmouseover="showTip(event, 'fs3', 14)" class="id">input</span> <span class="o">&lt;</span> <span class="o">-</span><span onmouseout="hideTip(event, 'fs6', 15)" onmouseover="showTip(event, 'fs6', 15)" class="id">threshold</span> <span class="k">then</span> <span class="o">-</span><span onmouseout="hideTip(event, 'fs6', 16)" onmouseover="showTip(event, 'fs6', 16)" class="id">threshold</span>
    <span class="k">else</span> <span onmouseout="hideTip(event, 'fs3', 17)" onmouseover="showTip(event, 'fs3', 17)" class="id">input</span>
</code></pre>
<excurs data-name="Types and Signatures">
<p>Note that in this case, we only write the resulting type (float). The types of <code>amount</code> and <code>input</code> are inferred, which means the compiler understands which type they are just by looking at the way they are used. We can also write it with explicit types for all input parameters:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 18)" onmouseover="showTip(event, 'fs1', 18)" class="fn">amp</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs2', 19)" onmouseover="showTip(event, 'fs2', 19)" class="id">amount</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 20)" onmouseover="showTip(event, 'fs4', 20)" class="vt">float</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs3', 21)" onmouseover="showTip(event, 'fs3', 21)" class="id">input</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 22)" onmouseover="showTip(event, 'fs4', 22)" class="vt">float</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 23)" onmouseover="showTip(event, 'fs4', 23)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 24)" onmouseover="showTip(event, 'fs3', 24)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs2', 25)" onmouseover="showTip(event, 'fs2', 25)" class="id">amount</span>
</code></pre>
<p>In the next samples, we will use the first variant so that we have some meaningful names for our parameters.</p>
</excurs>
<excurs data-name="Currying">
<p>Looking closely at the <code>amp</code> function, it becomes clear that we simply wrapped the <code>*</code> function (multiplication of two floats). Since F# "curries" functions by default, we can rewrite <code>amp.</code> If you want to take a deeper look into currying and the consequences it has, I recommend you go <a href="https://fsharpforfunandprofit.com/posts/currying/">here</a>.</p>
<p>In short, when the compiler curries a function, it transforms one function with n parameters into n nested functions, which each have one parameter.</p>
<p>In the case of <code>amp</code>, it would look like this (manual currying now):</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 26)" onmouseover="showTip(event, 'fs1', 26)" class="fn">amp</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs2', 27)" onmouseover="showTip(event, 'fs2', 27)" class="id">amount</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 28)" onmouseover="showTip(event, 'fs4', 28)" class="vt">float</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs3', 29)" onmouseover="showTip(event, 'fs3', 29)" class="id">input</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 30)" onmouseover="showTip(event, 'fs4', 30)" class="vt">float</span><span class="pn">)</span> <span class="k">-&gt;</span>
        <span onmouseout="hideTip(event, 'fs3', 31)" onmouseover="showTip(event, 'fs3', 31)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs2', 32)" onmouseover="showTip(event, 'fs2', 32)" class="id">amount</span>
</code></pre>
<p>And indeed, both ways of writing <code>amp</code> result in the same signature: <code>float -&gt; float -&gt; float</code>.</p>
<p>Since the F# compiler curries by default, we could now just leave out the last parameter because nothing would change.</p>
<p>Currying makes it simpler:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// (*) is now prefix style.</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs7', 33)" onmouseover="showTip(event, 'fs7', 33)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs8', 34)" onmouseover="showTip(event, 'fs8', 34)" class="id">amount</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 35)" onmouseover="showTip(event, 'fs4', 35)" class="vt">float</span> <span class="o">=</span> <span class="o">(*)</span> <span onmouseout="hideTip(event, 'fs8', 36)" onmouseover="showTip(event, 'fs8', 36)" class="id">amount</span>
</code></pre>
<p>Again, we could leave out amount, having defined just an alias for the (*) function:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs9', 37)" onmouseover="showTip(event, 'fs9', 37)" class="fn">amp</span> <span class="o">=</span> <span class="o">(*)</span>
</code></pre>
<p><strong>Why is that important?</strong></p>
<p>In our case (and in a whole lot of other cases), currying is extremely useful because it enables us to recognize functions as a kind of "factory function" for inner functions. Applying the first parameter to a function results in another function with the rest of the parameters. This is important when it comes to composing our processing functions.</p>
</excurs>
<h2>Composing Stateless Functions</h2>
<h3>Serial Composition</h3>
<p>The <code>amp</code> and <code>limit</code> functions are so small that we won't break them into smaller pieces to reuse them. They are kind of "atoms" in our context. But of course, we want to do the opposite: to compose them to larger, higher-level functions (that themselves can be composed again to higher-level functions, and so on).</p>
<p>Let's say we want to build a nice distortion effect that is defined in this way:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs10', 38)" onmouseover="showTip(event, 'fs10', 38)" class="fn">distort</span> <span onmouseout="hideTip(event, 'fs11', 39)" onmouseover="showTip(event, 'fs11', 39)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs12', 40)" onmouseover="showTip(event, 'fs12', 40)" class="id">i</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs13', 41)" onmouseover="showTip(event, 'fs13', 41)" class="id">amplified</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 42)" onmouseover="showTip(event, 'fs9', 42)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 43)" onmouseover="showTip(event, 'fs11', 43)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs12', 44)" onmouseover="showTip(event, 'fs12', 44)" class="id">i</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs14', 45)" onmouseover="showTip(event, 'fs14', 45)" class="id">limited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 46)" onmouseover="showTip(event, 'fs5', 46)" class="fn">limit</span> <span class="n">1.0</span> <span onmouseout="hideTip(event, 'fs13', 47)" onmouseover="showTip(event, 'fs13', 47)" class="id">amplified</span>
    <span onmouseout="hideTip(event, 'fs14', 48)" onmouseover="showTip(event, 'fs14', 48)" class="id">limited</span>
</code></pre>
<p>We can now visualize this function in a so-called <strong>block diagram</strong>:</p>
<p><img src="./bs_a.png" alt="Block diagram A" /></p>
<hint>
Note that in the block diagram, we assume all input parameters of a block as curried. The parameter order is from bottom to top.
</hint>
<p>The <code>drive</code> parameter controls how much distortion we want: 1 means no distortion, and the bigger the value gets means a lot of distortion. We achieve this by feeding the input into our amplifier. The output of the amp is then fed into a limiter. Let's call this technique of composition <strong>serial composition</strong>.</p>
<excurs data-name="Composition Alternatives">
<p>We use an explicit identifier (<code>amplified</code>, <code>result</code>) and evaluate our amp and limit functions. This can be a useful technique, e.g., when we want to reuse the <code>amplified</code> value in a more complex scenario (which we will see shortly). For serial composition, we can use alternatives to make our code more "compact":</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 49)" onmouseover="showTip(event, 'fs15', 49)" class="fn">distort1</span> <span onmouseout="hideTip(event, 'fs11', 50)" onmouseover="showTip(event, 'fs11', 50)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 51)" onmouseover="showTip(event, 'fs3', 51)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 52)" onmouseover="showTip(event, 'fs5', 52)" class="fn">limit</span> <span class="n">1.0</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs9', 53)" onmouseover="showTip(event, 'fs9', 53)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 54)" onmouseover="showTip(event, 'fs11', 54)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 55)" onmouseover="showTip(event, 'fs3', 55)" class="id">input</span><span class="pn">)</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs16', 56)" onmouseover="showTip(event, 'fs16', 56)" class="fn">distort2</span> <span onmouseout="hideTip(event, 'fs11', 57)" onmouseover="showTip(event, 'fs11', 57)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 58)" onmouseover="showTip(event, 'fs3', 58)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 59)" onmouseover="showTip(event, 'fs9', 59)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 60)" onmouseover="showTip(event, 'fs11', 60)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 61)" onmouseover="showTip(event, 'fs3', 61)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 62)" onmouseover="showTip(event, 'fs5', 62)" class="fn">limit</span> <span class="n">1.0</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs17', 63)" onmouseover="showTip(event, 'fs17', 63)" class="fn">distort3</span> <span onmouseout="hideTip(event, 'fs11', 64)" onmouseover="showTip(event, 'fs11', 64)" class="id">drive</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 65)" onmouseover="showTip(event, 'fs9', 65)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 66)" onmouseover="showTip(event, 'fs11', 66)" class="id">drive</span> <span class="o">&gt;</span><span class="pn">&gt;</span> <span onmouseout="hideTip(event, 'fs5', 67)" onmouseover="showTip(event, 'fs5', 67)" class="fn">limit</span> <span class="n">1.0</span>
</code></pre>
<ol>
<li><strong>Inline the expressions</strong></li>
</ol>
<p>This is a bit sad because the signal flow is reversed: it is written limit, then amp. But the order of evaluation is amp, then limit. To make our code look more like the actual signal flow, we can use:</p>
<ol>
<li><strong>Pipe operator</strong></li>
</ol>
<p>The pipe operator is explained <a href="https://fsharpforfunandprofit.com/posts/function-composition/">here</a> and basically boils down to this: it takes the value on the left side (in our case, it's a function that gets evaluated before the result gets piped) and feeds it to the function on the right side.</p>
<p>Now, having this in mind, remember the previous chapter, when I stated that currying is very important. Now we can see why: we said that we are interested in functions of form <code>float -&gt; float</code>, and now it's clear why: it enables us to compose functions always in the same manner. But when we review our <code>amp</code> function (and also the limit function), we see that they are <code>float -&gt; float -&gt; float</code>. This is because they not only transform an input value into an output value, but they also require an additional parameter to control their behavior. This is important: we have to design our "factory functions" (curried functions) so that all parameters come first and then are followed by the input value to have a <code>float -&gt; float</code> function at the end that can easily be composed. When things get more complex in the next section, the technique of currying will help us a lot.</p>
<ol>
<li><strong>Forward Composition Operator</strong></li>
</ol>
<p>This is a nice way of composition because it is just a "construction manual" for a signal flow. Neither of the two given functions is evaluated at all. The two functions are just combined to a bigger one and evaluated only when used.</p>
<p>In the following code samples, we will use all these composition techniques, depending on the use case. There is no "right or wrong," just a "better fit in this case" or even just a user's preference.</p>
</excurs>
<h3>Parallel Composition (Branch and Merge)</h3>
<hint>
Parallel composition does not necessarily mean that branches are executed in parallel from a threading/timing point of view. In the case of this article, branches are executed one after another.
</hint>
<p>Now that we understand what serial composition is, we know it is useful to have functions of type <code>float -&gt; float</code>, and we understand that serial composition of these functions can be done by using the <code>&gt;&gt;</code> or <code>|&gt;</code> operators.</p>
<p>Let's extend our sample in a way in which the techniques of serial composition is not sufficient.</p>
<p>The distortion effect we just engineered sounds nice, and we want to be able to "blend it in" together with a low pass filtered version of the original signal. Low pass filter means we want to get rid of the high frequencies that may sound "harsh", and preserve only the low frequencies. At the end, the whole result will be faded in over a certain time and output-gained (amplified). Visualizing this in a block diagram is easy:</p>
<p><img src="./bs_b.png" alt="Block diagram B" /></p>
<p>Some things to note on the block diagram are:</p>
<ul>
<li>the output value of "amp" is used in two following branches;</li>
<li>the output values of the two branches are then aggregated by the "mix" block;</li>
<li>the output value can then be processed further by the "fadeIn" block; and</li>
<li>we have an output gain to lower the signal's strength.</li>
</ul>
<p>Now we will look at a technique whereby we can translate this behavior to F# code. Think about what "branching" means: "use an evaluated value in more than one place in the rest of a computation."</p>
<p>As usual, there are a lot of ways to achieve this. I recommend taking some time and thinking about how this could be done. In our sample, we bind meaningful values to identifiers:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 596)" onmouseover="showTip(event, 'fs18', 596)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs11', 597)" onmouseover="showTip(event, 'fs11', 597)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 598)" onmouseover="showTip(event, 'fs3', 598)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 599)" onmouseover="showTip(event, 'fs19', 599)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 600)" onmouseover="showTip(event, 'fs3', 600)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 601)" onmouseover="showTip(event, 'fs9', 601)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 602)" onmouseover="showTip(event, 'fs11', 602)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 603)" onmouseover="showTip(event, 'fs20', 603)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 604)" onmouseover="showTip(event, 'fs19', 604)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 605)" onmouseover="showTip(event, 'fs5', 605)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 606)" onmouseover="showTip(event, 'fs21', 606)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 607)" onmouseover="showTip(event, 'fs19', 607)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 608)" onmouseover="showTip(event, 'fs22', 608)" class="fn">lowPass</span> <span class="n">0.2</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 609)" onmouseover="showTip(event, 'fs23', 609)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 610)" onmouseover="showTip(event, 'fs24', 610)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 611)" onmouseover="showTip(event, 'fs20', 611)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs21', 612)" onmouseover="showTip(event, 'fs21', 612)" class="id">softLimited</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 613)" onmouseover="showTip(event, 'fs25', 613)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 614)" onmouseover="showTip(event, 'fs23', 614)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 615)" onmouseover="showTip(event, 'fs26', 615)" class="fn">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 616)" onmouseover="showTip(event, 'fs27', 616)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 617)" onmouseover="showTip(event, 'fs9', 617)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 618)" onmouseover="showTip(event, 'fs25', 618)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 619)" onmouseover="showTip(event, 'fs27', 619)" class="id">gained</span>
</code></pre>
<p>By introducing the "amped" identifier, we are able to use its value in more than one place in the rest of our computation. Merging is nothing more than feeding evaluated branches into an appropriate function. Of course, there are other ways of writing this code.</p>
<excurs data-name="Alternatives">
<p>Let's focus on <code>hardLimited,</code> <code>softLimited</code> and <code>mixed</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs28', 92)" onmouseover="showTip(event, 'fs28', 92)" class="fn">blendedDistortion_Alt1</span> <span onmouseout="hideTip(event, 'fs11', 93)" onmouseover="showTip(event, 'fs11', 93)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 94)" onmouseover="showTip(event, 'fs3', 94)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 95)" onmouseover="showTip(event, 'fs19', 95)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 96)" onmouseover="showTip(event, 'fs3', 96)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 97)" onmouseover="showTip(event, 'fs9', 97)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 98)" onmouseover="showTip(event, 'fs11', 98)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs29', 99)" onmouseover="showTip(event, 'fs29', 99)" class="id">mixed</span> <span class="o">=</span>
        <span class="id">mix</span> <span class="n">0.5</span> 
            <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 100)" onmouseover="showTip(event, 'fs19', 100)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 101)" onmouseover="showTip(event, 'fs5', 101)" class="id">limit</span> <span class="n">0.7</span><span class="pn">)</span>
            <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 102)" onmouseover="showTip(event, 'fs19', 102)" class="id">amped</span> <span class="o">|&gt;</span> <span class="id">lowPass</span> <span class="n">0.2</span><span class="pn">)</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs30', 103)" onmouseover="showTip(event, 'fs30', 103)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs29', 104)" onmouseover="showTip(event, 'fs29', 104)" class="id">mixed</span> <span class="o">|&gt;</span> <span class="id">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 105)" onmouseover="showTip(event, 'fs27', 105)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 106)" onmouseover="showTip(event, 'fs9', 106)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 107)" onmouseover="showTip(event, 'fs30', 107)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 108)" onmouseover="showTip(event, 'fs27', 108)" class="id">gained</span>
</code></pre>
<p>In this code sample, we didn't use identifiers, but passed the two branches directly to the mix function as arguments.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs31', 109)" onmouseover="showTip(event, 'fs31', 109)" class="fn">blendedDistortion_Alt2</span> <span onmouseout="hideTip(event, 'fs11', 110)" onmouseover="showTip(event, 'fs11', 110)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 111)" onmouseover="showTip(event, 'fs3', 111)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 112)" onmouseover="showTip(event, 'fs19', 112)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 113)" onmouseover="showTip(event, 'fs3', 113)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 114)" onmouseover="showTip(event, 'fs9', 114)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 115)" onmouseover="showTip(event, 'fs11', 115)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs29', 116)" onmouseover="showTip(event, 'fs29', 116)" class="id">mixed</span> <span class="o">=</span>
        <span class="pn">(</span>
            <span onmouseout="hideTip(event, 'fs19', 117)" onmouseover="showTip(event, 'fs19', 117)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 118)" onmouseover="showTip(event, 'fs5', 118)" class="fn">limit</span> <span class="n">0.7</span><span class="pn">,</span>       <span class="c">// a: First branch: hardLimited</span>
            <span onmouseout="hideTip(event, 'fs19', 119)" onmouseover="showTip(event, 'fs19', 119)" class="id">amped</span> <span class="o">|&gt;</span> <span class="id">lowPass</span> <span class="n">0.2</span>      <span class="c">// b: Second Branch: softLimited</span>
        <span class="pn">)</span>
        <span class="o">||&gt;</span> <span class="id">mix</span> <span class="n">0.5</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs30', 120)" onmouseover="showTip(event, 'fs30', 120)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs29', 121)" onmouseover="showTip(event, 'fs29', 121)" class="id">mixed</span> <span class="o">|&gt;</span> <span class="id">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 122)" onmouseover="showTip(event, 'fs27', 122)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 123)" onmouseover="showTip(event, 'fs9', 123)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 124)" onmouseover="showTip(event, 'fs30', 124)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 125)" onmouseover="showTip(event, 'fs27', 125)" class="id">gained</span>
</code></pre>
<p>There is also the <code>||&gt;</code> operator: it takes a tuple (in our case, the two branches) and feeds it into a two-curried parameter function (in our case, <code>mix 0.5</code> evaluates to a two-parameter function).</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// ALt. 2: right-to-left pipe forward operator</span>
<span class="c">// Non idiomativ F#</span>

<span class="k">let</span> <span class="k">inline</span> <span class="pn">(</span> <span class="o">^|&gt;</span> <span class="pn">)</span> <span onmouseout="hideTip(event, 'fs32', 126)" onmouseover="showTip(event, 'fs32', 126)" class="id">x</span> <span onmouseout="hideTip(event, 'fs33', 127)" onmouseover="showTip(event, 'fs33', 127)" class="fn">f</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs33', 128)" onmouseover="showTip(event, 'fs33', 128)" class="fn">f</span> <span onmouseout="hideTip(event, 'fs32', 129)" onmouseover="showTip(event, 'fs32', 129)" class="id">x</span> 

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs34', 130)" onmouseover="showTip(event, 'fs34', 130)" class="fn">blendedDistortion_Alt3</span> <span onmouseout="hideTip(event, 'fs11', 131)" onmouseover="showTip(event, 'fs11', 131)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 132)" onmouseover="showTip(event, 'fs3', 132)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 133)" onmouseover="showTip(event, 'fs19', 133)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 134)" onmouseover="showTip(event, 'fs3', 134)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 135)" onmouseover="showTip(event, 'fs9', 135)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 136)" onmouseover="showTip(event, 'fs11', 136)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs29', 137)" onmouseover="showTip(event, 'fs29', 137)" class="id">mixed</span> <span class="o">=</span>
        <span class="pn">(</span>
            <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 138)" onmouseover="showTip(event, 'fs19', 138)" class="id">amped</span> <span class="o">|&gt;</span> <span class="id">lowPass</span> <span class="n">0.2</span><span class="pn">)</span>     <span class="c">// b: Second Branch: softLimited</span>
            <span class="o">^|&gt;</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 139)" onmouseover="showTip(event, 'fs19', 139)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 140)" onmouseover="showTip(event, 'fs5', 140)" class="fn">limit</span> <span class="n">0.7</span><span class="pn">)</span>   <span class="c">// a: First branch: hardLimited</span>
            <span class="o">^|&gt;</span> <span class="id">mix</span> <span class="n">0.5</span>
        <span class="pn">)</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs30', 141)" onmouseover="showTip(event, 'fs30', 141)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs29', 142)" onmouseover="showTip(event, 'fs29', 142)" class="id">mixed</span> <span class="o">|&gt;</span> <span class="id">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 143)" onmouseover="showTip(event, 'fs27', 143)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 144)" onmouseover="showTip(event, 'fs9', 144)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 145)" onmouseover="showTip(event, 'fs30', 145)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 146)" onmouseover="showTip(event, 'fs27', 146)" class="id">gained</span>
</code></pre>
<p>There is also the possibility of defining an own operator: using the <code>^</code> symbol before an operator makes the operator have a right associativity. This means that evaluation is not from left to right, but from right to left. In our case, the <code>mix 0.5</code> function is evaluated to a two-parameter function. Branch <code>b</code> is passed to that function (a one-parameter function remains), and then branch 'a' is passed to it. Note that (even for <code>mix,</code> it wouldn't matter) we have to switch the order of arguments (first b, then a) to achieve the same order as in the previous samples.</p>
<p>You can even test our operator on your own:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs35', 147)" onmouseover="showTip(event, 'fs35', 147)" class="fn">mix4</span> <span onmouseout="hideTip(event, 'fs36', 148)" onmouseover="showTip(event, 'fs36', 148)" class="id">a</span> <span onmouseout="hideTip(event, 'fs37', 149)" onmouseover="showTip(event, 'fs37', 149)" class="id">b</span> <span onmouseout="hideTip(event, 'fs38', 150)" onmouseover="showTip(event, 'fs38', 150)" class="id">c</span> <span onmouseout="hideTip(event, 'fs39', 151)" onmouseover="showTip(event, 'fs39', 151)" class="id">d</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs40', 152)" onmouseover="showTip(event, 'fs40', 152)" class="fn">sprintf</span> <span class="s">&quot;</span><span class="pf">%A</span><span class="s"> </span><span class="pf">%A</span><span class="s"> </span><span class="pf">%A</span><span class="s"> </span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs36', 153)" onmouseover="showTip(event, 'fs36', 153)" class="id">a</span> <span onmouseout="hideTip(event, 'fs37', 154)" onmouseover="showTip(event, 'fs37', 154)" class="id">b</span> <span onmouseout="hideTip(event, 'fs38', 155)" onmouseover="showTip(event, 'fs38', 155)" class="id">c</span> <span onmouseout="hideTip(event, 'fs39', 156)" onmouseover="showTip(event, 'fs39', 156)" class="id">d</span>

<span class="n">1.0</span>
<span class="o">^|&gt;</span> <span class="n">2.0</span>
<span class="o">^|&gt;</span> <span class="n">3.0</span>
<span class="o">^|&gt;</span> <span class="n">4.0</span>
<span class="o">^|&gt;</span> <span onmouseout="hideTip(event, 'fs35', 157)" onmouseover="showTip(event, 'fs35', 157)" class="fn">mix4</span>

<span class="c">// evaluates to: &quot;4.0 3.0 2.0 1.0&quot;</span>
</code></pre>
<p>Note that is not an idiomatic F# way, and I won't use it in the upcoming code samples.</p>
</excurs>
<h4>A Note on "lowPass" and "fadeIn":</h4>
<p>Note that for now, we do not have a working low pass filter implementation, so we just use a placeholder function that works like a normal stateless processing function of type <code>float -&gt; float</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs41', 158)" onmouseover="showTip(event, 'fs41', 158)" class="fn">lowPass</span> <span onmouseout="hideTip(event, 'fs42', 159)" onmouseover="showTip(event, 'fs42', 159)" class="id">frq</span> <span onmouseout="hideTip(event, 'fs3', 160)" onmouseover="showTip(event, 'fs3', 160)" class="id">input</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 161)" onmouseover="showTip(event, 'fs4', 161)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 162)" onmouseover="showTip(event, 'fs3', 162)" class="id">input</span> <span class="c">// just a dummy - for now...</span>
</code></pre>
<p>The same is for fadeIn:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs43', 163)" onmouseover="showTip(event, 'fs43', 163)" class="fn">fadeIn</span> <span onmouseout="hideTip(event, 'fs44', 164)" onmouseover="showTip(event, 'fs44', 164)" class="id">stepSize</span> <span onmouseout="hideTip(event, 'fs3', 165)" onmouseover="showTip(event, 'fs3', 165)" class="id">input</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 166)" onmouseover="showTip(event, 'fs4', 166)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 167)" onmouseover="showTip(event, 'fs3', 167)" class="id">input</span> <span class="c">// just a dummy - for now...</span>
</code></pre>
<h4>A Note on "mix":</h4>
<p>We need a "mix" function that has a <code>abRatio</code> parameter to control the amount of both incoming values in the final output. 0 means only signal a; 1 means only signal b.</p>
<p>The function is this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs24', 168)" onmouseover="showTip(event, 'fs24', 168)" class="fn">mix</span> <span onmouseout="hideTip(event, 'fs45', 169)" onmouseover="showTip(event, 'fs45', 169)" class="id">abRatio</span> <span onmouseout="hideTip(event, 'fs46', 170)" onmouseover="showTip(event, 'fs46', 170)" class="id">a</span> <span onmouseout="hideTip(event, 'fs47', 171)" onmouseover="showTip(event, 'fs47', 171)" class="id">b</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 172)" onmouseover="showTip(event, 'fs4', 172)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs46', 173)" onmouseover="showTip(event, 'fs46', 173)" class="id">a</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs45', 174)" onmouseover="showTip(event, 'fs45', 174)" class="id">abRatio</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs47', 175)" onmouseover="showTip(event, 'fs47', 175)" class="id">b</span> <span class="o">*</span> <span class="pn">(</span><span class="n">1.0</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs45', 176)" onmouseover="showTip(event, 'fs45', 176)" class="id">abRatio</span><span class="pn">)</span>
</code></pre>
<p>You can test it with:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs24', 177)" onmouseover="showTip(event, 'fs24', 177)" class="fn">mix</span> <span class="n">0.0</span> <span class="n">0.3</span> <span class="n">0.8</span> <span class="o">=</span> <span class="n">0.3</span>  <span class="c">// true</span>
<span onmouseout="hideTip(event, 'fs24', 178)" onmouseover="showTip(event, 'fs24', 178)" class="fn">mix</span> <span class="n">0.5</span> <span class="n">0.3</span> <span class="n">0.8</span> <span class="o">=</span> <span class="n">0.55</span> <span class="c">// true</span>
<span onmouseout="hideTip(event, 'fs24', 179)" onmouseover="showTip(event, 'fs24', 179)" class="fn">mix</span> <span class="n">1.0</span> <span class="n">0.3</span> <span class="n">0.8</span> <span class="o">=</span> <span class="n">0.8</span>  <span class="c">// true</span>
</code></pre>
<h2>Writing Stateful Functions</h2>
<p>In the previous chapters, we wrote and composed pure (stateless) functions. This means that processing a signal (= a sequence of values) was made up of the following "recipe":</p>
<ul>
<li>we have a sequence of input values;</li>
<li>we have processing functions;</li>
<li>we can compose these functions in several ways;</li>
<li>these functions are curried, so that after application of all parameters, functions of <code>float -&gt; float</code> remain; and</li>
<li>we have a "runtime" that generates an output sequence by mapping each value in the input sequence to a value in the output sequence by applying a processing function to the input value.</li>
</ul>
<h3>Revisit Low Pass Filter</h3>
<p>Until now, we treated the lowPass filter function as if it was pure, which means that from evaluation cycle to cycle, it does not "remember" anything; there is no information preserved between evaluations of the same function. In case of a filter, this cannot work, because filters need more than a single value: they deal with frequencies, and the concept of frequency requires a timespan. It's about how a sequence of values change over time. It's like with stock prices: you cannot say if there was a crash or if the market is hot by just looking at the current value. You need to look at the development of a price during a certain timespan. There are more things: some filters only need some past input values (FIR, finite impulse response). But there are other filter designs that depend on their past output values (IIR, infinite impulse response). So we need a mechanism that preserves past input, past output (and maybe past intermediate) <strong>state</strong>.</p>
<excurs data-name="Very Brief theory of a low pass filter">
<p>To understand what this means, we look at how a low pass filter can be designed.</p>
<p>The simplest way of designing an electronic low pass is using a resistor and a condenser in series, which is then connected to a currency that represents the input signal (<code>Ue</code>). The output signal is the currency of the condenser (<code>Ua</code>). So why is that a low pass filter?</p>
<p><img src="./rc_glied.png" alt="Resistor Condenser" /></p>
<p><strong>Resistor:</strong></p>
<p>It works like a valve in a water pipe: it limits the possibility of electrons to flow around. When you connect the poles of a battery to each other, you will get a shortcut, because the electrons can go from one pole to the other without any obstacle (and releasing the battery's energy in a very short amount of time). But if you connect the poles to a resistor (e.g., a glowing lamp), the electron flow is limited (thus releasing the energy in a much longer timespan).</p>
<p><strong>Condensor:</strong></p>
<p>Basically, it works like a battery - it can store and release energy, but much faster. It is made up of two poles (e.g., metal plates). Each plate can be charged up with a certain amount of electrons; the more electrons it has, the higher the currency measured between the two plates. Connecting a currency to each plate, the electrons will flow from the one pole of the currency to the connected plate of the condenser, and the electrons from the other condenser plate will flow to the other pole of the currency. <em>After some time</em> (which depends on the dimension of the resistor), the condenser has the same voltage as the currency, and it is then fully loaded. If you switch the connected currency poles (+ <> -), the condenser will first unload and then load again with switched voltages until it is in balance with the currency again.</p>
<p>Since the currency represents our input signal, we can say:</p>
<ul>
<li>high frequency is a fast change of currency; and</li>
<li>high frequency is a slow change of currency.</li>
</ul>
<p>Thus, when the input currency changes very quickly (high frequency), the condenser does not have enough time to fill itself up with electrons, and if we measure its voltage, it will not change. When the input currency changes slowly, the condenser has time for its load and unload cycle, so we will be able to measure a voltage change (which equals approximately the input signal after a longer time when the input frequency is 0).</p>
<p>And that's the low pass filter: low input frequencies can be measured at the condenser output, but high frequencies have no effect on the measured condenser output currency.</p>
<p>The key point for this is: the condenser brings the time into the game. It has state, which is made up of the "current electron load." The next moment's output value is made up of the last moment's internal value and a current external input value.</p>
</excurs>
<p>How can that be modeled?</p>
<h4>State in the Block Diagram</h4>
<p>Let's describe the characteristics of this lowPass filter in a textual way.</p>
<ol>
<li>An instance of lowPass filter has a state that represents the load amount. In our case, that state is proportional to the output value (like the amount of electrons is proportional to the output currency of the condenser).</li>
<li>
<p>The "calculation recipe" for the output value from one moment to the next moment is this.</p>
<ul>
<li><p>Take the output value from the last evaluation (which we call <code>lastOut</code>).</p></li>
<li><p>Take the difference between <code>lastOut</code> and the <code>current input.</code></p></li>
<li>Multiply that difference with a given time constant (to slow down the load time and thus adjust the filter's frequency).</li>
<li>The current output value is that difference subtracted from lastOut.</li>
</ul>
</li>
</ol>
<p>That's it. Think about it: the bigger the difference between current input and the last output value, the faster the condenser "loads up." The smaller the time constant gets, the slower the system reacts to input value changes - a low pass filter!</p>
<p>Let's see how we can implement it in a block diagram:</p>
<p><img src="./bs_delay.png" alt="Low pass filter" /></p>
<p>One interesting thing to note is there is no explicit state in the way that we store or memorize values. Instead, the state is modeled as "output value delayed by 1 sample" ("delay_1" block), which is then fed back into the next evaluation of the whole function. <strong>This is a key point</strong> because we can model any kind of local state in that way - no matter how that state is structured (it does not have to be a simple <code>float</code> - it could be anything). A abstract "block with state" can then be modeled like this:</p>
<p><img src="./bs_block_with_state.png" alt="Block with state and parameters" /></p>
<p>Besides the output value, there is an output state. And beside the input value, there comes an input state that is the output state from the last evaluation (plus the curried function parameters that come first, as usual).</p>
<p>In the next chapters, we will look at ways of writing and composing such functions, and we will understand that these ways provide less or more comfort for the user who wants to express signal processing computations.</p>
<p>We start with an object oriented programming approach.</p>
<h2>Composing Stateful Objects</h2>
<hint>
<p>See [src/2<em>Stateful</em>OOP.fsx] as sample source.</p>
</hint>
<p>As the name implies, we are first going to use an approach called "Object Oriented Programming." If you do not know what that is, read this:</p>
<excurs data-name="OOP">
<p>"Object oriented programming (OOP) is the thing with classes."</p>
<p>IMHO, that's not true (at least, it's not the key point). It's true that many object-oriented programming languages have a class-based type system, but that's not the essence of OOP. Another definition of what OOP might be is when three things occur together:</p>
<ul>
<li>References: Data are held in objects that have a referential identity (not a value-based identity), and references are shared.</li>
<li>Mutability: Object values can change over time, while their identities remain (objects are mutable).</li>
<li>Encapsulation: Data are "protected" by behavior (methods) to help ensure consistency during runtime (encapsulation of local state).</li>
</ul>
<p>These three characteristics can be seen as features, but at the same time, you have to deal with their consequences, and this has significant impact on how code is written, understood, and used.</p>
</excurs>
<p>The upcoming OOP samples use non-class techniques with functions as objects and closures that capture mutable state. The approach is still object oriented as I've defined it, and it could be easily transformed into code with classes, leading to the same insights. But whether you use a class-based or non-class-based OOP approach, they differ fundamentally from a purely functional approach in which we have no effects (no mutation) and only values (no references).</p>
<h3>"lowPass" and "fadeIn" in OOP</h3>
<h4>Implementation</h4>
<p>Here is the implementation of the low pass in F# with OOP techniques:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs48', 180)" onmouseover="showTip(event, 'fs48', 180)" class="fn">lowPassCtor</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, 'fs49', 181)" onmouseover="showTip(event, 'fs49', 181)" class="mv">lastOut</span> <span class="o">=</span> <span class="n">0.0</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs50', 182)" onmouseover="showTip(event, 'fs50', 182)" class="id">timeConstant</span> <span onmouseout="hideTip(event, 'fs3', 183)" onmouseover="showTip(event, 'fs3', 183)" class="id">input</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs51', 184)" onmouseover="showTip(event, 'fs51', 184)" class="id">diff</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs49', 185)" onmouseover="showTip(event, 'fs49', 185)" class="mv">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs3', 186)" onmouseover="showTip(event, 'fs3', 186)" class="id">input</span>
        <span onmouseout="hideTip(event, 'fs49', 187)" onmouseover="showTip(event, 'fs49', 187)" class="mv">lastOut</span> <span class="k">&lt;-</span> <span onmouseout="hideTip(event, 'fs49', 188)" onmouseover="showTip(event, 'fs49', 188)" class="mv">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs51', 189)" onmouseover="showTip(event, 'fs51', 189)" class="id">diff</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs50', 190)" onmouseover="showTip(event, 'fs50', 190)" class="id">timeConstant</span>
        <span onmouseout="hideTip(event, 'fs49', 191)" onmouseover="showTip(event, 'fs49', 191)" class="mv">lastOut</span>
</code></pre>
<p>What we have here:</p>
<ul>
<li>the <code>lowPassCtor</code> is a factory function that evaluates to another function (sounds like currying, but we cannot use automatic currying here since we capture mutable state);</li>
<li>this resulting function can be evaluated giving a timeConstant parameter and an input value (it is again a function of <code>float -&gt; float</code> after applying all parameters except input); and</li>
<li>it captures a mutable <code>lastOut</code> value that is initialized once when the <code>lowPassCtor</code> factory is called. That value changes each time the resulting function is evaluated.</li>
</ul>
<p>The same is for <code>fadeIn</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs52', 192)" onmouseover="showTip(event, 'fs52', 192)" class="fn">fadeInCtor</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, 'fs53', 193)" onmouseover="showTip(event, 'fs53', 193)" class="mv">lastValue</span> <span class="o">=</span> <span class="n">0.0</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs54', 194)" onmouseover="showTip(event, 'fs54', 194)" class="id">stepSize</span> <span onmouseout="hideTip(event, 'fs3', 195)" onmouseover="showTip(event, 'fs3', 195)" class="id">input</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs55', 196)" onmouseover="showTip(event, 'fs55', 196)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 197)" onmouseover="showTip(event, 'fs3', 197)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs53', 198)" onmouseover="showTip(event, 'fs53', 198)" class="mv">lastValue</span>
        <span onmouseout="hideTip(event, 'fs53', 199)" onmouseover="showTip(event, 'fs53', 199)" class="mv">lastValue</span> <span class="k">&lt;-</span> <span onmouseout="hideTip(event, 'fs56', 200)" onmouseover="showTip(event, 'fs56', 200)" class="fn">min</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs53', 201)" onmouseover="showTip(event, 'fs53', 201)" class="mv">lastValue</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs54', 202)" onmouseover="showTip(event, 'fs54', 202)" class="id">stepSize</span><span class="pn">)</span> <span class="n">1.0</span>
        <span onmouseout="hideTip(event, 'fs55', 203)" onmouseover="showTip(event, 'fs55', 203)" class="id">result</span>
</code></pre>
<h4>Usage</h4>
<p>In the previous chapter, we have already seen how we <em>would like</em> to use the low pass filter: Like a pure function. Here is again how:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// that compiles, but doesn&#39;t work.    </span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 204)" onmouseover="showTip(event, 'fs18', 204)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs11', 205)" onmouseover="showTip(event, 'fs11', 205)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 206)" onmouseover="showTip(event, 'fs3', 206)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 207)" onmouseover="showTip(event, 'fs19', 207)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 208)" onmouseover="showTip(event, 'fs3', 208)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 209)" onmouseover="showTip(event, 'fs9', 209)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 210)" onmouseover="showTip(event, 'fs11', 210)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 211)" onmouseover="showTip(event, 'fs20', 211)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 212)" onmouseover="showTip(event, 'fs19', 212)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 213)" onmouseover="showTip(event, 'fs5', 213)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs57', 214)" onmouseover="showTip(event, 'fs57', 214)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 215)" onmouseover="showTip(event, 'fs19', 215)" class="id">amped</span> <span class="o">|&gt;</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs48', 216)" onmouseover="showTip(event, 'fs48', 216)" class="fn">lowPassCtor</span><span class="pn">(</span><span class="pn">)</span><span class="pn">)</span> <span class="n">0.2</span>      <span class="c">// we would like to use lowPassCtor</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 217)" onmouseover="showTip(event, 'fs23', 217)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 218)" onmouseover="showTip(event, 'fs24', 218)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 219)" onmouseover="showTip(event, 'fs20', 219)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs57', 220)" onmouseover="showTip(event, 'fs57', 220)" class="id">softLimited</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs30', 221)" onmouseover="showTip(event, 'fs30', 221)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 222)" onmouseover="showTip(event, 'fs23', 222)" class="id">mixed</span> <span class="o">|&gt;</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs52', 223)" onmouseover="showTip(event, 'fs52', 223)" class="fn">fadeInCtor</span><span class="pn">(</span><span class="pn">)</span><span class="pn">)</span> <span class="n">0.1</span>           <span class="c">// we would like to use fadeInCtor</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 224)" onmouseover="showTip(event, 'fs27', 224)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 225)" onmouseover="showTip(event, 'fs9', 225)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 226)" onmouseover="showTip(event, 'fs30', 226)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 227)" onmouseover="showTip(event, 'fs27', 227)" class="id">gained</span>
</code></pre>
<p>But this won't work anymore. We cannot just insert <code>lowPassCtor</code> in a pure computation. But why not, since the compiler allows that? Answer: The <code>blendedDistortion</code> function itself is pure: when it is evaluated multiple times, it always creates a "new" lowPass by calling the lowPassCtor function, with lowPass's mutable <code>lastOut</code> field set to <code>0.0</code>. It would never calculate anything useful.</p>
<p>This issue can be solved by creating <code>lowPass</code> and <code>fadeIn</code> instances up front and capturing that reference in a closure. In doing so, we have to change our <code>blendedDistortion</code> processing function to a factory function (analog to the <code>lowPassCtor</code>):</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs58', 228)" onmouseover="showTip(event, 'fs58', 228)" class="fn">blendedDistortionCtor</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>

    <span class="c">// create and hold references to stateful objects</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs59', 229)" onmouseover="showTip(event, 'fs59', 229)" class="fn">lowPassInstance</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs48', 230)" onmouseover="showTip(event, 'fs48', 230)" class="fn">lowPassCtor</span><span class="pn">(</span><span class="pn">)</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs60', 231)" onmouseover="showTip(event, 'fs60', 231)" class="fn">fadeInInstance</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 232)" onmouseover="showTip(event, 'fs52', 232)" class="fn">fadeInCtor</span><span class="pn">(</span><span class="pn">)</span>

    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs11', 233)" onmouseover="showTip(event, 'fs11', 233)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 234)" onmouseover="showTip(event, 'fs3', 234)" class="id">input</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 235)" onmouseover="showTip(event, 'fs19', 235)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 236)" onmouseover="showTip(event, 'fs3', 236)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 237)" onmouseover="showTip(event, 'fs9', 237)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 238)" onmouseover="showTip(event, 'fs11', 238)" class="id">drive</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 239)" onmouseover="showTip(event, 'fs20', 239)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 240)" onmouseover="showTip(event, 'fs19', 240)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 241)" onmouseover="showTip(event, 'fs5', 241)" class="fn">limit</span> <span class="n">0.7</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs61', 242)" onmouseover="showTip(event, 'fs61', 242)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 243)" onmouseover="showTip(event, 'fs19', 243)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs59', 244)" onmouseover="showTip(event, 'fs59', 244)" class="fn">lowPassInstance</span> <span class="o">=</span> <span class="n">0.2</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 245)" onmouseover="showTip(event, 'fs23', 245)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 246)" onmouseover="showTip(event, 'fs24', 246)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 247)" onmouseover="showTip(event, 'fs20', 247)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs61', 248)" onmouseover="showTip(event, 'fs61', 248)" class="id">softLimited</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs30', 249)" onmouseover="showTip(event, 'fs30', 249)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 250)" onmouseover="showTip(event, 'fs23', 250)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs60', 251)" onmouseover="showTip(event, 'fs60', 251)" class="fn">fadeInInstance</span> <span class="n">0.1</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 252)" onmouseover="showTip(event, 'fs27', 252)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 253)" onmouseover="showTip(event, 'fs9', 253)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 254)" onmouseover="showTip(event, 'fs30', 254)" class="id">fadedIn</span>
        <span onmouseout="hideTip(event, 'fs27', 255)" onmouseover="showTip(event, 'fs27', 255)" class="id">gained</span>
</code></pre>
<p>That works! But: It's a burden for the user. Every time a stateful function is needed, it has to be declared before it can be used inside of the computation, and the instance has to be removed when it is not needed anymore. When authoring more complex effects or synthesizers, this can be a major pain. The user's focus is modeling a DSP computation and not instance management. Since instance management is something that has to be done, it draws away attention from the primary goal and interrupts the workflow of the programmer.</p>
<p>So what can be done to abstract instance management?</p>
<p>Look again at this block diagram from before:</p>
<p><img src="./bs_b.png" alt="Block diagram B" /></p>
<p>There is one important thing to notice: blocks themselves are not explicitly instanciated and then referenced by an identifier in the computation. They just sit in the place where they are used. They are kind of "inlined," even if they carry their own local state.</p>
<p>So it seems that in contrast to OOP, block diagrams work like this:</p>
<statement>A function with state is not identified by a reference, but by its position inside a computation.</statement>
<p>This is also the case when composing pure functions, and this is what we want to achieve:</p>
<statement>Finding a way of treating stateful functions as if they were pure functions.</statement>
<p>How can we do that?</p>
<p>We have to switch the way <strong>references</strong> are defined, from:</p>
<blockquote>
<p>a reference is made up of a unique address in a global address space</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>a reference is made up of
<em> a data structure that is implicitly defined by a computation, plus
</em> a local offset inside that computation.</p>
</blockquote>
<p>Reaching this goal means the user does not have to deal with instance management, because the aspect of local state would simply result from the way a computation is built by the user.</p>
<h2>Writing Stateful Functions</h2>
<p>First, let's look again at the block diagram that defines a stateful function:</p>
<p><img src="./bs_block_with_state.png" alt="Block with state" /></p>
<p>Notice that the feedback of state is the key point: how can that be achieved? To find an answer, let's just ignore it for a moment. We assume that there will be something that can handle this issue for us. What remains is a function with "state in" and "state out" beside the actual input and output values:</p>
<p><img src="./bs_block_with_state_no_feedback.png" alt="block_with_state_no_feedback" /></p>
<p>Assuming that some mechanism passes in previous state and records output state (that gets passed in as the previous state at the next evaluation, and so on), we can rewrite the object-oriented low pass filter code by transforming it to a pure function:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// float -&gt; float -&gt; float -&gt; float * float</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs62', 256)" onmouseover="showTip(event, 'fs62', 256)" class="fn">lowPass</span> <span onmouseout="hideTip(event, 'fs50', 257)" onmouseover="showTip(event, 'fs50', 257)" class="id">timeConstant</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs3', 258)" onmouseover="showTip(event, 'fs3', 258)" class="id">input</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 259)" onmouseover="showTip(event, 'fs4', 259)" class="vt">float</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs63', 260)" onmouseover="showTip(event, 'fs63', 260)" class="id">lastOut</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs51', 261)" onmouseover="showTip(event, 'fs51', 261)" class="id">diff</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs63', 262)" onmouseover="showTip(event, 'fs63', 262)" class="id">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs3', 263)" onmouseover="showTip(event, 'fs3', 263)" class="id">input</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs64', 264)" onmouseover="showTip(event, 'fs64', 264)" class="id">out</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs63', 265)" onmouseover="showTip(event, 'fs63', 265)" class="id">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs51', 266)" onmouseover="showTip(event, 'fs51', 266)" class="id">diff</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs50', 267)" onmouseover="showTip(event, 'fs50', 267)" class="id">timeConstant</span>
        <span class="c">// the output state **is in this case** equals the output value</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs65', 268)" onmouseover="showTip(event, 'fs65', 268)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs64', 269)" onmouseover="showTip(event, 'fs64', 269)" class="id">out</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs65', 270)" onmouseover="showTip(event, 'fs65', 270)" class="id">newState</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs64', 271)" onmouseover="showTip(event, 'fs64', 271)" class="id">out</span><span class="pn">)</span>
</code></pre>
<p>What have we done?</p>
<ul>
<li><p>There is no mutable state anymore, since the previous state gets passed in as a function parameter. Benefit: we do not need a <code>lowPassCtor</code> function anymore.</p></li>
<li><p>After application of the timeConstant parameter <em>and</em> the actual input value, the remaining function has the signature <code>float -&gt; float * float</code>: the previous state comes in, resulting in a tuple that "packs" output state and an actual output value together.</p></li>
</ul>
<hint>
<p>You have probably seen that we curried the most inner function "by hand." Instead, we could have written one single function like <code>let lowPass timeConstant (input: float) lastOut = ...</code>. Since will will "name" those inner output functions, we will stick with the manual curried version.</p>
</hint>
<h3>Abstracting Instanciation</h3>
<p>Like stateless functions, we want to compose many stateful functions to build higher-level computations. Since we not only want to compose functions that work like a low pass filter (with float as state), we generalize the function, so that in the end, we are looking for a way to compose functions that look like this:</p>
<p><code>'state -&gt; 'state * float</code> (instead of <code>float -&gt; float * float</code>).</p>
<p>Since <code>'state * float</code> tuple is a significant thing that we will need more often, let's transform it to a named record type:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs66', 272)" onmouseover="showTip(event, 'fs66', 272)" class="rt">BlockOutput</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="pn">{</span> <span onmouseout="hideTip(event, 'fs67', 273)" onmouseover="showTip(event, 'fs67', 273)" class="id">value</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 274)" onmouseover="showTip(event, 'fs4', 274)" class="vt">float</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs68', 275)" onmouseover="showTip(event, 'fs68', 275)" class="id">state</span><span class="pn">:</span> <span class="ta">&#39;</span><span class="id">state</span> <span class="pn">}</span>
</code></pre>
<p>Then the signature of our stateful functions looks like this:
<code>'state -&gt; BlockOutput&lt;'state&gt;</code></p>
<p>Let's name that function, too:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs69', 276)" onmouseover="showTip(event, 'fs69', 276)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs69', 277)" onmouseover="showTip(event, 'fs69', 277)" class="uc">Block</span> <span class="k">of</span> <span class="pn">(</span><span class="ta">&#39;</span><span class="id">state</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs66', 278)" onmouseover="showTip(event, 'fs66', 278)" class="rt">BlockOutput</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span><span class="pn">)</span>
</code></pre>
<p>The <code>Block</code> type is a so-called <strong>single case discriminated union</strong>. I suggest you read <a href="https://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/">this</a> to understand how to construct and deconstruct unions, but you can try to figure it out by looking at the modified low pass filter code.</p>
<p>Compared to type abbreviations, single case unions have the advantage that it has to be constructed and deconstructed before the inner value (in our case, the stateful function) can be used. It is an advantage because it's not possible to pass or use a function "by accident" that has the same signature, but different semantics. It can also saves us from writing more type annotations.</p>
<p>The lowPass and fadeIn functions look like this (the resulting functions are simply passed to the <code>Block</code> constructor):</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 279)" onmouseover="showTip(event, 'fs22', 279)" class="fn">lowPass</span> <span onmouseout="hideTip(event, 'fs50', 280)" onmouseover="showTip(event, 'fs50', 280)" class="id">timeConstant</span> <span onmouseout="hideTip(event, 'fs3', 281)" onmouseover="showTip(event, 'fs3', 281)" class="id">input</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs69', 282)" onmouseover="showTip(event, 'fs69', 282)" class="uc">Block</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs63', 283)" onmouseover="showTip(event, 'fs63', 283)" class="id">lastOut</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs51', 284)" onmouseover="showTip(event, 'fs51', 284)" class="id">diff</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs63', 285)" onmouseover="showTip(event, 'fs63', 285)" class="id">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs3', 286)" onmouseover="showTip(event, 'fs3', 286)" class="id">input</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs64', 287)" onmouseover="showTip(event, 'fs64', 287)" class="id">out</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs63', 288)" onmouseover="showTip(event, 'fs63', 288)" class="id">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs51', 289)" onmouseover="showTip(event, 'fs51', 289)" class="id">diff</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs50', 290)" onmouseover="showTip(event, 'fs50', 290)" class="id">timeConstant</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs65', 291)" onmouseover="showTip(event, 'fs65', 291)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs64', 292)" onmouseover="showTip(event, 'fs64', 292)" class="id">out</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs64', 293)" onmouseover="showTip(event, 'fs64', 293)" class="id">out</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs65', 294)" onmouseover="showTip(event, 'fs65', 294)" class="id">newState</span> <span class="pn">}</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 295)" onmouseover="showTip(event, 'fs26', 295)" class="fn">fadeIn</span> <span onmouseout="hideTip(event, 'fs54', 296)" onmouseover="showTip(event, 'fs54', 296)" class="id">stepSize</span> <span onmouseout="hideTip(event, 'fs3', 297)" onmouseover="showTip(event, 'fs3', 297)" class="id">input</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs69', 298)" onmouseover="showTip(event, 'fs69', 298)" class="uc">Block</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs70', 299)" onmouseover="showTip(event, 'fs70', 299)" class="id">lastValue</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs55', 300)" onmouseover="showTip(event, 'fs55', 300)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 301)" onmouseover="showTip(event, 'fs3', 301)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs70', 302)" onmouseover="showTip(event, 'fs70', 302)" class="id">lastValue</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs65', 303)" onmouseover="showTip(event, 'fs65', 303)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs56', 304)" onmouseover="showTip(event, 'fs56', 304)" class="fn">min</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs70', 305)" onmouseover="showTip(event, 'fs70', 305)" class="id">lastValue</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs54', 306)" onmouseover="showTip(event, 'fs54', 306)" class="id">stepSize</span><span class="pn">)</span> <span class="n">1.0</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs55', 307)" onmouseover="showTip(event, 'fs55', 307)" class="id">result</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs65', 308)" onmouseover="showTip(event, 'fs65', 308)" class="id">newState</span> <span class="pn">}</span>
</code></pre>
<p>To be able to use a previously constructed single case union, we need a function that "unpacks" the inner value:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs71', 309)" onmouseover="showTip(event, 'fs71', 309)" class="fn">runB</span> <span onmouseout="hideTip(event, 'fs72', 310)" onmouseover="showTip(event, 'fs72', 310)" class="id">block</span> <span class="o">=</span> <span class="k">let</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs69', 311)" onmouseover="showTip(event, 'fs69', 311)" class="uc">Block</span> <span onmouseout="hideTip(event, 'fs73', 312)" onmouseover="showTip(event, 'fs73', 312)" class="fn">b</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs72', 313)" onmouseover="showTip(event, 'fs72', 313)" class="id">block</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs73', 314)" onmouseover="showTip(event, 'fs73', 314)" class="fn">b</span>
</code></pre>
<p>We will see shortly how <code>runB</code> is used.</p>
<h4>Generalizing Float</h4>
<p>Since we might have signal values that are not always of type <code>float</code>, we can easily generalize the <code>float</code>, so that our types look like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs74', 315)" onmouseover="showTip(event, 'fs74', 315)" class="rt">BlockOutput</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="pn">{</span> <span onmouseout="hideTip(event, 'fs75', 316)" onmouseover="showTip(event, 'fs75', 316)" class="id">value</span><span class="pn">:</span> <span class="ta">&#39;</span><span onmouseout="hideTip(event, 'fs75', 317)" onmouseover="showTip(event, 'fs75', 317)" class="id">value</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs68', 318)" onmouseover="showTip(event, 'fs68', 318)" class="id">state</span><span class="pn">:</span> <span class="ta">&#39;</span><span onmouseout="hideTip(event, 'fs68', 319)" onmouseover="showTip(event, 'fs68', 319)" class="id">state</span> <span class="pn">}</span>

<span class="k">type</span> <span onmouseout="hideTip(event, 'fs76', 320)" onmouseover="showTip(event, 'fs76', 320)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="ta">&#39;</span><span class="id">state</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs74', 321)" onmouseover="showTip(event, 'fs74', 321)" class="rt">BlockOutput</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span>
</code></pre>
<p>The code for <code>lowPass</code> and <code>fadeIn</code> remain the same because the compiler infers <code>float</code>.</p>
<p>Now we need a way of composing those functions. The composition must handle the "recording" of the output state and feed it into the next evaluation's input, and this must be done for every block in the computation. This sounds like we are goint to moved the key issue (instance management) into the composition layer. This is true - and beneficial - because we can abstract ("outsource") a recurring aspect of our programming model so that the user does not have to handle it anymore in a concrete way.</p>
<h2>Composing Stateful Functions</h2>
<hint>
<p>See [src/3<em>Stateful</em>FP.fsx] as sample source.</p>
</hint>
<p>So how can a composition function "record and feed back" work? Remember: we do not want to give "names" or "addresses" to our blocks - their identity shall be solely based on their place inside the computation. The composition function itself will consequently also be pure.</p>
<h3>Pick Up and Delivery</h3>
<p>Let's call the overall strategy "Pick Up and Delivery," and it will work like this:</p>
<ul>
<li>In a whole computation, all blocks are evaluated one after another.</li>
<li><p>The actual value of an evaluated <code>Block</code> is passed to the rest of the computation.</p></li>
<li><p><strong>Pick Up:</strong></p></li>
</ul>
<p>The output states of the blocks are accumulated. The output state of a <code>Block</code> and the output state of a following <code>Block</code> are packed together (in a tuple). This "state pack" will be passed to the next <code>Block</code> evaluation, that one's output is then packed again with the state of that <code>Block</code>, and so on. So in the end, we have:</p>
<p>state, packed together with the next state, that is packed together with next state, that is packed...</p>
<ul>
<li><strong>Delivery:</strong></li>
</ul>
<p>The final state pack that is emitted from the whole computation (alongside with the final actual output value) is then used as input state for the next evaluation cycle. That nested state pack is then unpacked piece by piece, evaluation by evaluation - like a FIFO buffer. In that way, the local state of a <code>Block</code> from the last evaluation is addressed and passed into the corresponding <code>Block</code> of the current evaluation.</p>
<p>Since this article is all about synthesizers, let's synthesize a composition function according to this recipe. We call it <code>bind</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs77', 322)" onmouseover="showTip(event, 'fs77', 322)" class="fn">bind</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs78', 323)" onmouseover="showTip(event, 'fs78', 323)" class="fn">currentBlock</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 324)" onmouseover="showTip(event, 'fs76', 324)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueA</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateA</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs79', 325)" onmouseover="showTip(event, 'fs79', 325)" class="fn">rest</span><span class="pn">:</span> <span class="ta">&#39;</span><span class="id">valueA</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs76', 326)" onmouseover="showTip(event, 'fs76', 326)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueB</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateB</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 327)" onmouseover="showTip(event, 'fs76', 327)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueB</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateA</span> <span class="pn">*</span> <span class="ta">&#39;</span><span class="id">stateB</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs76', 328)" onmouseover="showTip(event, 'fs76', 328)" class="uc">Block</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs80', 329)" onmouseover="showTip(event, 'fs80', 329)" class="id">previousStatePack</span> <span class="k">-&gt;</span>

        <span class="c">// Deconstruct state pack:</span>
        <span class="c">// state is a tuple of (&#39;stateA * &#39;stateB)</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs81', 330)" onmouseover="showTip(event, 'fs81', 330)" class="id">previousStateOfCurrentBlock</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs82', 331)" onmouseover="showTip(event, 'fs82', 331)" class="id">previousStateOfNextBlock</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs80', 332)" onmouseover="showTip(event, 'fs80', 332)" class="id">previousStatePack</span>

        <span class="c">// We evaluate the currentBlock. It&#39;s result is made up of an actual value and a state that</span>
        <span class="c">// has to be &quot;recorded&quot; by packing it together with the state of the</span>
        <span class="c">// next block.</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs83', 333)" onmouseover="showTip(event, 'fs83', 333)" class="id">currentBlockOutput</span> <span class="o">=</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs71', 334)" onmouseover="showTip(event, 'fs71', 334)" class="fn">runB</span> <span onmouseout="hideTip(event, 'fs78', 335)" onmouseover="showTip(event, 'fs78', 335)" class="fn">currentBlock</span><span class="pn">)</span> <span onmouseout="hideTip(event, 'fs81', 336)" onmouseover="showTip(event, 'fs81', 336)" class="id">previousStateOfCurrentBlock</span>

        <span class="c">// Continue evaluating the computation:</span>
        <span class="c">// passing the actual output value of currentBlock to the rest of the computation</span>
        <span class="c">// gives us access to the next block in the computation:</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs84', 337)" onmouseover="showTip(event, 'fs84', 337)" class="fn">nextBlock</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs79', 338)" onmouseover="showTip(event, 'fs79', 338)" class="fn">rest</span> <span onmouseout="hideTip(event, 'fs83', 339)" onmouseover="showTip(event, 'fs83', 339)" class="id">currentBlockOutput</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs67', 340)" onmouseover="showTip(event, 'fs67', 340)" class="id">value</span>

        <span class="c">// Evaluate the next block and build up the result of this bind function</span>
        <span class="c">// as a block, so that it can be used as a bindable element itself -</span>
        <span class="c">// but this time with state of 2 blocks packed together.</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs85', 341)" onmouseover="showTip(event, 'fs85', 341)" class="id">nextBlockOutput</span> <span class="o">=</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs71', 342)" onmouseover="showTip(event, 'fs71', 342)" class="fn">runB</span> <span onmouseout="hideTip(event, 'fs84', 343)" onmouseover="showTip(event, 'fs84', 343)" class="fn">nextBlock</span><span class="pn">)</span> <span onmouseout="hideTip(event, 'fs82', 344)" onmouseover="showTip(event, 'fs82', 344)" class="id">previousStateOfNextBlock</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs85', 345)" onmouseover="showTip(event, 'fs85', 345)" class="id">nextBlockOutput</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs67', 346)" onmouseover="showTip(event, 'fs67', 346)" class="id">value</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs83', 347)" onmouseover="showTip(event, 'fs83', 347)" class="id">currentBlockOutput</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs86', 348)" onmouseover="showTip(event, 'fs86', 348)" class="id">state</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs85', 349)" onmouseover="showTip(event, 'fs85', 349)" class="id">nextBlockOutput</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs86', 350)" onmouseover="showTip(event, 'fs86', 350)" class="id">state</span> <span class="pn">}</span>
</code></pre>
<p>You can read the code comments that explain the step. In addition, there are some more insights:</p>
<ul>
<li><code>bind</code> takes a <code>Block</code> and the rest of the computation;</li>
<li><code>bind</code> itself evaluates to a <code>Block</code>, which can then be composed again using <code>bind</code>, and so on; and</li>
<li><code>bind</code> can be seen as a kind of "hook" that lies in between our computation and can thus handle all the state aspects for the user.</li>
</ul>
<p>The last two points are essential: bind enables us to "nest" functions and therefor nest their state, and bind builds up a data context when it is used inside of the "rest functions." This means a nested "rest function" has access to all given values of its enclosing functions.</p>
<h3>Using Blocks</h3>
<p>Now, we have two important things in our hands:</p>
<ul>
<li>we know how stateful functions look like, and we call them "Block" functions; and</li>
<li>we have a way of composing these <code>Block</code> functions which is implemented in the "bind" function.</li>
</ul>
<p>Having this in mind, we can modify our use case example "blendedDistortion" in way that fits with "blocks and bind."</p>
<p>Here it is in the desired form:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// that would be nice, but doesn&#39;t work.</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 351)" onmouseover="showTip(event, 'fs18', 351)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs11', 352)" onmouseover="showTip(event, 'fs11', 352)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 353)" onmouseover="showTip(event, 'fs3', 353)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 354)" onmouseover="showTip(event, 'fs19', 354)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 355)" onmouseover="showTip(event, 'fs3', 355)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 356)" onmouseover="showTip(event, 'fs9', 356)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 357)" onmouseover="showTip(event, 'fs11', 357)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 358)" onmouseover="showTip(event, 'fs20', 358)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 359)" onmouseover="showTip(event, 'fs19', 359)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 360)" onmouseover="showTip(event, 'fs5', 360)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 361)" onmouseover="showTip(event, 'fs21', 361)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 362)" onmouseover="showTip(event, 'fs19', 362)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 363)" onmouseover="showTip(event, 'fs22', 363)" class="fn">lowPass</span> <span class="n">0.2</span>      <span class="c">// we would like to use lowPass</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 364)" onmouseover="showTip(event, 'fs23', 364)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 365)" onmouseover="showTip(event, 'fs24', 365)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 366)" onmouseover="showTip(event, 'fs20', 366)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs21', 367)" onmouseover="showTip(event, 'fs21', 367)" class="id">softLimited</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 368)" onmouseover="showTip(event, 'fs25', 368)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 369)" onmouseover="showTip(event, 'fs23', 369)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 370)" onmouseover="showTip(event, 'fs26', 370)" class="fn">fadeIn</span> <span class="n">0.1</span>           <span class="c">// we would like to use fadeIn</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 371)" onmouseover="showTip(event, 'fs27', 371)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 372)" onmouseover="showTip(event, 'fs9', 372)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 373)" onmouseover="showTip(event, 'fs25', 373)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 374)" onmouseover="showTip(event, 'fs27', 374)" class="id">gained</span>
</code></pre>
<p>Here, we treat lowPass and fadeIn as pure functions - which is what we wanted - but which also does not work. We then use OOP that solves the issue, but forces us to create and manage references to instances.</p>
<p>Now that we have introduced blocks and the "Pick Up and Delivery" strategy (implemented by the <code>bind</code> combinator function), let's see how far we have come.</p>
<p>We defined that <code>bind</code> takes a <code>Block</code> and the "rest of the computation." Since in a functional language, "rest of computation" is an expression (since everything is an expression), we defined it as a function of the form <code>float -&gt; Block&lt;'value, 'state&gt;</code>.</p>
<p>To be able to do so, we have to</p>
<ul>
<li>break up the code sample from above into pieces of "rest functions";</li>
<li>in the desired form (<code>float -&gt; Block&lt;'value, 'state&gt;</code>);</li>
<li>and do that every time a value from a <code>Block</code> is needed; and</li>
<li>use 'bind' to compose the pieces.</li>
</ul>
<p>Let's do it!</p>
<hint>If you are already familiar with monads and/or F# computation expressions, you can skip this chapter.</hint>
<h2>Rewrite blendedDistortion with "bind"</h2>
<hint>
<p>See [src/3<em>Stateful</em>FP.fsx] as sample source.</p>
</hint>
<p>In this chapter, we will modify our <code>blendedDistortion</code> sample to achieve the following:</p>
<ul>
<li>explain how <code>bind</code> is finally used;</li>
<li>understand in which way it relates to stateless computations; and</li>
<li>see how we can simplify the syntax by using F#'s computation expressions.</li>
</ul>
<p>Let's start with breaking the computation into pieces every time a <code>Block</code> is used and composing these pieces with <code>bind</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs87', 375)" onmouseover="showTip(event, 'fs87', 375)" class="fn">blendedDistortion1</span> <span onmouseout="hideTip(event, 'fs11', 376)" onmouseover="showTip(event, 'fs11', 376)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 377)" onmouseover="showTip(event, 'fs3', 377)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 378)" onmouseover="showTip(event, 'fs19', 378)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 379)" onmouseover="showTip(event, 'fs3', 379)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 380)" onmouseover="showTip(event, 'fs9', 380)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 381)" onmouseover="showTip(event, 'fs11', 381)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 382)" onmouseover="showTip(event, 'fs20', 382)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 383)" onmouseover="showTip(event, 'fs19', 383)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 384)" onmouseover="showTip(event, 'fs5', 384)" class="fn">limit</span> <span class="n">0.7</span>
    <span onmouseout="hideTip(event, 'fs77', 385)" onmouseover="showTip(event, 'fs77', 385)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 386)" onmouseover="showTip(event, 'fs19', 386)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 387)" onmouseover="showTip(event, 'fs22', 387)" class="fn">lowPass</span> <span class="n">0.2</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs57', 388)" onmouseover="showTip(event, 'fs57', 388)" class="id">softLimited</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 389)" onmouseover="showTip(event, 'fs23', 389)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 390)" onmouseover="showTip(event, 'fs24', 390)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 391)" onmouseover="showTip(event, 'fs20', 391)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs57', 392)" onmouseover="showTip(event, 'fs57', 392)" class="id">softLimited</span>
        <span onmouseout="hideTip(event, 'fs77', 393)" onmouseover="showTip(event, 'fs77', 393)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs23', 394)" onmouseover="showTip(event, 'fs23', 394)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 395)" onmouseover="showTip(event, 'fs26', 395)" class="fn">fadeIn</span> <span class="n">0.1</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs30', 396)" onmouseover="showTip(event, 'fs30', 396)" class="id">fadedIn</span> <span class="k">-&gt;</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 397)" onmouseover="showTip(event, 'fs27', 397)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 398)" onmouseover="showTip(event, 'fs9', 398)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 399)" onmouseover="showTip(event, 'fs30', 399)" class="id">fadedIn</span>
            <span onmouseout="hideTip(event, 'fs27', 400)" onmouseover="showTip(event, 'fs27', 400)" class="id">gained</span><span class="pn">)</span><span class="pn">)</span>
</code></pre>
<p><strong>Indent</strong></p>
<p>That does not look like the desired result (and it wouldn't compile - but let's set that aside for a moment). But with a little bit of tweaking indentation, we can make it look a little more readable:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs88', 451)" onmouseover="showTip(event, 'fs88', 451)" class="fn">blendedDistortion2</span> <span onmouseout="hideTip(event, 'fs11', 452)" onmouseover="showTip(event, 'fs11', 452)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 453)" onmouseover="showTip(event, 'fs3', 453)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 454)" onmouseover="showTip(event, 'fs19', 454)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 455)" onmouseover="showTip(event, 'fs3', 455)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 456)" onmouseover="showTip(event, 'fs9', 456)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 457)" onmouseover="showTip(event, 'fs11', 457)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 458)" onmouseover="showTip(event, 'fs20', 458)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 459)" onmouseover="showTip(event, 'fs19', 459)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 460)" onmouseover="showTip(event, 'fs5', 460)" class="fn">limit</span> <span class="n">0.7</span>
    <span onmouseout="hideTip(event, 'fs77', 461)" onmouseover="showTip(event, 'fs77', 461)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 462)" onmouseover="showTip(event, 'fs19', 462)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 463)" onmouseover="showTip(event, 'fs22', 463)" class="fn">lowPass</span> <span class="n">0.2</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs57', 464)" onmouseover="showTip(event, 'fs57', 464)" class="id">softLimited</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 465)" onmouseover="showTip(event, 'fs23', 465)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 466)" onmouseover="showTip(event, 'fs24', 466)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 467)" onmouseover="showTip(event, 'fs20', 467)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs57', 468)" onmouseover="showTip(event, 'fs57', 468)" class="id">softLimited</span>
    <span onmouseout="hideTip(event, 'fs77', 469)" onmouseover="showTip(event, 'fs77', 469)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs23', 470)" onmouseover="showTip(event, 'fs23', 470)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 471)" onmouseover="showTip(event, 'fs26', 471)" class="fn">fadeIn</span> <span class="n">0.1</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs30', 472)" onmouseover="showTip(event, 'fs30', 472)" class="id">fadedIn</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 473)" onmouseover="showTip(event, 'fs27', 473)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 474)" onmouseover="showTip(event, 'fs9', 474)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 475)" onmouseover="showTip(event, 'fs30', 475)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 476)" onmouseover="showTip(event, 'fs27', 476)" class="id">gained</span><span class="pn">)</span><span class="pn">)</span>
</code></pre>
<p>That's better! Now compare this code with the desired code from:</p>
<div class="col-2">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 596)" onmouseover="showTip(event, 'fs18', 596)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs11', 597)" onmouseover="showTip(event, 'fs11', 597)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 598)" onmouseover="showTip(event, 'fs3', 598)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 599)" onmouseover="showTip(event, 'fs19', 599)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 600)" onmouseover="showTip(event, 'fs3', 600)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 601)" onmouseover="showTip(event, 'fs9', 601)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 602)" onmouseover="showTip(event, 'fs11', 602)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 603)" onmouseover="showTip(event, 'fs20', 603)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 604)" onmouseover="showTip(event, 'fs19', 604)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 605)" onmouseover="showTip(event, 'fs5', 605)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 606)" onmouseover="showTip(event, 'fs21', 606)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 607)" onmouseover="showTip(event, 'fs19', 607)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 608)" onmouseover="showTip(event, 'fs22', 608)" class="fn">lowPass</span> <span class="n">0.2</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 609)" onmouseover="showTip(event, 'fs23', 609)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 610)" onmouseover="showTip(event, 'fs24', 610)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 611)" onmouseover="showTip(event, 'fs20', 611)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs21', 612)" onmouseover="showTip(event, 'fs21', 612)" class="id">softLimited</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 613)" onmouseover="showTip(event, 'fs25', 613)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 614)" onmouseover="showTip(event, 'fs23', 614)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 615)" onmouseover="showTip(event, 'fs26', 615)" class="fn">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 616)" onmouseover="showTip(event, 'fs27', 616)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 617)" onmouseover="showTip(event, 'fs9', 617)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 618)" onmouseover="showTip(event, 'fs25', 618)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 619)" onmouseover="showTip(event, 'fs27', 619)" class="id">gained</span>
</code></pre>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs88', 451)" onmouseover="showTip(event, 'fs88', 451)" class="fn">blendedDistortion2</span> <span onmouseout="hideTip(event, 'fs11', 452)" onmouseover="showTip(event, 'fs11', 452)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 453)" onmouseover="showTip(event, 'fs3', 453)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 454)" onmouseover="showTip(event, 'fs19', 454)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 455)" onmouseover="showTip(event, 'fs3', 455)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 456)" onmouseover="showTip(event, 'fs9', 456)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 457)" onmouseover="showTip(event, 'fs11', 457)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 458)" onmouseover="showTip(event, 'fs20', 458)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 459)" onmouseover="showTip(event, 'fs19', 459)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 460)" onmouseover="showTip(event, 'fs5', 460)" class="fn">limit</span> <span class="n">0.7</span>
    <span onmouseout="hideTip(event, 'fs77', 461)" onmouseover="showTip(event, 'fs77', 461)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 462)" onmouseover="showTip(event, 'fs19', 462)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 463)" onmouseover="showTip(event, 'fs22', 463)" class="fn">lowPass</span> <span class="n">0.2</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs57', 464)" onmouseover="showTip(event, 'fs57', 464)" class="id">softLimited</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 465)" onmouseover="showTip(event, 'fs23', 465)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 466)" onmouseover="showTip(event, 'fs24', 466)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 467)" onmouseover="showTip(event, 'fs20', 467)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs57', 468)" onmouseover="showTip(event, 'fs57', 468)" class="id">softLimited</span>
    <span onmouseout="hideTip(event, 'fs77', 469)" onmouseover="showTip(event, 'fs77', 469)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs23', 470)" onmouseover="showTip(event, 'fs23', 470)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 471)" onmouseover="showTip(event, 'fs26', 471)" class="fn">fadeIn</span> <span class="n">0.1</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs30', 472)" onmouseover="showTip(event, 'fs30', 472)" class="id">fadedIn</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 473)" onmouseover="showTip(event, 'fs27', 473)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 474)" onmouseover="showTip(event, 'fs9', 474)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 475)" onmouseover="showTip(event, 'fs30', 475)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 476)" onmouseover="showTip(event, 'fs27', 476)" class="id">gained</span><span class="pn">)</span><span class="pn">)</span>
</code></pre>
</div>
<p>Every time we use a lowPass or fadeIn, there's no let binding anymore, but rather a bind that takes exactly the expression on the right side of the let binding. The second parameter of bind is then the "rest of the computation," coded as a lambda function, that has a parameter with the identifier name of the let binding.</p>
<p>This form can still be improved by introducing a custom operator:</p>
<p><strong>Custom bind Operator</strong></p>
<p>We can then introduce a prefix style operator as an alias for bind:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="pn">(</span><span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs77', 477)" onmouseover="showTip(event, 'fs77', 477)" class="fn">bind</span>
</code></pre>
<p>...and remove the parenthesis:</p>
<div class="col-2">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 596)" onmouseover="showTip(event, 'fs18', 596)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs11', 597)" onmouseover="showTip(event, 'fs11', 597)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 598)" onmouseover="showTip(event, 'fs3', 598)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 599)" onmouseover="showTip(event, 'fs19', 599)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 600)" onmouseover="showTip(event, 'fs3', 600)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 601)" onmouseover="showTip(event, 'fs9', 601)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 602)" onmouseover="showTip(event, 'fs11', 602)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 603)" onmouseover="showTip(event, 'fs20', 603)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 604)" onmouseover="showTip(event, 'fs19', 604)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 605)" onmouseover="showTip(event, 'fs5', 605)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 606)" onmouseover="showTip(event, 'fs21', 606)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 607)" onmouseover="showTip(event, 'fs19', 607)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 608)" onmouseover="showTip(event, 'fs22', 608)" class="fn">lowPass</span> <span class="n">0.2</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 609)" onmouseover="showTip(event, 'fs23', 609)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 610)" onmouseover="showTip(event, 'fs24', 610)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 611)" onmouseover="showTip(event, 'fs20', 611)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs21', 612)" onmouseover="showTip(event, 'fs21', 612)" class="id">softLimited</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 613)" onmouseover="showTip(event, 'fs25', 613)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 614)" onmouseover="showTip(event, 'fs23', 614)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 615)" onmouseover="showTip(event, 'fs26', 615)" class="fn">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 616)" onmouseover="showTip(event, 'fs27', 616)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 617)" onmouseover="showTip(event, 'fs9', 617)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 618)" onmouseover="showTip(event, 'fs25', 618)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 619)" onmouseover="showTip(event, 'fs27', 619)" class="id">gained</span>
</code></pre>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs89', 502)" onmouseover="showTip(event, 'fs89', 502)" class="fn">blendedDistortion3</span> <span onmouseout="hideTip(event, 'fs11', 503)" onmouseover="showTip(event, 'fs11', 503)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 504)" onmouseover="showTip(event, 'fs3', 504)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 505)" onmouseover="showTip(event, 'fs19', 505)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 506)" onmouseover="showTip(event, 'fs3', 506)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 507)" onmouseover="showTip(event, 'fs9', 507)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 508)" onmouseover="showTip(event, 'fs11', 508)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 509)" onmouseover="showTip(event, 'fs20', 509)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 510)" onmouseover="showTip(event, 'fs19', 510)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 511)" onmouseover="showTip(event, 'fs5', 511)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 512)" onmouseover="showTip(event, 'fs19', 512)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 513)" onmouseover="showTip(event, 'fs22', 513)" class="fn">lowPass</span> <span class="n">0.2</span><span class="pn">)</span> <span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs57', 514)" onmouseover="showTip(event, 'fs57', 514)" class="id">softLimited</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 515)" onmouseover="showTip(event, 'fs23', 515)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 516)" onmouseover="showTip(event, 'fs24', 516)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 517)" onmouseover="showTip(event, 'fs20', 517)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs57', 518)" onmouseover="showTip(event, 'fs57', 518)" class="id">softLimited</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs23', 519)" onmouseover="showTip(event, 'fs23', 519)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 520)" onmouseover="showTip(event, 'fs26', 520)" class="fn">fadeIn</span> <span class="n">0.1</span><span class="pn">)</span> <span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs30', 521)" onmouseover="showTip(event, 'fs30', 521)" class="id">fadedIn</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 522)" onmouseover="showTip(event, 'fs27', 522)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 523)" onmouseover="showTip(event, 'fs9', 523)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 524)" onmouseover="showTip(event, 'fs30', 524)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 525)" onmouseover="showTip(event, 'fs27', 525)" class="id">gained</span>
</code></pre>
</div>
<p>Now we are pretty close to the desired code, except that the identifiers of the lambdas are coming after the expression. But we will get rid of that, too, in a minute.</p>
<p><strong>Return</strong></p>
<p>There is one thing to notice here: the code wouldn't compile. Remember that we defined bind in a way that it gets past the "rest of the computation" as a function that evaluates to a <code>Block</code>? Look at the last expression: it evaluates to a float, not to a <code>Block</code>. Why? The answer is easy: it has no state because the "mix" function is a stateless function. Thus, it evaluates to a pure float value and not to a Block. Solving this is easy, because we can turn a float value into a <code>Block&lt;float, unit&gt;</code> like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// &quot;Return&quot; function of: &#39;a -&gt; Block&lt;&#39;a, Unit&gt;</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs90', 526)" onmouseover="showTip(event, 'fs90', 526)" class="fn">returnB</span> <span onmouseout="hideTip(event, 'fs32', 527)" onmouseover="showTip(event, 'fs32', 527)" class="id">x</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs91', 528)" onmouseover="showTip(event, 'fs91', 528)" class="fn">blockFunction</span> <span onmouseout="hideTip(event, 'fs92', 529)" onmouseover="showTip(event, 'fs92', 529)" class="id">unusedState</span> <span class="o">=</span> <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs32', 530)" onmouseover="showTip(event, 'fs32', 530)" class="id">x</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="pn">)</span> <span class="pn">}</span>
    <span onmouseout="hideTip(event, 'fs76', 531)" onmouseover="showTip(event, 'fs76', 531)" class="uc">Block</span> <span onmouseout="hideTip(event, 'fs91', 532)" onmouseover="showTip(event, 'fs91', 532)" class="fn">blockFunction</span>
</code></pre>
<p>The whole <code>blendedDistortion</code> function then looks like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs89', 533)" onmouseover="showTip(event, 'fs89', 533)" class="fn">blendedDistortion3</span> <span onmouseout="hideTip(event, 'fs11', 534)" onmouseover="showTip(event, 'fs11', 534)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 535)" onmouseover="showTip(event, 'fs3', 535)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 536)" onmouseover="showTip(event, 'fs19', 536)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 537)" onmouseover="showTip(event, 'fs3', 537)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 538)" onmouseover="showTip(event, 'fs9', 538)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 539)" onmouseover="showTip(event, 'fs11', 539)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 540)" onmouseover="showTip(event, 'fs20', 540)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 541)" onmouseover="showTip(event, 'fs19', 541)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 542)" onmouseover="showTip(event, 'fs5', 542)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs19', 543)" onmouseover="showTip(event, 'fs19', 543)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 544)" onmouseover="showTip(event, 'fs22', 544)" class="fn">lowPass</span> <span class="n">0.2</span><span class="pn">)</span> <span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs57', 545)" onmouseover="showTip(event, 'fs57', 545)" class="id">softLimited</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 546)" onmouseover="showTip(event, 'fs23', 546)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 547)" onmouseover="showTip(event, 'fs24', 547)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 548)" onmouseover="showTip(event, 'fs20', 548)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs57', 549)" onmouseover="showTip(event, 'fs57', 549)" class="id">softLimited</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs23', 550)" onmouseover="showTip(event, 'fs23', 550)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 551)" onmouseover="showTip(event, 'fs26', 551)" class="fn">fadeIn</span> <span class="n">0.1</span><span class="pn">)</span> <span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs30', 552)" onmouseover="showTip(event, 'fs30', 552)" class="id">fadedIn</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 553)" onmouseover="showTip(event, 'fs27', 553)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 554)" onmouseover="showTip(event, 'fs9', 554)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 555)" onmouseover="showTip(event, 'fs30', 555)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs90', 556)" onmouseover="showTip(event, 'fs90', 556)" class="fn">returnB</span> <span onmouseout="hideTip(event, 'fs27', 557)" onmouseover="showTip(event, 'fs27', 557)" class="id">gained</span>
</code></pre>
<h3>Using F# Language Support for Bind and Return</h3>
<p>The syntax with our lambdas is close to the desired syntax, but we can get even closer. Luckily, what we did is so generic that F# (and other languages) has support for this kind of composition.</p>
<p>All we have to do is implement a class - which is called "builder" - that has a predefined set of methods. Here, we use a minimal set to enable the F# syntax support for bind. Note that in a real-world scenario, there are many more builder methods available that serve different needs, although we won't capture them here.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs93', 558)" onmouseover="showTip(event, 'fs93', 558)" class="rt">Patch</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs94', 559)" onmouseover="showTip(event, 'fs94', 559)" class="id">this</span><span class="pn">.</span><span class="fn">Bind</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs95', 560)" onmouseover="showTip(event, 'fs95', 560)" class="fn">block</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs96', 561)" onmouseover="showTip(event, 'fs96', 561)" class="fn">rest</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs77', 562)" onmouseover="showTip(event, 'fs77', 562)" class="fn">bind</span> <span onmouseout="hideTip(event, 'fs95', 563)" onmouseover="showTip(event, 'fs95', 563)" class="fn">block</span> <span onmouseout="hideTip(event, 'fs96', 564)" onmouseover="showTip(event, 'fs96', 564)" class="fn">rest</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs94', 565)" onmouseover="showTip(event, 'fs94', 565)" class="id">this</span><span class="pn">.</span><span class="fn">Return</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs32', 566)" onmouseover="showTip(event, 'fs32', 566)" class="id">x</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs90', 567)" onmouseover="showTip(event, 'fs90', 567)" class="fn">returnB</span> <span onmouseout="hideTip(event, 'fs32', 568)" onmouseover="showTip(event, 'fs32', 568)" class="id">x</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs97', 569)" onmouseover="showTip(event, 'fs97', 569)" class="id">patch</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs93', 570)" onmouseover="showTip(event, 'fs93', 570)" class="rt">Patch</span><span class="pn">(</span><span class="pn">)</span>
</code></pre>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs98', 620)" onmouseover="showTip(event, 'fs98', 620)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs11', 621)" onmouseover="showTip(event, 'fs11', 621)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 622)" onmouseover="showTip(event, 'fs3', 622)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs97', 623)" onmouseover="showTip(event, 'fs97', 623)" class="k">patch</span> <span class="pn">{</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 624)" onmouseover="showTip(event, 'fs19', 624)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 625)" onmouseover="showTip(event, 'fs3', 625)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 626)" onmouseover="showTip(event, 'fs9', 626)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 627)" onmouseover="showTip(event, 'fs11', 627)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 628)" onmouseover="showTip(event, 'fs20', 628)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 629)" onmouseover="showTip(event, 'fs19', 629)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 630)" onmouseover="showTip(event, 'fs5', 630)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs57', 631)" onmouseover="showTip(event, 'fs57', 631)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 632)" onmouseover="showTip(event, 'fs19', 632)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 633)" onmouseover="showTip(event, 'fs22', 633)" class="fn">lowPass</span> <span class="n">0.2</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 634)" onmouseover="showTip(event, 'fs23', 634)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 635)" onmouseover="showTip(event, 'fs24', 635)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 636)" onmouseover="showTip(event, 'fs20', 636)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs57', 637)" onmouseover="showTip(event, 'fs57', 637)" class="id">softLimited</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs30', 638)" onmouseover="showTip(event, 'fs30', 638)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 639)" onmouseover="showTip(event, 'fs23', 639)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 640)" onmouseover="showTip(event, 'fs26', 640)" class="fn">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 641)" onmouseover="showTip(event, 'fs27', 641)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 642)" onmouseover="showTip(event, 'fs9', 642)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 643)" onmouseover="showTip(event, 'fs30', 643)" class="id">fadedIn</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs27', 644)" onmouseover="showTip(event, 'fs27', 644)" class="id">gained</span>
<span class="pn">}</span>
</code></pre>
<p>This looks almost similar to what we wanted to achieve. We only have to wrap our code in the "patch" and use let! instead of let every time we deal with blocks instead of pure functions. The F# compiler translates this syntax into the form we have seen above. Compare the desired form and the final form:</p>
<div class="col-2">
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 596)" onmouseover="showTip(event, 'fs18', 596)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs11', 597)" onmouseover="showTip(event, 'fs11', 597)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 598)" onmouseover="showTip(event, 'fs3', 598)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 599)" onmouseover="showTip(event, 'fs19', 599)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 600)" onmouseover="showTip(event, 'fs3', 600)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 601)" onmouseover="showTip(event, 'fs9', 601)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 602)" onmouseover="showTip(event, 'fs11', 602)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 603)" onmouseover="showTip(event, 'fs20', 603)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 604)" onmouseover="showTip(event, 'fs19', 604)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 605)" onmouseover="showTip(event, 'fs5', 605)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 606)" onmouseover="showTip(event, 'fs21', 606)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 607)" onmouseover="showTip(event, 'fs19', 607)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 608)" onmouseover="showTip(event, 'fs22', 608)" class="fn">lowPass</span> <span class="n">0.2</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 609)" onmouseover="showTip(event, 'fs23', 609)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 610)" onmouseover="showTip(event, 'fs24', 610)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 611)" onmouseover="showTip(event, 'fs20', 611)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs21', 612)" onmouseover="showTip(event, 'fs21', 612)" class="id">softLimited</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 613)" onmouseover="showTip(event, 'fs25', 613)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 614)" onmouseover="showTip(event, 'fs23', 614)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 615)" onmouseover="showTip(event, 'fs26', 615)" class="fn">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 616)" onmouseover="showTip(event, 'fs27', 616)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 617)" onmouseover="showTip(event, 'fs9', 617)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 618)" onmouseover="showTip(event, 'fs25', 618)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs27', 619)" onmouseover="showTip(event, 'fs27', 619)" class="id">gained</span>
</code></pre>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs98', 620)" onmouseover="showTip(event, 'fs98', 620)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs11', 621)" onmouseover="showTip(event, 'fs11', 621)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 622)" onmouseover="showTip(event, 'fs3', 622)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs97', 623)" onmouseover="showTip(event, 'fs97', 623)" class="k">patch</span> <span class="pn">{</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 624)" onmouseover="showTip(event, 'fs19', 624)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 625)" onmouseover="showTip(event, 'fs3', 625)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 626)" onmouseover="showTip(event, 'fs9', 626)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 627)" onmouseover="showTip(event, 'fs11', 627)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 628)" onmouseover="showTip(event, 'fs20', 628)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 629)" onmouseover="showTip(event, 'fs19', 629)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 630)" onmouseover="showTip(event, 'fs5', 630)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs57', 631)" onmouseover="showTip(event, 'fs57', 631)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 632)" onmouseover="showTip(event, 'fs19', 632)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 633)" onmouseover="showTip(event, 'fs22', 633)" class="fn">lowPass</span> <span class="n">0.2</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 634)" onmouseover="showTip(event, 'fs23', 634)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 635)" onmouseover="showTip(event, 'fs24', 635)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 636)" onmouseover="showTip(event, 'fs20', 636)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs57', 637)" onmouseover="showTip(event, 'fs57', 637)" class="id">softLimited</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs30', 638)" onmouseover="showTip(event, 'fs30', 638)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 639)" onmouseover="showTip(event, 'fs23', 639)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 640)" onmouseover="showTip(event, 'fs26', 640)" class="fn">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 641)" onmouseover="showTip(event, 'fs27', 641)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 642)" onmouseover="showTip(event, 'fs9', 642)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 643)" onmouseover="showTip(event, 'fs30', 643)" class="id">fadedIn</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs27', 644)" onmouseover="showTip(event, 'fs27', 644)" class="id">gained</span>
<span class="pn">}</span>
</code></pre>
</div>
<p>So our primary goal has been reached! We abstracted state (and therefor instance-) management, so that the user can focus on writing signal processing functions.</p>
<p>Since we chose an approach of "synthesizing" our solution, we will now analyze what we did in the upcoming chapters.</p>
<h2>Evaluating Stateful Functions</h2>
<hint>
<p>See [src/4<em>Optional</em>Initial_Values.fsx] and [src/5_Evaluation.fsx] as sample source.</p>
</hint>
<p>In the previous chapter, we learned that we can compose stateful <code>Block</code> functions easily by using the <code>block</code> computation expression and <code>let!</code> instead of <code>let</code> when we want to bind the output value of a <code>Block</code> function to an identifier and use it in the rest of our computation.</p>
<p>But in the end, we are not interested in state - we need the pure output values of our computation to send them to the soundcard's buffer. For us, it will be enough to just have these values available as sequence.</p>
<h3>The Signature of State</h3>
<p>Having a look at the final <code>blendedDistortion</code> function again, there is an interesting aspect about the signature of its state:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// float -&gt; float -&gt; Block&lt;float, float * (float * unit)&gt;</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs99', 645)" onmouseover="showTip(event, 'fs99', 645)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs100', 646)" onmouseover="showTip(event, 'fs100', 646)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs101', 647)" onmouseover="showTip(event, 'fs101', 647)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs97', 648)" onmouseover="showTip(event, 'fs97', 648)" class="id">patch</span> <span class="pn">{</span> <span class="c">(*...*)</span> <span class="pn">}</span>
</code></pre>
<p>The first two floats are "drive" and "input". After applying these, we get a <code>Block</code> that deals with float signal values. Its state signature is then <code>float * (float * unit)</code>.</p>
<p>Where does this come from?</p>
<p>This is the nested tuple that is completely inferred from the structure of the <code>blendedDistortion</code> computation expression:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs98', 649)" onmouseover="showTip(event, 'fs98', 649)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs11', 650)" onmouseover="showTip(event, 'fs11', 650)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 651)" onmouseover="showTip(event, 'fs3', 651)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs97', 652)" onmouseover="showTip(event, 'fs97', 652)" class="k">patch</span> <span class="pn">{</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 653)" onmouseover="showTip(event, 'fs19', 653)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 654)" onmouseover="showTip(event, 'fs3', 654)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 655)" onmouseover="showTip(event, 'fs9', 655)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs11', 656)" onmouseover="showTip(event, 'fs11', 656)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 657)" onmouseover="showTip(event, 'fs20', 657)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 658)" onmouseover="showTip(event, 'fs19', 658)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 659)" onmouseover="showTip(event, 'fs5', 659)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs57', 660)" onmouseover="showTip(event, 'fs57', 660)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs19', 661)" onmouseover="showTip(event, 'fs19', 661)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs22', 662)" onmouseover="showTip(event, 'fs22', 662)" class="fn">lowPass</span> <span class="n">0.2</span>       <span class="c">// lowPass has float as state</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 663)" onmouseover="showTip(event, 'fs23', 663)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 664)" onmouseover="showTip(event, 'fs24', 664)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs20', 665)" onmouseover="showTip(event, 'fs20', 665)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs57', 666)" onmouseover="showTip(event, 'fs57', 666)" class="id">softLimited</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs30', 667)" onmouseover="showTip(event, 'fs30', 667)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs23', 668)" onmouseover="showTip(event, 'fs23', 668)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs26', 669)" onmouseover="showTip(event, 'fs26', 669)" class="fn">fadeIn</span> <span class="n">0.1</span>            <span class="c">// fadeIn has float as state</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 670)" onmouseover="showTip(event, 'fs27', 670)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 671)" onmouseover="showTip(event, 'fs9', 671)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs30', 672)" onmouseover="showTip(event, 'fs30', 672)" class="id">fadedIn</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs27', 673)" onmouseover="showTip(event, 'fs27', 673)" class="id">gained</span>                                 <span class="c">// return (which is returnB) has unit as state</span>
</code></pre>
<p>The F# compiler understands how the state of the whole computation has to look like just by "looking" at how the computation is defined. There is no explicit type annotation needed that would be given by the user (that would be a show stopper). It is all inferred for the user by the F# compiler.</p>
<p>But our goal was to evaluate the computation for a given set of input values. To achieve that, we have to evaluate the <code>Block</code> function that we get from blendedDistortion. Let's have a look at the <code>Block</code> type again:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs76', 674)" onmouseover="showTip(event, 'fs76', 674)" class="id">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="id">&#39;</span><span class="id">state</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs74', 675)" onmouseover="showTip(event, 'fs74', 675)" class="id">BlockOutput</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="id">&#39;</span><span class="id">state</span><span class="pn">&gt;</span>
</code></pre>
<p>A <code>Block</code> needs (of course) state - the previous state - passed in to be able to evaluate its next state and value. At the beginning of an evaluation cycle, what's the previous state? There is none, so we need an initial state in form of <code>float * (float * unit)</code>.</p>
<pre class="fssnip highlighted"><code lang="fsharp">    <span class="c">// we have to create some initial state to kick off the computation.</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs102', 676)" onmouseover="showTip(event, 'fs102', 676)" class="id">initialState</span> <span class="o">=</span> <span class="n">0.0</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.0</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span>
    
    <span class="c">// for simplification, we pass in constant drive and input values to blendedDistortion.</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs103', 677)" onmouseover="showTip(event, 'fs103', 677)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs98', 678)" onmouseover="showTip(event, 'fs98', 678)" class="fn">blendedDistortion</span> <span class="n">1.5</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs102', 679)" onmouseover="showTip(event, 'fs102', 679)" class="id">initialState</span>
</code></pre>
<p>The fact that we have to write initial state for a computation seems kind of annoying. Now imagine you are in a real-world scenario in which you reuse <code>Block</code> in <code>Block</code>, building more and more high-level blocks. And another thing: you might not even know what is an appropriate initial value for blocks you didn't write. Thus, providing initial values might be your concern, but it could also be the concern of another author. What we need is a mechanism that enables us to:</p>
<ul>
<li>omit initial state; and</li>
<li>define it either on block-declaration side; or</li>
<li>let it be defined inside of a <code>Block</code> itself.</li>
</ul>
<h3>Optional Initial State</h3>
<p>We can achieve this by making state optional. In that case, the block author can decide if initial state values are a curried part of the <code>Block</code> function or if they will be handled completely inside the <code>Block</code> function so that they are hard-coded and not parameterizable.</p>
<p>This means we have to change the signature of our <code>Block</code> type:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs76', 680)" onmouseover="showTip(event, 'fs76', 680)" class="id">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="id">&#39;</span><span class="id">state</span> <span onmouseout="hideTip(event, 'fs104', 681)" onmouseover="showTip(event, 'fs104', 681)" class="id">option</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs74', 682)" onmouseover="showTip(event, 'fs74', 682)" class="id">BlockOutput</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="id">&#39;</span><span class="id">state</span><span class="pn">&gt;</span>
</code></pre>
<p>Instead of a <code>'state</code> parameter, a <code>Block</code> expects an optional <code>'state option</code> parameter.</p>
<p>Now our <code>bind</code> function has to be adapted. Since <code>bind</code> is just a kind of "relay" between functions that unpacks and forwards a previously packed state tuple, the modification is quite local and easy to understand:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs105', 683)" onmouseover="showTip(event, 'fs105', 683)" class="fn">bind</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs106', 684)" onmouseover="showTip(event, 'fs106', 684)" class="fn">currentBlock</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 685)" onmouseover="showTip(event, 'fs76', 685)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueA</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateA</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs107', 686)" onmouseover="showTip(event, 'fs107', 686)" class="fn">rest</span><span class="pn">:</span> <span class="ta">&#39;</span><span class="id">valueA</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs76', 687)" onmouseover="showTip(event, 'fs76', 687)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueB</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateB</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 688)" onmouseover="showTip(event, 'fs76', 688)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueB</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateA</span> <span class="pn">*</span> <span class="ta">&#39;</span><span class="id">stateB</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs108', 689)" onmouseover="showTip(event, 'fs108', 689)" class="id">previousStatePack</span> <span class="k">-&gt;</span>

        <span class="c">// Deconstruct state pack:</span>
        <span class="c">// state is a tuple of: (&#39;stateA * &#39;stateB) option</span>
        <span class="c">// that gets transformed to: &#39;stateA option * &#39;stateB option</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs81', 690)" onmouseover="showTip(event, 'fs81', 690)" class="id">previousStateOfCurrentBlock</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs82', 691)" onmouseover="showTip(event, 'fs82', 691)" class="id">previousStateOfNextBlock</span> <span class="o">=</span>
            <span class="k">match</span> <span onmouseout="hideTip(event, 'fs108', 692)" onmouseover="showTip(event, 'fs108', 692)" class="id">previousStatePack</span> <span class="k">with</span>
            <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs109', 693)" onmouseover="showTip(event, 'fs109', 693)" class="id">None</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs109', 694)" onmouseover="showTip(event, 'fs109', 694)" class="id">None</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs109', 695)" onmouseover="showTip(event, 'fs109', 695)" class="id">None</span>
            <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs110', 696)" onmouseover="showTip(event, 'fs110', 696)" class="id">Some</span> <span class="pn">(</span><span class="id">stateA</span><span class="pn">,</span><span class="id">stateB</span><span class="pn">)</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs110', 697)" onmouseover="showTip(event, 'fs110', 697)" class="id">Some</span> <span class="id">stateA</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs110', 698)" onmouseover="showTip(event, 'fs110', 698)" class="id">Some</span> <span class="id">stateB</span>

        <span class="c">// no modifications from here:</span>
        <span class="c">// previousStateOfCurrentBlock and previousStateOfNextBlock are now</span>
        <span class="c">// both optional, but block who use it can deal with that.</span>
</code></pre>
<p>The key point here is that an incoming tuple of <code>('stateA * 'stateB) option</code> gets transformed to a tuple of <code>'stateA option * 'stateB option</code>. The two tuple elements can then be passed to their corresponding <code>currentBlock</code> and <code>nextBlock</code> inside the bind function.</p>
<p>The only thing that is missing is the adaption of the <code>Block</code> functions themselves, namely <code>lowPass</code> and <code>fadeIn</code>.</p>
<p>For <code>lowPass</code>, we assume that there is only one meaningful initial value that we always want to default to 0.0:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs111', 699)" onmouseover="showTip(event, 'fs111', 699)" class="fn">lowPass</span> <span onmouseout="hideTip(event, 'fs50', 700)" onmouseover="showTip(event, 'fs50', 700)" class="id">timeConstant</span> <span onmouseout="hideTip(event, 'fs3', 701)" onmouseover="showTip(event, 'fs3', 701)" class="id">input</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs76', 702)" onmouseover="showTip(event, 'fs76', 702)" class="uc">Block</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs112', 703)" onmouseover="showTip(event, 'fs112', 703)" class="id">lastOut</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs113', 704)" onmouseover="showTip(event, 'fs113', 704)" class="id">state</span> <span class="o">=</span> <span class="k">match</span> <span onmouseout="hideTip(event, 'fs112', 705)" onmouseover="showTip(event, 'fs112', 705)" class="id">lastOut</span> <span class="k">with</span> 
                    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs109', 706)" onmouseover="showTip(event, 'fs109', 706)" class="uc">None</span> <span class="k">-&gt;</span> <span class="n">0.0</span>      <span class="c">// initial value hard coded to 0.0</span>
                    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs110', 707)" onmouseover="showTip(event, 'fs110', 707)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs114', 708)" onmouseover="showTip(event, 'fs114', 708)" class="id">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs114', 709)" onmouseover="showTip(event, 'fs114', 709)" class="id">v</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs51', 710)" onmouseover="showTip(event, 'fs51', 710)" class="id">diff</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs113', 711)" onmouseover="showTip(event, 'fs113', 711)" class="id">state</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs3', 712)" onmouseover="showTip(event, 'fs3', 712)" class="id">input</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs64', 713)" onmouseover="showTip(event, 'fs64', 713)" class="id">out</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs113', 714)" onmouseover="showTip(event, 'fs113', 714)" class="id">state</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs51', 715)" onmouseover="showTip(event, 'fs51', 715)" class="id">diff</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs50', 716)" onmouseover="showTip(event, 'fs50', 716)" class="id">timeConstant</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs65', 717)" onmouseover="showTip(event, 'fs65', 717)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs64', 718)" onmouseover="showTip(event, 'fs64', 718)" class="id">out</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs64', 719)" onmouseover="showTip(event, 'fs64', 719)" class="id">out</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs113', 720)" onmouseover="showTip(event, 'fs113', 720)" class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs65', 721)" onmouseover="showTip(event, 'fs65', 721)" class="id">newState</span> <span class="pn">}</span>
</code></pre>
<p>For our <code>fadeIn</code>, we want the user to specify an initial value, since it might be that he or she does not want to fade from silence, but from half loudness:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs115', 722)" onmouseover="showTip(event, 'fs115', 722)" class="fn">fadeIn</span> <span onmouseout="hideTip(event, 'fs54', 723)" onmouseover="showTip(event, 'fs54', 723)" class="id">stepSize</span> <span onmouseout="hideTip(event, 'fs116', 724)" onmouseover="showTip(event, 'fs116', 724)" class="id">initial</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs3', 725)" onmouseover="showTip(event, 'fs3', 725)" class="id">input</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 726)" onmouseover="showTip(event, 'fs4', 726)" class="vt">float</span><span class="pn">)</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs76', 727)" onmouseover="showTip(event, 'fs76', 727)" class="uc">Block</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs117', 728)" onmouseover="showTip(event, 'fs117', 728)" class="id">lastValue</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs113', 729)" onmouseover="showTip(event, 'fs113', 729)" class="id">state</span> <span class="o">=</span> <span class="k">match</span> <span onmouseout="hideTip(event, 'fs117', 730)" onmouseover="showTip(event, 'fs117', 730)" class="id">lastValue</span> <span class="k">with</span> 
                    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs109', 731)" onmouseover="showTip(event, 'fs109', 731)" class="uc">None</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs116', 732)" onmouseover="showTip(event, 'fs116', 732)" class="id">initial</span>      <span class="c">// initial value can be specified</span>
                    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs110', 733)" onmouseover="showTip(event, 'fs110', 733)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs114', 734)" onmouseover="showTip(event, 'fs114', 734)" class="id">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs114', 735)" onmouseover="showTip(event, 'fs114', 735)" class="id">v</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs55', 736)" onmouseover="showTip(event, 'fs55', 736)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 737)" onmouseover="showTip(event, 'fs3', 737)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs113', 738)" onmouseover="showTip(event, 'fs113', 738)" class="id">state</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs65', 739)" onmouseover="showTip(event, 'fs65', 739)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs56', 740)" onmouseover="showTip(event, 'fs56', 740)" class="fn">min</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs113', 741)" onmouseover="showTip(event, 'fs113', 741)" class="id">state</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs54', 742)" onmouseover="showTip(event, 'fs54', 742)" class="id">stepSize</span><span class="pn">)</span> <span class="n">1.0</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs55', 743)" onmouseover="showTip(event, 'fs55', 743)" class="id">result</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs113', 744)" onmouseover="showTip(event, 'fs113', 744)" class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs65', 745)" onmouseover="showTip(event, 'fs65', 745)" class="id">newState</span> <span class="pn">}</span>
</code></pre>
<p>Now we have reached our goal. We can pass initial values in places in which they are needed and omit them when the author wants to specify them on his or her own.</p>
<p>So finally, we can just pass in <code>None</code> as the initial state, so that code looks like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// for simplification, we pass in constant drive and input values to blendedDistortion.</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs118', 746)" onmouseover="showTip(event, 'fs118', 746)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs98', 747)" onmouseover="showTip(event, 'fs98', 747)" class="fn">blendedDistortion</span> <span class="n">1.5</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs109', 748)" onmouseover="showTip(event, 'fs109', 748)" class="uc">None</span>
</code></pre>
<h3>Sequential Evaluation</h3>
<p>In the code above, we evaluates a <code>Block</code> one time. This gives one <code>BlockResult</code> value that contains the actual value and the accumulated state of that evaluation. Since we are not interested in a single value, but in a sequence of values for producing sound, we need to repeat the pattern.</p>
<p>Assuming we have a sequence that produces random values (here it's actually a list in F#, but it does not necessarily have to be a list; a sequence of values would be sufficient):</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs119', 799)" onmouseover="showTip(event, 'fs119', 799)" class="id">inputValues</span> <span class="o">=</span> <span class="pn">[</span> <span class="n">0.0</span><span class="pn">;</span> <span class="n">0.2</span><span class="pn">;</span> <span class="n">0.4</span><span class="pn">;</span> <span class="n">0.6</span><span class="pn">;</span> <span class="n">0.8</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">0.8</span><span class="pn">;</span> <span class="n">0.6</span><span class="pn">;</span> <span class="n">0.4</span><span class="pn">;</span> <span class="n">0.2</span><span class="pn">;</span> <span class="n">0.0</span> <span class="pn">]</span>
</code></pre>
<p>We can plot that sequence, too:</p>
<p><img src="./inputValues.png" alt="Input Values" /></p>
<p>Now we want to apply our <code>blendedDistortion</code> function to the <code>inputValues</code> sequence.</p>
<hint>
<p>Note that a <code>seq&lt;'a&gt;</code> in F# corresponds to <code>IEnumerable&lt;T&gt;</code> in C#/.NET. This means that by just defining a sequence, data is not persisted in memory until the sequence is evaluated (e.g., by iterating over it). A sequence can be infinite and can be viewed as a stream of values. It can be copied to a list or an array, but its values can also be completely transient.</p>
</hint>
<p>Now we need a mechanism for mapping over a sequence of input values to a sequence of output values. Before we write code, keep one thing in mind: at the end, we have to provide some kind of callback to an audio backend. This callback (as function pointer) is usually held by the audio backend and called multiple times when new data is needed. The purpose of the callback is to take an input array of values (in case of an effect) and produce an output array of values (usually, its indeed arrays). Since the callback is called multiple times, it has to store its state somewhere. Since the callback resides at the boundary of our functional system and the I/O world, we will store the latest state in a mutable variable that is captured by a closure (so you see that F# is not a "pure" functional language, but this can be an advantage and simplify work when it is appropriate). Have a look:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// (&#39;vIn -&gt; Block&lt;&#39;vOut,&#39;s&gt;) -&gt; (seq&lt;&#39;vIn&gt; -&gt; seq&lt;BlockOutput&lt;&#39;vOut, &#39;s&gt;&gt;)</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs120', 750)" onmouseover="showTip(event, 'fs120', 750)" class="fn">createEvaluatorWithStateAndValues</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs121', 751)" onmouseover="showTip(event, 'fs121', 751)" class="fn">blockWithInput</span><span class="pn">:</span> <span class="ta">&#39;</span><span class="id">vIn</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs76', 752)" onmouseover="showTip(event, 'fs76', 752)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">vOut</span><span class="pn">,</span><span class="ta">&#39;</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, 'fs122', 753)" onmouseover="showTip(event, 'fs122', 753)" class="mv">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs109', 754)" onmouseover="showTip(event, 'fs109', 754)" class="uc">None</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs123', 755)" onmouseover="showTip(event, 'fs123', 755)" class="id">inputValues</span> <span class="k">-&gt;</span>
        <span onmouseout="hideTip(event, 'fs124', 756)" onmouseover="showTip(event, 'fs124', 756)" class="k">seq</span> <span class="pn">{</span>
            <span class="k">for</span> <span onmouseout="hideTip(event, 'fs125', 757)" onmouseover="showTip(event, 'fs125', 757)" class="id">i</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs123', 758)" onmouseover="showTip(event, 'fs123', 758)" class="id">inputValues</span> <span class="k">-&gt;</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, 'fs126', 759)" onmouseover="showTip(event, 'fs126', 759)" class="fn">block</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs121', 760)" onmouseover="showTip(event, 'fs121', 760)" class="fn">blockWithInput</span> <span onmouseout="hideTip(event, 'fs125', 761)" onmouseover="showTip(event, 'fs125', 761)" class="id">i</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, 'fs127', 762)" onmouseover="showTip(event, 'fs127', 762)" class="id">result</span> <span class="o">=</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs71', 763)" onmouseover="showTip(event, 'fs71', 763)" class="fn">runB</span> <span onmouseout="hideTip(event, 'fs126', 764)" onmouseover="showTip(event, 'fs126', 764)" class="fn">block</span><span class="pn">)</span> <span onmouseout="hideTip(event, 'fs122', 765)" onmouseover="showTip(event, 'fs122', 765)" class="mv">state</span>
                <span onmouseout="hideTip(event, 'fs122', 766)" onmouseover="showTip(event, 'fs122', 766)" class="mv">state</span> <span class="k">&lt;-</span> <span onmouseout="hideTip(event, 'fs110', 767)" onmouseover="showTip(event, 'fs110', 767)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs127', 768)" onmouseover="showTip(event, 'fs127', 768)" class="id">result</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs128', 769)" onmouseover="showTip(event, 'fs128', 769)" class="id">state</span>
                <span onmouseout="hideTip(event, 'fs127', 770)" onmouseover="showTip(event, 'fs127', 770)" class="id">result</span>
        <span class="pn">}</span>
</code></pre>
<p>The <code>createEvaluatorWithStateAndValues</code> function itself takes a function as parameter. A single input value can be passed to that function that evaluates to a <code>Block</code>. That <code>Block</code> can then be evaluated itself. It produces a state that is assigned to the variable and the value that is finally yielded (together with the state) to our output sequence. This whole mechanism is wrapped in a function that takes an input array. This is the callback that could finally be passed to an audio backend. It can be evaluated multiple times, receiving the input buffer from the soundcard, mapping its values over with the given <code>Block</code> function and outputting a sequence of values that is taken by the audio backend.</p>
<hint>
<p>In the next chapter, we will analyze the results from our <code>blendedDistortion</code> effect. For now, we will just look at <em>how</em> we can evaluate blocks against an input value sequence.</p>
</hint>
<p>Using the <code>createEvaluatorWithStateAndValues</code> function is quite straightforward:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs129', 771)" onmouseover="showTip(event, 'fs129', 771)" class="fn">evaluateWithStateAndValues</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs98', 772)" onmouseover="showTip(event, 'fs98', 772)" class="fn">blendedDistortion</span> <span class="n">1.5</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs120', 773)" onmouseover="showTip(event, 'fs120', 773)" class="fn">createEvaluatorWithStateAndValues</span>

<span class="c">// we can evaluate a sequence of input values.</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs130', 774)" onmouseover="showTip(event, 'fs130', 774)" class="id">outputStateAndValues_cycle1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs129', 775)" onmouseover="showTip(event, 'fs129', 775)" class="fn">evaluateWithStateAndValues</span> <span onmouseout="hideTip(event, 'fs119', 776)" onmouseover="showTip(event, 'fs119', 776)" class="id">inputValues</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs131', 777)" onmouseover="showTip(event, 'fs131', 777)" class="m">Seq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs132', 778)" onmouseover="showTip(event, 'fs132', 778)" class="id">toList</span>

<span class="c">// evaluate more than once...</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs133', 779)" onmouseover="showTip(event, 'fs133', 779)" class="id">outputStateAndValues_cycle2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs129', 780)" onmouseover="showTip(event, 'fs129', 780)" class="fn">evaluateWithStateAndValues</span> <span onmouseout="hideTip(event, 'fs119', 781)" onmouseover="showTip(event, 'fs119', 781)" class="id">inputValues</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs131', 782)" onmouseover="showTip(event, 'fs131', 782)" class="m">Seq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs132', 783)" onmouseover="showTip(event, 'fs132', 783)" class="id">toList</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs134', 784)" onmouseover="showTip(event, 'fs134', 784)" class="id">outputStateAndValues_cycle3</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs129', 785)" onmouseover="showTip(event, 'fs129', 785)" class="fn">evaluateWithStateAndValues</span> <span onmouseout="hideTip(event, 'fs119', 786)" onmouseover="showTip(event, 'fs119', 786)" class="id">inputValues</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs131', 787)" onmouseover="showTip(event, 'fs131', 787)" class="m">Seq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs132', 788)" onmouseover="showTip(event, 'fs132', 788)" class="id">toList</span>
</code></pre>
<p>After creating the <code>evaluateWithStateAndValues</code> function, we can pass the input values sequence (with n elements) to it and receive a sequence (with n elements) as output. This output sequence contains elements of type <code>BlockOutput</code> that contain the actual value together with the state of that cycle:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">[</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.0</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.0</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.1</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.009</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.06</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.2</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.0384</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.168</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.3</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.07608</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.3144</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.4</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.119152</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.49152</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.5</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.174152</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.693216</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.6</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.23318592</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.8545728</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.7</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.294640192</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.98365824</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.8</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.3573853184</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">1.086926592</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.9</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.4206467866</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">1.169541274</span><span class="pn">,</span> <span class="pn">(</span><span class="n">1.0</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.4689082547</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">1.175633019</span><span class="pn">,</span> <span class="pn">(</span><span class="n">1.0</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.4551266038</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">1.120506415</span><span class="pn">,</span> <span class="pn">(</span><span class="n">1.0</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.404101283</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">1.016405132</span><span class="pn">,</span> <span class="pn">(</span><span class="n">1.0</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.2932810264</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.8731241057</span><span class="pn">,</span> <span class="pn">(</span><span class="n">1.0</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
    <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="n">0.1746248211</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="n">0.6984992845</span><span class="pn">,</span> <span class="pn">(</span><span class="n">1.0</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span><span class="pn">)</span> <span class="pn">}</span>
<span class="pn">]</span>
</code></pre>
<p>Now have a look at the state, more concretely. The first tuple element of the innermost tuple is the state of our <code>fadeIn</code> function. We defined that it should increase an internal factor by 0.1 every cycle (and then multiply the input with this value to have a fade-in effect). The value you see here is the internal factor that increases by 0.1 until the limit of 1.0 is reached. It looks like it is working - at least from an inner perspective.</p>
<p><strong>Pause and Continue</strong></p>
<p>Note that in our whole computation, there are no side effects at all, and our state is completely made up of values. This has some interesting consequences. We could take the computation code (<code>blendedDistortion</code>) and some arbitrary state object from the result list above. We could then (even on another computer) continue the computation by using the computation's code and the state we picked. The resulting elements would be the same on both machines.</p>
<p><strong>Values Only</strong></p>
<p>There is also a version that emits not values and state, but only values:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// (&#39;vIn -&gt; Block&lt;&#39;vOut,&#39;s&gt;) -&gt; (seq&lt;&#39;vIn&gt; -&gt; seq&lt;&#39;vOut&gt;)</span>
<span class="k">let</span> <span class="id">createEvaluatorWithValues</span> <span class="pn">(</span><span class="id">blockWithInput</span><span class="pn">:</span> <span class="id">&#39;</span><span class="id">vIn</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs76', 789)" onmouseover="showTip(event, 'fs76', 789)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">vOut</span><span class="pn">,</span><span class="id">&#39;</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="id">stateAndValueEvaluator</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs120', 790)" onmouseover="showTip(event, 'fs120', 790)" class="id">createEvaluatorWithStateAndValues</span> <span class="id">blockWithInput</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs119', 791)" onmouseover="showTip(event, 'fs119', 791)" class="id">inputValues</span> <span class="k">-&gt;</span>
        <span class="id">stateAndValueEvaluator</span> <span onmouseout="hideTip(event, 'fs119', 792)" onmouseover="showTip(event, 'fs119', 792)" class="id">inputValues</span>
        <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs131', 793)" onmouseover="showTip(event, 'fs131', 793)" class="id">Seq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs135', 794)" onmouseover="showTip(event, 'fs135', 794)" class="id">map</span> <span class="pn">(</span><span class="k">fun</span> <span class="id">stateAndValue</span> <span class="k">-&gt;</span> <span class="id">stateAndValue</span><span class="pn">.</span><span class="id">value</span><span class="pn">)</span>
</code></pre>
<p>The <code>createEvaluatorWithValues</code> function simply maps the <code>BlockOutput</code> values to just a sequence of pure values. The usage is quite the same as above:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">evaluateWithValues</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs98', 795)" onmouseover="showTip(event, 'fs98', 795)" class="id">blendedDistortion</span> <span class="n">1.5</span> <span class="o">|&gt;</span> <span class="id">createEvaluatorWithValues</span>
<span class="k">let</span> <span class="id">outputValues</span> <span class="o">=</span> <span class="id">evaluateWithValues</span> <span onmouseout="hideTip(event, 'fs119', 796)" onmouseover="showTip(event, 'fs119', 796)" class="id">inputValues</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs131', 797)" onmouseover="showTip(event, 'fs131', 797)" class="id">Seq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs132', 798)" onmouseover="showTip(event, 'fs132', 798)" class="id">toList</span>
</code></pre>
<p>The result is:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">[</span>
    <span class="n">0.0</span>
    <span class="n">0.009</span>
    <span class="n">0.0384</span>
    <span class="n">0.07608</span>
    <span class="n">0.119152</span>
    <span class="n">0.174152</span>
    <span class="n">0.23318592</span>
    <span class="n">0.29464019</span>
    <span class="n">0.3573853184</span>
    <span class="n">0.4206467866</span>
    <span class="n">0.4689082547</span>
    <span class="n">0.4551266038</span>
    <span class="n">0.404101283</span>
    <span class="n">0.2932810264</span>
    <span class="n">0.174624821</span>
<span class="pn">]</span>
</code></pre>
<p>The values are the same in both output sequences.</p>
<h2>Analysis</h2>
<hint>
<p>See [src/6<em>Retracing</em>Stateful_FP.fsx] as sample source.</p>
</hint>
<p>Now we can write blocks, understand the inner mechanism of composing them, and evaluate them. Time to have a closer look on our <code>blendedDistortion</code> use case. In the next chapter, we will dissect the parts of <code>blendedDistortion</code> step by step and retrace the flow of values through our computation.</p>
<p>Before we begin, the following samples use a constant set of parameters used in our computations:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">driveConstant</span> <span class="o">=</span> <span class="n">1.5</span>
<span class="k">let</span> <span class="id">hardLimitConstant</span> <span class="o">=</span> <span class="n">0.7</span>
<span class="k">let</span> <span class="id">lowPassConstant</span> <span class="o">=</span> <span class="n">0.4</span>
<span class="k">let</span> <span class="id">mixABConstant</span> <span class="o">=</span> <span class="n">0.5</span>
<span class="k">let</span> <span class="id">gainConstant</span> <span class="o">=</span> <span class="n">0.5</span>
<span class="k">let</span> <span class="id">fadeInStepSize</span> <span class="o">=</span> <span class="n">0.1</span>
</code></pre>
<p>...and there are some helper functions for evaluating a <code>Block</code> against the same set of input values:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs119', 799)" onmouseover="showTip(event, 'fs119', 799)" class="id">inputValues</span> <span class="o">=</span> <span class="pn">[</span> <span class="n">0.0</span><span class="pn">;</span> <span class="n">0.2</span><span class="pn">;</span> <span class="n">0.4</span><span class="pn">;</span> <span class="n">0.6</span><span class="pn">;</span> <span class="n">0.8</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">0.8</span><span class="pn">;</span> <span class="n">0.6</span><span class="pn">;</span> <span class="n">0.4</span><span class="pn">;</span> <span class="n">0.2</span><span class="pn">;</span> <span class="n">0.0</span> <span class="pn">]</span>
</code></pre>
<h3>Amplification</h3>
<p>Let's begin with the first part of our effect - the amplification. Besides that, we also show the original input values to compare them:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">inputChart</span> <span class="o">=</span> <span class="id">chart</span> <span class="s">&quot;0 - Input&quot;</span> <span onmouseout="hideTip(event, 'fs119', 800)" onmouseover="showTip(event, 'fs119', 800)" class="id">inputValues</span>

<span class="k">let</span> <span class="id">ampChart</span> <span class="o">=</span> 
    <span class="k">fun</span> <span class="id">drive</span> <span class="id">input</span> <span class="k">-&gt;</span> <span class="id">block</span> <span class="pn">{</span>
        <span class="k">let</span> <span class="id">amped</span> <span class="o">=</span> <span class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 801)" onmouseover="showTip(event, 'fs9', 801)" class="id">amp</span> <span class="id">drive</span>
        <span class="k">return</span> <span class="id">amped</span>
    <span class="pn">}</span>
    <span class="o">|&gt;</span> <span class="id">evalWithInputValuesAndChart</span> <span class="s">&quot;1 - amp&quot;</span>

<span class="pn">[</span> <span class="id">inputChart</span><span class="pn">;</span> <span class="id">ampChart</span> <span class="pn">]</span> <span class="o">|&gt;</span> <span class="id">showAll</span>
</code></pre>
<p><img src="./chart_input_and_amp.png" alt="Input &lt;-&gt; Amp" /></p>
<p><strong>Plausibility:</strong></p>
<p>Since we only amped the signal, which means in our case that we multiply it by a given factor, the result is comprehensive. The <code>drive</code> parameter is set to 1.5, which means to multiply every input value by 1.5. Try it - I didn't find a mistake.</p>
<hint>
<p>The effect of the amplifier is not only a higher volume, but also a steeper rise and descent of the curve, which - depending on the following process - can result in a stronger distortion (generation of overtones).</p>
</hint>
<h3>Hard Limit</h3>
<p>Next, the limiter comes into the game, taking the amplified value and limiting it to a given amount - in our case, 0.7.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">ampHardLimitChart</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="id">drive</span> <span class="id">input</span> <span class="k">-&gt;</span> <span class="id">block</span> <span class="pn">{</span>
        <span class="k">let</span> <span class="id">amped</span> <span class="o">=</span> <span class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 802)" onmouseover="showTip(event, 'fs9', 802)" class="id">amp</span> <span class="id">drive</span>
        <span class="k">let</span> <span class="id">hardLimited</span> <span class="o">=</span> <span class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 803)" onmouseover="showTip(event, 'fs5', 803)" class="id">limit</span> <span class="id">hardLimitConstant</span>
        <span class="k">return</span> <span class="id">hardLimited</span>
    <span class="pn">}</span>
    <span class="o">|&gt;</span> <span class="id">evalWithInputValuesAndChart</span> <span class="s">&quot;2 - amp &gt;&gt; hardLimited&quot;</span>
</code></pre>
<p><img src="./chart_amp_hardLimit.png" alt="Amp &lt;-&gt; Hard Limit" /></p>
<p><strong>Plausibility:</strong></p>
<p>All values above 0.7 are limited to 0.7.</p>
<h3>Low Pass</h3>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">ampLowPassChart</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="id">drive</span> <span class="id">input</span> <span class="k">-&gt;</span> <span class="id">block</span> <span class="pn">{</span>
        <span class="k">let</span> <span class="id">amped</span> <span class="o">=</span> <span class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 804)" onmouseover="showTip(event, 'fs9', 804)" class="id">amp</span> <span class="id">drive</span>
        <span class="k">let!</span> <span class="id">softLimited</span> <span class="o">=</span> <span class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs111', 805)" onmouseover="showTip(event, 'fs111', 805)" class="id">lowPass</span> <span class="id">lowPassConstant</span>
        <span class="k">return</span> <span class="id">softLimited</span>
    <span class="pn">}</span>
    <span class="o">|&gt;</span> <span class="id">evalWithInputValuesAndChart</span> <span class="s">&quot;3 - amp &gt;&gt; lowPass&quot;</span>

<span class="pn">[</span> <span class="id">ampChart</span><span class="pn">;</span> <span class="id">ampLowPassChart</span> <span class="pn">]</span> <span class="o">|&gt;</span> <span class="id">showAll</span>
</code></pre>
<p><img src="./chart_amp_lowPass.png" alt="Amp &lt;-&gt; Low Pass" /></p>
<p>The low pass is next, and interestingly, it is - like the hard limiter - fed by the amplified value. One way of understanding a low pass is that it "follows" a given input signal. We implemented the low pass as a so-called "first order lag element" from the electronic analog "currency-resistor-condenser".</p>
<p><strong>Plausibility:</strong></p>
<p>Looking at the chart, we see that the low passed signal follows its input (the amplified signal), but never reaches it because (because it only adds a fraction of the difference between output and input to it's output value). When the original signal drops, it is again faster than the lowPass output. Low pass is always slower, and that's the way it should work.</p>
<h3>Mix</h3>
<p>Mix is easy, since we have no "time" (no state) incorporated. It is completely linear and can be calculated with values at one single point in time, without looking at state or past values.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">mixedChart</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="id">drive</span> <span class="id">input</span> <span class="k">-&gt;</span> <span class="id">block</span> <span class="pn">{</span>
        <span class="k">let</span> <span class="id">amped</span> <span class="o">=</span> <span class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 806)" onmouseover="showTip(event, 'fs9', 806)" class="id">amp</span> <span class="id">drive</span>
        <span class="k">let</span> <span class="id">hardLimited</span> <span class="o">=</span> <span class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 807)" onmouseover="showTip(event, 'fs5', 807)" class="id">limit</span> <span class="id">hardLimitConstant</span>
        <span class="k">let!</span> <span class="id">softLimited</span> <span class="o">=</span> <span class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs111', 808)" onmouseover="showTip(event, 'fs111', 808)" class="id">lowPass</span> <span class="id">lowPassConstant</span>
        <span class="k">let</span> <span class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 809)" onmouseover="showTip(event, 'fs24', 809)" class="id">mix</span> <span class="n">0.5</span> <span class="id">hardLimited</span> <span class="id">softLimited</span>
        <span class="k">return</span> <span class="id">mixed</span>
    <span class="pn">}</span>
    <span class="o">|&gt;</span> <span class="id">evalWithInputValuesAndChart</span> <span class="s">&quot;4 - .. &gt;&gt; mixed&quot;</span>

<span class="pn">[</span> <span class="id">ampHardLimitChart</span><span class="pn">;</span> <span class="id">ampLowPassChart</span><span class="pn">;</span> <span class="id">mixedChart</span> <span class="pn">]</span> <span class="o">|&gt;</span> <span class="id">showAll</span>
</code></pre>
<p><img src="./chart_hardLimit_lowPass_mix.png" alt="Hard Limit &lt;-&gt; Low Pass &lt;-&gt; Mix" /></p>
<p><strong>Plausibility:</strong></p>
<p>Since we have a mix factor of 0.5, you can add both input values of a point in time and divide them by 2.0.</p>
<h3>Fade In</h3>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">mixedFadeInChart</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="id">drive</span> <span class="id">input</span> <span class="k">-&gt;</span> <span class="id">block</span> <span class="pn">{</span>
        <span class="k">let</span> <span class="id">amped</span> <span class="o">=</span> <span class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 810)" onmouseover="showTip(event, 'fs9', 810)" class="id">amp</span> <span class="id">drive</span>
        <span class="k">let</span> <span class="id">hardLimited</span> <span class="o">=</span> <span class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 811)" onmouseover="showTip(event, 'fs5', 811)" class="id">limit</span> <span class="id">hardLimitConstant</span>
        <span class="k">let!</span> <span class="id">softLimited</span> <span class="o">=</span> <span class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs111', 812)" onmouseover="showTip(event, 'fs111', 812)" class="id">lowPass</span> <span class="id">lowPassConstant</span>
        <span class="k">let</span> <span class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 813)" onmouseover="showTip(event, 'fs24', 813)" class="id">mix</span> <span class="id">mixABConstant</span> <span class="id">hardLimited</span> <span class="id">softLimited</span>
        <span class="k">let!</span> <span class="id">fadedIn</span> <span class="o">=</span> <span class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs115', 814)" onmouseover="showTip(event, 'fs115', 814)" class="id">fadeIn</span> <span class="id">fadeInStepSize</span> <span class="n">0.0</span>
        <span class="k">return</span> <span class="id">fadedIn</span>
    <span class="pn">}</span>
    <span class="o">|&gt;</span> <span class="id">evalWithInputValuesAndChart</span> <span class="s">&quot;5 - .. &gt;&gt; mixed &gt;&gt; fadeIn&quot;</span>

<span class="pn">[</span> <span class="id">mixedChart</span><span class="pn">;</span> <span class="id">mixedFadeInChart</span> <span class="pn">]</span> <span class="o">|&gt;</span> <span class="id">showAll</span>
</code></pre>
<p><img src="./chart_mix_fadeIn.png" alt="Mix &lt;-&gt; Fade In" /></p>
<p><strong>Plausibility:</strong></p>
<p>We analyzed fadeIn before, when we looked at evaluating blocks. We saw that the state value increased by the given step size of 0.1 every cycle. That was the inner view - we couldn't check whether the final calculation was correct. Now we can. The input of fadeIn (which is the "mix" value) has to be multiplied by the corresponding state value <code>[ 0; 0.1; 0.2 ;...]</code>. Now, believe it or not, I double checked all the values, and the assumption is true! (I'm happy if you do not believe me and check the facts on your own - it's easy).</p>
<p><img src="./calculator.png" alt="Doublechecking Fade In" /></p>
<h3>Gain</h3>
<p>Now the output gain stage:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">finalChart</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="id">drive</span> <span class="id">input</span> <span class="k">-&gt;</span> <span class="id">block</span> <span class="pn">{</span>
        <span class="k">let</span> <span class="id">amped</span> <span class="o">=</span> <span class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs9', 815)" onmouseover="showTip(event, 'fs9', 815)" class="id">amp</span> <span class="id">drive</span>
        <span class="k">let</span> <span class="id">hardLimited</span> <span class="o">=</span> <span class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs5', 816)" onmouseover="showTip(event, 'fs5', 816)" class="id">limit</span> <span class="id">hardLimitConstant</span>
        <span class="k">let!</span> <span class="id">softLimited</span> <span class="o">=</span> <span class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs111', 817)" onmouseover="showTip(event, 'fs111', 817)" class="id">lowPass</span> <span class="id">lowPassConstant</span>
        <span class="k">let</span> <span class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 818)" onmouseover="showTip(event, 'fs24', 818)" class="id">mix</span> <span class="id">mixABConstant</span> <span class="id">hardLimited</span> <span class="id">softLimited</span>
        <span class="k">let!</span> <span class="id">fadedIn</span> <span class="o">=</span> <span class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs115', 819)" onmouseover="showTip(event, 'fs115', 819)" class="id">fadeIn</span> <span class="id">fadeInStepSize</span> <span class="n">0.0</span>
        <span class="k">let</span> <span class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 820)" onmouseover="showTip(event, 'fs9', 820)" class="id">amp</span> <span class="id">gainConstant</span> <span class="id">fadedIn</span>
        <span class="k">return</span> <span class="id">gained</span>
    <span class="pn">}</span>
    <span class="o">|&gt;</span> <span class="id">evalWithInputValuesAndChart</span> <span class="s">&quot;6 - .. &gt;&gt; mixed &gt;&gt; fadeIn &gt;&gt; gained&quot;</span>

<span class="pn">[</span> <span class="id">mixedFadeInChart</span><span class="pn">;</span> <span class="id">finalChart</span> <span class="pn">]</span> <span class="o">|&gt;</span> <span class="id">showAll</span>
</code></pre>
<p><img src="./chart_fadeIn_gain.png" alt="Fade In &lt;-&gt; Gain" /></p>
<p><strong>Plausibility:</strong></p>
<p>This is also just an amplifier, which we parametrized with 0.5. So divide an input value by 2.0, and you get the result.</p>
<h3>Input - Final</h3>
<p>And finally - just for fun - the original input values compared to the final result:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">[</span> <span class="id">inputChart</span><span class="pn">;</span> <span class="id">finalChart</span> <span class="pn">]</span> <span class="o">|&gt;</span> <span class="id">showAll</span>
</code></pre>
<p><img src="./chart_final.png" alt="Final" /></p>
<h2>Appendix</h2>
<p>In this section, some more concepts are covered in a loose and very brief way.</p>
<h3>Appendix I - Feedback</h3>
<hint>
<p>See [src/8_Feedback.fsx] as sample source.</p>
</hint>
<p>Since we can do serial and parallel composition and we have a way for blocks to keep local state, one thing is missing: making a past value from inside of a computation available in the next cycle.</p>
<p>This can sometimes be done by extracting a "closed loop" in a sub-block, but when a past value from inside of a computation is needed in more than one position, this won't work.</p>
<p>Here is a block diagram explaining this:</p>
<p>// TODO: Blockschaltbild Feedback</p>
<p>Achieving this with the <code>block { ... }</code> syntax is not easy. Although we could emit a result at the end of the computation, there would be no direct way of accessing it as state in the next cycle. The state that is collected inside the <code>block { ... }</code> is not accessible to the user.</p>
<p>But there is a solution: feedback!</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="id">Fbd</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">fbdValue</span><span class="pn">,</span> <span class="id">&#39;</span><span class="id">value</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="pn">{</span> <span class="id">feedback</span><span class="pn">:</span> <span class="id">&#39;</span><span class="id">fbdValue</span><span class="pn">;</span> <span class="id">out</span><span class="pn">:</span> <span class="id">&#39;</span><span class="id">value</span> <span class="pn">}</span>

<span class="k">let</span> <span class="pn">(</span><span class="o">&lt;-&gt;</span><span class="pn">)</span> <span class="id">seed</span> <span class="pn">(</span><span class="id">f</span><span class="pn">:</span> <span class="id">&#39;</span><span class="id">fbdValue</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs76', 821)" onmouseover="showTip(event, 'fs76', 821)" class="id">Block</span><span class="pn">&lt;</span><span class="id">Fbd</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">fbdValue</span><span class="pn">,</span><span class="id">&#39;</span><span class="id">value</span><span class="pn">&gt;</span><span class="pn">,</span><span class="id">&#39;</span><span class="id">state</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs76', 822)" onmouseover="showTip(event, 'fs76', 822)" class="id">Block</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span class="id">prev</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span class="id">myPrev</span><span class="pn">,</span><span class="id">innerPrev</span> <span class="o">=</span> 
            <span class="k">match</span> <span class="id">prev</span> <span class="k">with</span>
            <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs109', 823)" onmouseover="showTip(event, 'fs109', 823)" class="id">None</span>            <span class="k">-&gt;</span> <span class="id">seed</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs109', 824)" onmouseover="showTip(event, 'fs109', 824)" class="id">None</span>
            <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs110', 825)" onmouseover="showTip(event, 'fs110', 825)" class="id">Some</span> <span class="pn">(</span><span class="id">my</span><span class="pn">,</span><span class="id">inner</span><span class="pn">)</span> <span class="k">-&gt;</span> <span class="id">my</span><span class="pn">,</span><span class="id">inner</span>
        <span class="k">let</span> <span class="id">fRes</span> <span class="o">=</span> <span class="id">f</span> <span class="id">myPrev</span>
        <span class="k">let</span> <span class="id">lRes</span> <span class="o">=</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs71', 826)" onmouseover="showTip(event, 'fs71', 826)" class="id">runB</span> <span class="id">fRes</span><span class="pn">)</span> <span class="id">innerPrev</span>
        <span class="k">let</span> <span class="id">feed</span> <span class="o">=</span> <span class="id">lRes</span><span class="pn">.</span><span class="id">value</span>
        <span class="k">let</span> <span class="id">innerState</span> <span class="o">=</span> <span class="id">lRes</span><span class="pn">.</span><span class="id">state</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span class="id">feed</span><span class="pn">.</span><span class="id">out</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="id">feed</span><span class="pn">.</span><span class="id">feedback</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs110', 827)" onmouseover="showTip(event, 'fs110', 827)" class="id">Some</span> <span class="id">innerState</span> <span class="pn">}</span>
</code></pre>
<p>The key is that the user can specify a function that - with the help of the feedback operator <code>&lt;-&gt;</code> - is evaluated and resulting in a <code>Block</code> itself. This <code>Block</code> accumulates the user's feedback value as well as the state of the actual computation and packs (later unpacks) it together.</p>
<h4>UseCase 1: Two Counter Alternatives</h4>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// some simple blocks</span>
<span class="k">let</span> <span class="id">counter</span> <span class="pn">(</span><span class="id">seed</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 828)" onmouseover="showTip(event, 'fs4', 828)" class="id">float</span><span class="pn">)</span> <span class="pn">(</span><span class="id">increment</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 829)" onmouseover="showTip(event, 'fs4', 829)" class="id">float</span><span class="pn">)</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs76', 830)" onmouseover="showTip(event, 'fs76', 830)" class="id">Block</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span class="id">maybeState</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span class="id">state</span> <span class="o">=</span> <span class="k">match</span> <span class="id">maybeState</span> <span class="k">with</span> <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs109', 831)" onmouseover="showTip(event, 'fs109', 831)" class="id">None</span> <span class="k">-&gt;</span> <span class="id">seed</span> <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs110', 832)" onmouseover="showTip(event, 'fs110', 832)" class="id">Some</span> <span class="id">v</span> <span class="k">-&gt;</span> <span class="id">v</span>
        <span class="k">let</span> <span class="id">res</span> <span class="o">=</span> <span class="id">state</span> <span class="o">+</span> <span class="id">increment</span>
        <span class="pn">{</span><span class="id">value</span><span class="o">=</span><span class="id">res</span><span class="pn">;</span> <span class="id">state</span><span class="o">=</span><span class="id">res</span><span class="pn">}</span>

<span class="c">// we can rewrite &#39;counter&#39; by using feedback:</span>
<span class="k">let</span> <span class="id">counterAlt</span> <span class="pn">(</span><span class="id">seed</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 833)" onmouseover="showTip(event, 'fs4', 833)" class="id">float</span><span class="pn">)</span> <span class="pn">(</span><span class="id">increment</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 834)" onmouseover="showTip(event, 'fs4', 834)" class="id">float</span><span class="pn">)</span> <span class="o">=</span>
    <span class="id">seed</span> <span class="o">&lt;-&gt;</span> <span class="k">fun</span> <span class="id">state</span> <span class="k">-&gt;</span>
        <span class="id">block</span> <span class="pn">{</span>
            <span class="k">let</span> <span class="id">res</span> <span class="o">=</span> <span class="id">state</span> <span class="o">+</span> <span class="id">increment</span>
            <span class="k">return</span> <span class="pn">{</span> <span class="id">out</span><span class="o">=</span><span class="id">res</span><span class="pn">;</span> <span class="id">feedback</span><span class="o">=</span><span class="id">res</span> <span class="pn">}</span>
        <span class="pn">}</span>
</code></pre>
<p>Look at the sample for evaluating the counter functions.</p>
<hint>All `Block` functions can be rewritten using the feedback operator.</hint>
<h4>UseCase 2: State in 'block { ... }' Syntax</h4>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">myFx</span> <span class="id">input</span> <span class="o">=</span>
    <span class="id">block</span> <span class="pn">{</span>
        <span class="c">// I would like to feed back the amped value</span>
        <span class="c">// and access it in the next cycly</span>
        <span class="c">// - but how?</span>
        <span class="k">let</span> <span class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 835)" onmouseover="showTip(event, 'fs9', 835)" class="id">amp</span> <span class="n">0.5</span> <span class="id">input</span> <span class="c">(* - (lastAmped * 0.1) *)</span>
        <span class="k">let!</span> <span class="id">lp</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs111', 836)" onmouseover="showTip(event, 'fs111', 836)" class="id">lowPass</span> <span class="n">0.2</span> <span class="id">amped</span>
        <span class="k">return</span> <span class="id">lp</span>
    <span class="pn">}</span>

<span class="k">let</span> <span class="id">myFxWithFeedback</span> <span class="id">input</span> <span class="o">=</span>
    <span class="c">// initial value for lastAmped is: 0.0</span>
    <span class="n">0.0</span> <span class="o">&lt;-&gt;</span> <span class="k">fun</span> <span class="id">lastAmped</span> <span class="k">-&gt;</span>
        <span class="id">block</span> <span class="pn">{</span>
            <span class="k">let</span> <span class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 837)" onmouseover="showTip(event, 'fs9', 837)" class="id">amp</span> <span class="n">0.5</span> <span class="id">input</span> <span class="o">-</span> <span class="pn">(</span><span class="id">lastAmped</span> <span class="pn">*</span> <span class="n">0.1</span><span class="pn">)</span>
            <span class="k">let!</span> <span class="id">lp</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs111', 838)" onmouseover="showTip(event, 'fs111', 838)" class="id">lowPass</span> <span class="n">0.2</span> <span class="id">amped</span>
            <span class="c">// we emit our actual value (lp), and the feedback value (amped)</span>
            <span class="k">return</span> <span class="pn">{</span> <span class="id">out</span><span class="o">=</span><span class="id">lp</span><span class="pn">;</span> <span class="id">feedback</span><span class="o">=</span><span class="id">amped</span> <span class="pn">}</span>
        <span class="pn">}</span>
</code></pre>
<h3>Appendix II - Arithmetic operators</h3>
<hint>
<p>See [src/9_Arithmetic.fsx] as sample source.</p>
</hint>
<p>Sometimes you want to make some arithmetic calculation from a <code>Block</code>'s result <em>directly</em> and not use the identifier of the bound value:</p>
<p>Instead of this...</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">block</span> <span class="pn">{</span>
    <span class="c">// we can add a Block and a float</span>
    <span class="k">let!</span> <span class="id">cnt</span> <span class="o">=</span> <span class="pn">(</span><span class="id">counter</span> <span class="n">0.0</span> <span class="n">1.0</span><span class="pn">)</span>
    <span class="k">let</span> <span class="id">cntPlus100</span> <span class="o">=</span> <span class="id">cnt</span> <span class="o">+</span> <span class="n">100.0</span>
    <span class="c">// do some other things with cntPlus100...</span>
    <span class="k">return</span> <span class="id">cnt</span>
<span class="pn">}</span>
</code></pre>
<p>...you want to do this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">block</span> <span class="pn">{</span>
    <span class="c">// we can add a Block and a float</span>
    <span class="k">let!</span> <span class="id">cnt</span> <span class="o">=</span> <span class="pn">(</span><span class="id">counter</span> <span class="n">0.0</span> <span class="n">1.0</span><span class="pn">)</span> <span class="o">+</span> <span class="n">100.0</span>
    <span class="k">return</span> <span class="id">cnt</span>
<span class="pn">}</span>
</code></pre>
<p>...or you even want to add two blocks directly:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">block</span> <span class="pn">{</span>
    <span class="c">// we can add 2 Blocks</span>
    <span class="k">let!</span> <span class="id">cnt</span> <span class="o">=</span> <span class="pn">(</span><span class="id">counter</span> <span class="n">0.0</span> <span class="n">1.0</span><span class="pn">)</span> <span class="o">+</span> <span class="pn">(</span><span class="id">counter</span> <span class="n">0.0</span> <span class="n">10.0</span><span class="pn">)</span>
    <span class="k">return</span> <span class="id">cnt</span>
<span class="pn">}</span>
</code></pre>
<p>This is possible with a more or less tricky mechanism incorporating an F# language feature called "Statically Resolved Type Parameters" in combination with a Single Case Union and operator overloading. An explanation of why and how this works is worth an article. Unfortunately, I cannot find the link to a presentation I once had, so please forgive me for not referencing the author of this idea.</p>
<p>Anyway, here is the code (as an example for <code>+</code>):</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="id">ArithmeticExt</span> <span class="o">=</span> <span class="id">ArithmeticExt</span> <span class="k">with</span>
    <span class="k">static</span> <span class="k">member</span> <span class="k">inline</span> <span class="pn">(</span><span class="o">?&lt;-</span><span class="pn">)</span> <span class="pn">(</span><span class="id">ArithmeticExt</span><span class="pn">,</span> <span class="id">a</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 839)" onmouseover="showTip(event, 'fs76', 839)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">v</span><span class="pn">,</span><span class="id">&#39;</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">,</span> <span class="id">b</span><span class="pn">)</span> <span class="o">=</span>
        <span class="id">block</span> <span class="pn">{</span>
            <span class="k">let!</span> <span class="id">aValue</span> <span class="o">=</span> <span class="id">a</span>
            <span class="k">return</span> <span class="id">aValue</span> <span class="o">+</span> <span class="id">b</span>
        <span class="pn">}</span>
    <span class="k">static</span> <span class="k">member</span> <span class="k">inline</span> <span class="pn">(</span><span class="o">?&lt;-</span><span class="pn">)</span> <span class="pn">(</span><span class="id">ArithmeticExt</span><span class="pn">,</span> <span class="id">a</span><span class="pn">,</span> <span class="id">b</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 840)" onmouseover="showTip(event, 'fs76', 840)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">v</span><span class="pn">,</span><span class="id">&#39;</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="id">block</span> <span class="pn">{</span>
            <span class="k">let!</span> <span class="id">bValue</span> <span class="o">=</span> <span class="id">b</span>
            <span class="k">return</span> <span class="id">a</span> <span class="o">+</span> <span class="id">bValue</span>
        <span class="pn">}</span>
    <span class="k">static</span> <span class="k">member</span> <span class="k">inline</span> <span class="pn">(</span><span class="o">?&lt;-</span><span class="pn">)</span> <span class="pn">(</span><span class="id">ArithmeticExt</span><span class="pn">,</span> <span class="id">a</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 841)" onmouseover="showTip(event, 'fs76', 841)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">v1</span><span class="pn">,</span><span class="id">&#39;</span><span class="id">s1</span><span class="pn">&gt;</span><span class="pn">,</span> <span class="id">b</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 842)" onmouseover="showTip(event, 'fs76', 842)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">v2</span><span class="pn">,</span><span class="id">&#39;</span><span class="id">s2</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="id">block</span> <span class="pn">{</span>
            <span class="k">let!</span> <span class="id">aValue</span> <span class="o">=</span> <span class="id">a</span>
            <span class="k">let!</span> <span class="id">bValue</span> <span class="o">=</span> <span class="id">b</span>
            <span class="k">return</span> <span class="id">aValue</span> <span class="o">+</span> <span class="id">bValue</span>
        <span class="pn">}</span>
    <span class="k">static</span> <span class="k">member</span> <span class="k">inline</span> <span class="pn">(</span><span class="o">?&lt;-</span><span class="pn">)</span> <span class="pn">(</span><span class="id">ArithmeticExt</span><span class="pn">,</span> <span class="id">a</span><span class="pn">,</span> <span class="id">b</span><span class="pn">)</span> <span class="o">=</span> <span class="id">a</span> <span class="o">+</span> <span class="id">b</span>

<span class="k">let</span> <span class="k">inline</span> <span class="pn">(</span><span class="o">+</span><span class="pn">)</span> <span class="id">a</span> <span class="id">b</span> <span class="o">=</span> <span class="pn">(</span><span class="o">?&lt;-</span><span class="pn">)</span> <span class="id">ArithmeticExt</span> <span class="id">a</span> <span class="id">b</span>
</code></pre>
<h3>Appendix III - Modulation ("map" and "apply")</h3>
<hint>
<p>See [src/10<em>Modulation</em>with<em>map</em>and_apply.fsx] as sample source.</p>
</hint>
<p>Quite often, you want to modulate parameters of one <code>Block</code> by the output value of another <code>Block</code>. Imagine this: You have an oscillator (e.g. a sine wave generator), and its frequence is not a constant value. Instead, it is the output value of another oscillator, that has a very low frequency (this is called LFO). The result is a sound that might remind you of a police cars siren.</p>
<p>I created a more comprehensive example, incorporating a <code>counter</code> and a <code>toggleAB</code> block:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">/// helper for working with optional state and seed value</span>
<span class="k">let</span> <span class="id">getStateOrSeed</span> <span class="id">seed</span> <span class="id">maybeState</span> <span class="o">=</span>
    <span class="k">match</span> <span class="id">maybeState</span> <span class="k">with</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs109', 843)" onmouseover="showTip(event, 'fs109', 843)" class="id">None</span> <span class="k">-&gt;</span> <span class="id">seed</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs110', 844)" onmouseover="showTip(event, 'fs110', 844)" class="id">Some</span> <span class="id">v</span> <span class="k">-&gt;</span> <span class="id">v</span>

<span class="k">let</span> <span class="id">counter</span> <span class="pn">(</span><span class="id">seed</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 845)" onmouseover="showTip(event, 'fs4', 845)" class="id">float</span><span class="pn">)</span> <span class="pn">(</span><span class="id">increment</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 846)" onmouseover="showTip(event, 'fs4', 846)" class="id">float</span><span class="pn">)</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs76', 847)" onmouseover="showTip(event, 'fs76', 847)" class="id">Block</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span class="id">maybeState</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span class="id">state</span> <span class="o">=</span> <span class="id">getStateOrSeed</span> <span class="id">seed</span> <span class="id">maybeState</span>
        <span class="k">let</span> <span class="id">res</span> <span class="o">=</span> <span class="id">state</span> <span class="o">+</span> <span class="id">increment</span>
        <span class="pn">{</span><span class="id">value</span><span class="o">=</span><span class="id">res</span><span class="pn">;</span> <span class="id">state</span><span class="o">=</span><span class="id">res</span><span class="pn">}</span>

<span class="k">type</span> <span class="id">AOrB</span> <span class="o">=</span> <span class="pn">|</span> <span class="id">A</span> <span class="pn">|</span> <span class="id">B</span>

<span class="c">/// from evaluation to evaluation take a, then b, then a, then b, ...</span>
<span class="k">let</span> <span class="id">toggleAB</span> <span class="id">a</span> <span class="id">b</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs76', 848)" onmouseover="showTip(event, 'fs76', 848)" class="id">Block</span> <span class="o">&lt;|</span> <span class="k">fun</span> <span class="id">maybeState</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span class="id">state</span> <span class="o">=</span> <span class="id">getStateOrSeed</span> <span class="id">A</span> <span class="id">maybeState</span>
        <span class="k">let</span> <span class="id">res</span><span class="pn">,</span><span class="id">newState</span> <span class="o">=</span>
            <span class="k">match</span> <span class="id">state</span> <span class="k">with</span>
            <span class="pn">|</span> <span class="id">A</span> <span class="k">-&gt;</span> <span class="id">a</span><span class="pn">,</span><span class="id">B</span>
            <span class="pn">|</span> <span class="id">B</span> <span class="k">-&gt;</span> <span class="id">b</span><span class="pn">,</span><span class="id">A</span>
        <span class="pn">{</span> <span class="id">value</span><span class="o">=</span><span class="id">res</span><span class="pn">;</span> <span class="id">state</span><span class="o">=</span><span class="id">newState</span> <span class="pn">}</span>
</code></pre>
<p>We can then use 2 <code>counter</code> and feed their results to <code>toggleAB</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="id">block</span> <span class="pn">{</span>
    <span class="k">let!</span> <span class="id">count1</span> <span class="o">=</span> <span class="id">counter</span> <span class="n">0.0</span> <span class="n">1.0</span>
    <span class="k">let!</span> <span class="id">count2</span> <span class="o">=</span> <span class="id">counter</span> <span class="n">0.0</span> <span class="n">20.0</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs118', 849)" onmouseover="showTip(event, 'fs118', 849)" class="id">result</span> <span class="o">=</span> <span class="id">toggleAB</span> <span class="id">count1</span> <span class="id">count2</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs118', 850)" onmouseover="showTip(event, 'fs118', 850)" class="id">result</span>
<span class="pn">}</span>
<span class="o">|&gt;</span> <span class="id">evaluateGen</span>

<span class="c">// Result: [1.0; 40.0; 3.0; 80.0; 5.0; 120.0; 7.0; 160.0; 9.0; 200.0]</span>
</code></pre>
<p>This works, but it can be annoying forced to always introduce an identifier (<code>count1</code>, <code>count2</code>), even if the values bound to them are only used in a single place.</p>
<p>Luckily, there are 2 functions called <code>map</code> and <code>apply</code> that help:</p>
<p><strong>map:</strong></p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">map</span> <span class="pn">(</span><span class="id">f</span><span class="pn">:</span> <span class="id">&#39;</span><span class="id">a</span> <span class="k">-&gt;</span> <span class="id">&#39;</span><span class="id">b</span><span class="pn">)</span> <span class="pn">(</span><span class="id">l</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 851)" onmouseover="showTip(event, 'fs76', 851)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">a</span><span class="pn">,</span><span class="id">_</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 852)" onmouseover="showTip(event, 'fs76', 852)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">b</span><span class="pn">,</span><span class="id">_</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="id">block</span> <span class="pn">{</span>
        <span class="k">let!</span> <span class="id">resL</span> <span class="o">=</span> <span class="id">l</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs118', 853)" onmouseover="showTip(event, 'fs118', 853)" class="id">result</span> <span class="o">=</span> <span class="id">f</span> <span class="id">resL</span>
        <span class="k">return</span> <span onmouseout="hideTip(event, 'fs118', 854)" onmouseover="showTip(event, 'fs118', 854)" class="id">result</span>
    <span class="pn">}</span>
<span class="k">let</span> <span class="pn">(</span> <span class="o">&lt;!&gt;</span> <span class="pn">)</span> <span class="o">=</span> <span class="id">map</span>
</code></pre>
<p>You might know <code>map</code> from other languages in the context of list processing, where the inner type of a list changes, but the domain (lists) remain. In C#, it is called <code>Select</code>, but with <code>f</code> and <code>l</code> parameters reversed.</p>
<p>In the domain of <code>Block</code>, map takes a function, and another <code>Block</code>, evaluates that block to get it's value, applies that value to the given function and returns it (in form of a <code>Block</code> - of course).</p>
<p>"What is that function f", you might ask yourself now. That function is nothing else but our <code>toggleAB</code> function: But <code>toggleAB</code> is of <code>'a -&gt; 'a -&gt; Block&lt;'a,_&gt;</code>? That's true, but remember currying: The first part is just <code>'a -&gt; 'a</code>, which is a specialization of <code>'a -&gt; 'b</code>. That means that after using <code>map</code>, the value that is wrapped inside the resulting <code>Block</code> is the partially applied function of <code>toggleAB</code> (<code>'a -&gt; Block&lt;'a,_&gt;</code>).</p>
<p>What we need now is a function that "unwraps" that partially applied function from the resulting block and applies a resulting value from another given <code>Block</code> to finally have the result available. We call it "apply".</p>
<p><strong>apply:</strong></p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="id">apply</span>
        <span class="pn">(</span><span class="id">fB</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 855)" onmouseover="showTip(event, 'fs76', 855)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs76', 856)" onmouseover="showTip(event, 'fs76', 856)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">b</span><span class="pn">,</span><span class="id">_</span><span class="pn">&gt;</span><span class="pn">,</span> <span class="id">_</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">(</span><span class="id">xB</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 857)" onmouseover="showTip(event, 'fs76', 857)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">a</span><span class="pn">,</span><span class="id">_</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs76', 858)" onmouseover="showTip(event, 'fs76', 858)" class="id">Block</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">b</span><span class="pn">,</span><span class="id">_</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="id">block</span> <span class="pn">{</span>
        <span class="k">let!</span> <span class="id">f</span> <span class="o">=</span> <span class="id">fB</span>
        <span class="k">let!</span> <span class="id">x</span> <span class="o">=</span> <span class="id">xB</span>
        <span class="k">let</span> <span class="id">fRes</span> <span class="o">=</span> <span class="id">f</span> <span class="id">x</span>
        
        <span class="c">// hint: So far, we have always bound the result of a block to an identifier and used &quot;return ident&quot;</span>
        <span class="c">// to yield the final result.</span>
        <span class="c">// Here we use &quot;return!&quot;, which simply yields the given block directly.</span>
        <span class="c">// to enable this, implement &#39;ReturnFrom(x)&#39; as method of the block builder type.</span>
        <span class="c">// Example here: 4_Optional_Initial_Values / BlockBuilder.ReturnFrom</span>
        <span class="k">return!</span> <span class="id">fRes</span>
    <span class="pn">}</span>
<span class="k">let</span> <span class="pn">(</span> <span class="o">&lt;*&gt;</span> <span class="pn">)</span> <span class="o">=</span> <span class="id">apply</span>
</code></pre>
<p><code>apply</code> can take the result of a <code>map</code>, and another <code>Block</code>, that serves as parameter for the given <em>inner</em> function that resides inside a <code>Block</code>. It applies the value <code>x</code> to the inner function <code>f</code> and returns the resulting <code>Block</code>.</p>
<p><strong>Example:</strong></p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// Alternative 2: use map and apply directly</span>
<span class="id">toggleAB</span> <span class="o">&lt;!&gt;</span> <span class="pn">(</span><span class="id">counter</span> <span class="n">0.0</span> <span class="n">1.0</span><span class="pn">)</span> <span class="o">&lt;*&gt;</span> <span class="pn">(</span><span class="id">counter</span> <span class="n">0.0</span> <span class="n">20.0</span><span class="pn">)</span>
<span class="o">|&gt;</span> <span class="id">evaluateGen</span>
<span class="c">// Result: [1.0; 40.0; 3.0; 80.0; 5.0; 120.0; 7.0; 160.0; 9.0; 200.0]</span>


<span class="c">// Hint: use map and apply also work inside a block computation expression</span>
<span class="id">block</span> <span class="pn">{</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs118', 859)" onmouseover="showTip(event, 'fs118', 859)" class="id">result</span> <span class="o">=</span> <span class="id">toggleAB</span> <span class="o">&lt;!&gt;</span> <span class="pn">(</span><span class="id">counter</span> <span class="n">0.0</span> <span class="n">1.0</span><span class="pn">)</span> <span class="o">&lt;*&gt;</span> <span class="pn">(</span><span class="id">counter</span> <span class="n">0.0</span> <span class="n">20.0</span><span class="pn">)</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs118', 860)" onmouseover="showTip(event, 'fs118', 860)" class="id">result</span>
<span class="pn">}</span>
<span class="o">|&gt;</span> <span class="id">evaluateGen</span>
<span class="c">// Result: [1.0; 40.0; 3.0; 80.0; 5.0; 120.0; 7.0; 160.0; 9.0; 200.0]</span>
</code></pre>
<h3>Appendix IV - OSS Experimental Project</h3>
<p>The basis for this article is an experimental OSS project I started a year ago. It is called FluX (it was called FLooping before, and I will probably change the name again). You can find the project on <a href="https://github.com/ronaldschlenker/FluX">Github</a>.</p>
<h4>Playing Audio</h4>
<p>Unfortunately, this topic is not covered in this article. So I suggest you have a look at FluX:</p>
<ul>
<li>you can actually play sounds, using a Node audio server or CSAudio as backend; and</li>
<li>there is a small library of effects and oscillators (hp, lp, sin, rect, tri, etc.)</li>
</ul>
<h4>Reader State</h4>
<p>For real-world audio applications, it is necessary to access some "global" values like the current sample rate or the position in a song for an evaluation cycle. In FluX, this is done by extending <code>Block</code> with the capability of what is called <code>reader</code>. This makes it possible to the <code>Block</code> author to access these "environmental" values inside of a <code>Block</code> function. This is simply done by passing another parameter besides state to the <code>Block</code> function.</p>

        <div class="tip" id="fs1">val amp : amount:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs2">val amount : float</div>
<div class="tip" id="fs3">val input : float</div>
<div class="tip" id="fs4">Multiple items<br />val float : value:&#39;T -&gt; float (requires member op_Explicit)<br /><br />--------------------<br />type float = System.Double<br /><br />--------------------<br />type float&lt;&#39;Measure&gt; = float</div>
<div class="tip" id="fs5">val limit : threshold:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs6">val threshold : float</div>
<div class="tip" id="fs7">val amp : amount:int -&gt; float</div>
<div class="tip" id="fs8">val amount : int</div>
<div class="tip" id="fs9">val amp : (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs10">val distort : drive:float -&gt; i:float -&gt; float</div>
<div class="tip" id="fs11">val drive : float</div>
<div class="tip" id="fs12">val i : float</div>
<div class="tip" id="fs13">val amplified : float</div>
<div class="tip" id="fs14">val limited : float</div>
<div class="tip" id="fs15">val distort1 : drive:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs16">val distort2 : drive:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs17">val distort3 : drive:float -&gt; (float -&gt; float)</div>
<div class="tip" id="fs18">val blendedDistortion : drive:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs19">val amped : float</div>
<div class="tip" id="fs20">val hardLimited : float</div>
<div class="tip" id="fs21">val softLimited : Block&lt;float&gt;</div>
<div class="tip" id="fs22">val lowPass : timeConstant:float -&gt; input:float -&gt; Block&lt;float&gt;</div>
<div class="tip" id="fs23">val mixed : float</div>
<div class="tip" id="fs24">val mix : abRatio:float -&gt; a:float -&gt; b:float -&gt; float</div>
<div class="tip" id="fs25">val fadedIn : Block&lt;float&gt;</div>
<div class="tip" id="fs26">val fadeIn : stepSize:float -&gt; input:float -&gt; Block&lt;float&gt;</div>
<div class="tip" id="fs27">val gained : float</div>
<div class="tip" id="fs28">val blendedDistortion_Alt1 : drive:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs29">val mixed : obj</div>
<div class="tip" id="fs30">val fadedIn : float</div>
<div class="tip" id="fs31">val blendedDistortion_Alt2 : drive:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs32">val x : &#39;a</div>
<div class="tip" id="fs33">val f : (&#39;a -&gt; &#39;b)</div>
<div class="tip" id="fs34">val blendedDistortion_Alt3 : drive:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs35">val mix4 : a:&#39;a -&gt; b:&#39;b -&gt; c:&#39;c -&gt; d:&#39;d -&gt; string</div>
<div class="tip" id="fs36">val a : &#39;a</div>
<div class="tip" id="fs37">val b : &#39;b</div>
<div class="tip" id="fs38">val c : &#39;c</div>
<div class="tip" id="fs39">val d : &#39;d</div>
<div class="tip" id="fs40">val sprintf : format:Printf.StringFormat&lt;&#39;T&gt; -&gt; &#39;T</div>
<div class="tip" id="fs41">val lowPass : frq:&#39;a -&gt; input:float -&gt; float</div>
<div class="tip" id="fs42">val frq : &#39;a</div>
<div class="tip" id="fs43">val fadeIn : stepSize:&#39;a -&gt; input:float -&gt; float</div>
<div class="tip" id="fs44">val stepSize : &#39;a</div>
<div class="tip" id="fs45">val abRatio : float</div>
<div class="tip" id="fs46">val a : float</div>
<div class="tip" id="fs47">val b : float</div>
<div class="tip" id="fs48">val lowPassCtor : unit -&gt; (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs49">val mutable lastOut : float</div>
<div class="tip" id="fs50">val timeConstant : float</div>
<div class="tip" id="fs51">val diff : float</div>
<div class="tip" id="fs52">val fadeInCtor : unit -&gt; (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs53">val mutable lastValue : float</div>
<div class="tip" id="fs54">val stepSize : float</div>
<div class="tip" id="fs55">val result : float</div>
<div class="tip" id="fs56">val min : e1:&#39;T -&gt; e2:&#39;T -&gt; &#39;T (requires comparison)</div>
<div class="tip" id="fs57">val softLimited : float</div>
<div class="tip" id="fs58">val blendedDistortionCtor : unit -&gt; (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs59">val lowPassInstance : (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs60">val fadeInInstance : (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs61">val softLimited : bool</div>
<div class="tip" id="fs62">val lowPass : timeConstant:float -&gt; input:float -&gt; lastOut:float -&gt; float * float</div>
<div class="tip" id="fs63">val lastOut : float</div>
<div class="tip" id="fs64">val out : float</div>
<div class="tip" id="fs65">val newState : float</div>
<div class="tip" id="fs66">type BlockOutput&lt;&#39;state&gt; =<br />&#160;&#160;{value: float;<br />&#160;&#160;&#160;state: &#39;state;}</div>
<div class="tip" id="fs67">BlockOutput.value: float</div>
<div class="tip" id="fs68">BlockOutput.state: &#39;state</div>
<div class="tip" id="fs69">Multiple items<br />union case Block.Block: (&#39;state -&gt; BlockOutput&lt;&#39;state&gt;) -&gt; Block&lt;&#39;state&gt;<br /><br />--------------------<br />type Block&lt;&#39;state&gt; = | Block of (&#39;state -&gt; BlockOutput&lt;&#39;state&gt;)</div>
<div class="tip" id="fs70">val lastValue : float</div>
<div class="tip" id="fs71">val runB : block:Block&lt;&#39;a&gt; -&gt; (&#39;a -&gt; BlockOutput&lt;&#39;a&gt;)</div>
<div class="tip" id="fs72">val block : Block&lt;&#39;a&gt;</div>
<div class="tip" id="fs73">val b : (&#39;a -&gt; BlockOutput&lt;&#39;a&gt;)</div>
<div class="tip" id="fs74">Multiple items<br />type BlockOutput&lt;&#39;state&gt; =<br />&#160;&#160;{value: float;<br />&#160;&#160;&#160;state: &#39;state;}<br /><br />--------------------<br />type BlockOutput&lt;&#39;value,&#39;state&gt; =<br />&#160;&#160;{value: &#39;value;<br />&#160;&#160;&#160;state: &#39;state;}</div>
<div class="tip" id="fs75">BlockOutput.value: &#39;value</div>
<div class="tip" id="fs76">Multiple items<br />union case Block.Block: (&#39;state -&gt; BlockOutput&lt;&#39;state&gt;) -&gt; Block&lt;&#39;state&gt;<br /><br />--------------------<br />type Block&lt;&#39;state&gt; = | Block of (&#39;state -&gt; BlockOutput&lt;&#39;state&gt;)<br /><br />--------------------<br />type Block&lt;&#39;value,&#39;state&gt; = &#39;state -&gt; BlockOutput&lt;&#39;value,&#39;state&gt;</div>
<div class="tip" id="fs77">val bind : currentBlock:Block&lt;float,&#39;stateA&gt; -&gt; rest:(float -&gt; Block&lt;&#39;valueB,&#39;stateB&gt;) -&gt; Block&lt;&#39;valueB,(&#39;stateA * &#39;stateB)&gt;</div>
<div class="tip" id="fs78">val currentBlock : Block&lt;float,&#39;stateA&gt;</div>
<div class="tip" id="fs79">val rest : (float -&gt; Block&lt;&#39;valueB,&#39;stateB&gt;)</div>
<div class="tip" id="fs80">val previousStatePack : obj * obj</div>
<div class="tip" id="fs81">val previousStateOfCurrentBlock : obj</div>
<div class="tip" id="fs82">val previousStateOfNextBlock : obj</div>
<div class="tip" id="fs83">val currentBlockOutput : BlockOutput&lt;obj&gt;</div>
<div class="tip" id="fs84">val nextBlock : Block&lt;&#39;valueB,&#39;stateB&gt;</div>
<div class="tip" id="fs85">val nextBlockOutput : BlockOutput&lt;obj&gt;</div>
<div class="tip" id="fs86">BlockOutput.state: obj</div>
<div class="tip" id="fs87">val blendedDistortion1 : drive:float -&gt; input:float -&gt; Block&lt;&#39;a,(&#39;b * (&#39;c * &#39;d))&gt;</div>
<div class="tip" id="fs88">val blendedDistortion2 : drive:float -&gt; input:float -&gt; Block&lt;&#39;a,(&#39;b * (&#39;c * &#39;d))&gt;</div>
<div class="tip" id="fs89">val blendedDistortion3 : drive:float -&gt; input:float -&gt; Block&lt;&#39;a,(&#39;b * (&#39;c * &#39;d))&gt;</div>
<div class="tip" id="fs90">val returnB : x:&#39;a -&gt; Block&lt;&#39;b&gt;</div>
<div class="tip" id="fs91">val blockFunction : (&#39;c -&gt; BlockOutput&lt;&#39;a,unit&gt;)</div>
<div class="tip" id="fs92">val unusedState : &#39;c</div>
<div class="tip" id="fs93">Multiple items<br />type Patch =<br />&#160;&#160;new : unit -&gt; Patch<br />&#160;&#160;member Bind : block:Block&lt;float,&#39;c&gt; * rest:(float -&gt; Block&lt;&#39;d,&#39;e&gt;) -&gt; Block&lt;&#39;d,(&#39;c * &#39;e)&gt;<br />&#160;&#160;member Return : x:&#39;a -&gt; Block&lt;&#39;b&gt;<br /><br />--------------------<br />new : unit -&gt; Patch</div>
<div class="tip" id="fs94">val this : Patch</div>
<div class="tip" id="fs95">val block : Block&lt;float,&#39;c&gt;</div>
<div class="tip" id="fs96">val rest : (float -&gt; Block&lt;&#39;d,&#39;e&gt;)</div>
<div class="tip" id="fs97">val patch : Patch</div>
<div class="tip" id="fs98">val blendedDistortion : drive:float -&gt; input:float -&gt; Block&lt;&#39;a,(&#39;b * (&#39;c * &#39;d))&gt;</div>
<div class="tip" id="fs99">val blendedDistortion : drive:&#39;a -&gt; input:&#39;b -&gt; &#39;c</div>
<div class="tip" id="fs100">val drive : &#39;a</div>
<div class="tip" id="fs101">val input : &#39;b</div>
<div class="tip" id="fs102">val initialState : float * (float * unit)</div>
<div class="tip" id="fs103">val result : BlockOutput&lt;obj,(float * (float * unit))&gt;</div>
<div class="tip" id="fs104">type &#39;T option = Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs105">val bind : currentBlock:Block&lt;&#39;valueA,&#39;stateA&gt; -&gt; rest:(&#39;valueA -&gt; Block&lt;&#39;valueB,&#39;stateB&gt;) -&gt; &#39;stateA * &#39;stateB -&gt; BlockOutput&lt;&#39;valueB,(&#39;stateA * &#39;stateB)&gt;</div>
<div class="tip" id="fs106">val currentBlock : Block&lt;&#39;valueA,&#39;stateA&gt;</div>
<div class="tip" id="fs107">val rest : (&#39;valueA -&gt; Block&lt;&#39;valueB,&#39;stateB&gt;)</div>
<div class="tip" id="fs108">val previousStatePack : &#39;stateA * &#39;stateB</div>
<div class="tip" id="fs109">union case Option.None: Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs110">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs111">val lowPass : timeConstant:float -&gt; input:float -&gt; Block&lt;float option&gt;</div>
<div class="tip" id="fs112">val lastOut : float option</div>
<div class="tip" id="fs113">val state : float</div>
<div class="tip" id="fs114">val v : float</div>
<div class="tip" id="fs115">val fadeIn : stepSize:float -&gt; initial:float -&gt; input:float -&gt; Block&lt;float option&gt;</div>
<div class="tip" id="fs116">val initial : float</div>
<div class="tip" id="fs117">val lastValue : float option</div>
<div class="tip" id="fs118">val result : BlockOutput&lt;obj,(obj * (obj * obj))&gt;</div>
<div class="tip" id="fs119">val inputValues : float list</div>
<div class="tip" id="fs120">val createEvaluatorWithStateAndValues : blockWithInput:(&#39;vIn -&gt; Block&lt;&#39;vOut,&#39;s&gt;) -&gt; (seq&lt;&#39;vIn&gt; -&gt; seq&lt;BlockOutput&lt;&#39;a option&gt;&gt;)</div>
<div class="tip" id="fs121">val blockWithInput : (&#39;vIn -&gt; Block&lt;&#39;vOut,&#39;s&gt;)</div>
<div class="tip" id="fs122">val mutable state : &#39;a option</div>
<div class="tip" id="fs123">val inputValues : seq&lt;&#39;vIn&gt;</div>
<div class="tip" id="fs124">Multiple items<br />val seq : sequence:seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />--------------------<br />type seq&lt;&#39;T&gt; = System.Collections.Generic.IEnumerable&lt;&#39;T&gt;</div>
<div class="tip" id="fs125">val i : &#39;vIn</div>
<div class="tip" id="fs126">val block : Block&lt;&#39;vOut,&#39;s&gt;</div>
<div class="tip" id="fs127">val result : BlockOutput&lt;&#39;a option&gt;</div>
<div class="tip" id="fs128">BlockOutput.state: &#39;a option</div>
<div class="tip" id="fs129">val evaluateWithStateAndValues : (float list -&gt; seq&lt;BlockOutput&lt;obj option&gt;&gt;)</div>
<div class="tip" id="fs130">val outputStateAndValues_cycle1 : BlockOutput&lt;obj option&gt; list</div>
<div class="tip" id="fs131">module Seq<br /><br />from Microsoft.FSharp.Collections</div>
<div class="tip" id="fs132">val toList : source:seq&lt;&#39;T&gt; -&gt; &#39;T list</div>
<div class="tip" id="fs133">val outputStateAndValues_cycle2 : BlockOutput&lt;obj option&gt; list</div>
<div class="tip" id="fs134">val outputStateAndValues_cycle3 : BlockOutput&lt;obj option&gt; list</div>
<div class="tip" id="fs135">val map : mapping:(&#39;T -&gt; &#39;U) -&gt; source:seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;U&gt;</div>

      </div>
      <div class="span1"></div>
    </div>

  </div>
</body>

</html>