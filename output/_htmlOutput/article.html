<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <!--
      The Digital Signal Processing with F# (in the Domain of Audio and Music)
 parameters will be replaced with the
      document title extracted from the <h1> element or
      file name, if there is no <h1> heading
    -->
  <title>Digital Signal Processing with F# (in the Domain of Audio and Music)
</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script src="http://code.jquery.com/jquery-1.8.0.js"></script>
  <!-- <script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script> -->
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <!-- <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet"> -->
  <link type="text/css" rel="stylesheet" href="content/style.css" />
  <link type="text/css" rel="stylesheet" href="content/custom_style.css" />

  <script src="content/tips.js" type="text/javascript"></script>

  <script>
    $(document).ready(function () {
      $('hint').prepend("<p><b>Hint</b></p>");
      $('excurs').each(function () {
        var name = $(this).data('name');
        $(this).prepend("<p><b>Excurs: " + name + "</b></p>");
      });
    });

    $(document).ready(function () {
      $(tocList).empty();

      var prevH2Item = null;
      var prevH2List = null;

      var index = 0;
      $("h2, h3").each(function () {

        //insert an anchor to jump to, from the TOC link.            
        var anchor = "<a name='" + index + "'></a>";
        $(this).before(anchor);

        var li = "<li><a href='#" + index + "'>" + $(this).text() + "</a></li>";

        if ($(this).is("h2")) {
          prevH2List = $("<ul></ul>");
          prevH2Item = $(li);
          prevH2Item.append(prevH2List);
          prevH2Item.appendTo("#tocList");
        } else {
          prevH2List.append(li);
        }
        index++;
      });
    }); 
  </script>

  <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body>
  <div class="container markdown-body">

    <div class="row" style="margin-top:30px">
      <div class="span1"></div>
      <div class="span10" id="main">
        <h1>Digital Signal Processing with F# (in the Domain of Audio and Music)</h1>
<div id="tocDiv">
    <ul id="tocList">
    </ul>
</div>
<h2>Einleitung und Motivation</h2>
<p>Making music with the help of computers is not a new approach. It started with music N (TODO: Nochmal ausbauen)... and one ask might the question: Why do we need yet another language?</p>
<p>In the analog world, physical quantities like the electric currency are used to represent a signal that is finally sent to a speaker. Thes quantities are created and altered by low-level components like condensors, resistors, magnetic coils, transistors, diods, etc. which are connected to each others in circuits. They are composed to larger components like operational amplifiers, that are again used to build modules like filters and oscillators which synthesizers and effect processors are made of. Digital audio signal processing (Audio-DSP) is about modeling these components on different levels of abstraction, resulting in the simulation of circuits similar to their analog counterparts (of course, there is no limit in creating completely new forms of synthesizers and effects).</p>
<p>If you are already familiar with languages like Java or C#, you might think that DSP fits perfectly in the world of object-oriented programming languages: With it's basic idea of encapsulating mutable state by behavior (methods) and giving it an addressable identity (instance pointer), it maps directly to the concept of having physical entities (like condensors or transistors) that "exist" and hold their's own state that changes over time. This article is about an alternative approach of audio-DSP which is solely based on the paradigm of pure functions using a language called F#. TODO: Benefits</p>
<p>(<strong><em></em></strong>
We will learn that object-oriented concept like instances (and therfore instanciation) as well as aspects of method evaluation can be left out completely, leading to a way of describing signal flows and circuits purely focussing on how values flow through the system.</p>
<p>Key point: Eigentlich denkt man: OO,  ...this leads to - well, it lead me to pure functions!
"Well, it lead me to pure functional programming, and we will see why it is superior to an object-oriented approach when we want to express stateful computations.
<strong></strong>)</p>
<h2>What you can expect from this article</h2>
<p>Kurzer Überblick - warum machen wir das?</p>
<p>Worum geht es: Um einen Weg, Signalflüsse in einer dafür passenden Form - ohne Boilerplate, etc - zu beschreiben. "and it tuens out that a functional language called F# brings all the flexibility to "tune" itself in a way we can do this".</p>
<p>Bedingungen:
<em> Write small, easy to understand pieces of code (let's call them "blocks")
</em> We want to be able to use these blocks in a larger context, means by composing them.
* It shall then be able to use the results of the composition as blocks themselves, that are again composable, and so on.</p>
<h2>Abgrenzung</h2>
<ul>
<li>Audio signals (means: at the end, we are interested in a sequence of float values)</li>
<li>Time domain only</li>
<li>Performance: Not considered here.</li>
</ul>
<h2>A Brief Definition of DSP</h2>
<p>TODO: Bild: Werte, Buffer, Souncard, Speaker
TODO: Erklären: Audio Loop</p>
<p>Digital signal processing - in contrast to analog signal processing - deals with quantized values over a discrete time. What does it mean: Take an analog synthesizer. It creates and outputs a signal based on electric currency - which is continuous from a physical point of view. A computer cannot process values in a continuous way - it has to <em>quantize</em> two things:
<em> Time: This is called sampling, and happens for an audio signal usually at multiples of 44100 times per second (44.1 kHz). Why 44100? Look at TODO: Sample Theorem.
</em> Values: At each sample point, a value must be captured (analog to the electric currency). This happens usually in a number, represented by a 16, 32 or 64 bit value. In this article, we use a F# "float" value, which is a 64 bit floating point number.</p>
<p>Having understood the definition from above, it's easy to define what a signal is: <strong>A signal is a value that changes over time</strong>. Sampling of these values with constant time intervals results in a sequence of values:</p>
<p>TODO: Plot</p>
<p>As we can see, we have captured a sine wave with the <em>amplitude</em> of 0.5 (see here TODO) and a frequence of 1Hz (1 complete cycle in 1s). The sample rate is 16Hz. Why? Because we have captured 16 samples in 1 second.</p>
<p>Given the information that we have a sample rate of 16Hz, we can simplify our time-value sequence to just a value sequence:
[ 0.0; 0.3; ...]</p>
<p>The point-in-time of the the n-th value in the sequence can easily be calculated when sample rate and starting time are given. This fact is fundamental, and leads to a definition of what <em>processing</em> means:</p>
<statement>Processing signal is creating or changing sequence of values.</statement>
<h3>Constraints:</h3>
<ul>
<li>Real Time: Meistens will man Effekte oder erzeugte Klänge sofort hören - z.B. wenn man live spielt oder an seinem Computer-Musik Programm sitzt. D.h. wir sind nicht an Funktionen interessiert, die auf einer kompletten Sequenz arbeiten oder diese generieren, sondern an Funktionen, die einen Ausschnitt oder sogar nur <strong>Einzelwerte</strong> verarbeiten. So we are interested in functions that operate on these values. Beispiel: Live-Musik und Effektgerät: Nicht zuerst alles einspielen und dann den Effekt drüberlegen. Das alles soll quasi "sofort" passieren mit einer sehr geringen Latenz (Def: Latenz).</li>
</ul>
<p>We treat a 'sequence of values' like a stream instead of a random access persistent array, so that when we talk about signal processing, we mean 'steam processing' in this article.</p>
<ul>
<li>Composable (nicht immer als Ganzes schreiben) and reusable</li>
<li></li>
<li>Signale sind symmetrisch (schwingen um die Null-Linie). Das muss oft beachtet werden, wenn wir Algorithmen programmieren.</li>
<li>Mono</li>
</ul>
<h2>Goals</h2>
<p>TODO</p>
<h2>Nachvollziehen: Die Beispiele können in VS Code / Ionide, F# Interactive nachvollzogen werden.</h2>
<p>TODO</p>
<h2>Writing stateless processing functions</h2>
<h3>What we have learned so far</h3>
<p>TODO
* Was Signale sind</p>
<p>[von vorher:
Transformation of Generator functions
Then: Apply these functions to every single value of a sequence.
]</p>
<p>TODO: Hier muss erklärt werden, was wir erreichen wollen. Also das Beispiel direkt mit Blockschaltbild usw. erklären, da man sonst nicht weiß, was das alles soll.</p>
<p>[TODO: Kurzes Vorwort, was uns hier erwartet.] Please note that currently, we are not interested in the way</p>
<p>Let's start with something simple.</p>
<ul>
<li>Gegeben ist immer ein Eingangssignal</li>
<li>Das wird angezeigt in Form einer Werteliste sowie eines Plots.</li>
<li>Blockschaltbild</li>
</ul>
<p>Knowing that we are so far interested in functions that transform scalar inputs to scalar outputs, we will have a look at some simple examples of processing functions. Later on, we will see how we can compose these small functions to a larger systems.</p>
<h3>Amplifier</h3>
<p>Amplifying signals is a science for itself and one can spend a lot of money buying analog gear that sounds just "right" - where right is a subjective term based on user preferences. For us, a simple solution will be enough: Amplification of a signal in our context means: Scale values linearly. We can do that like this:</p>
<p>[Bild: Signal vorher - nachher]</p>
<p>Linear scaling of a value is mathematically just a multiplication, so that is indeed very simple. This function does the job:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// float -&gt; float -&gt; float</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="id">amount</span> <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="id">input</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 5)" onmouseover="showTip(event, 'fs3', 5)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs2', 6)" onmouseover="showTip(event, 'fs2', 6)" class="id">amount</span>
</code></pre>
<p>TODO: Blockschaltbild machen</p>
<excurs data-name="Currying">
We only write the "returning" type (float). The types of amount and i are infered. Can also write it with explicit types for all input params:
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 7)" onmouseover="showTip(event, 'fs1', 7)" class="fn">amp</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs2', 8)" onmouseover="showTip(event, 'fs2', 8)" class="id">amount</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 9)" onmouseover="showTip(event, 'fs4', 9)" class="vt">float</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs3', 10)" onmouseover="showTip(event, 'fs3', 10)" class="id">input</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 11)" onmouseover="showTip(event, 'fs4', 11)" class="vt">float</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 12)" onmouseover="showTip(event, 'fs4', 12)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 13)" onmouseover="showTip(event, 'fs3', 13)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs2', 14)" onmouseover="showTip(event, 'fs2', 14)" class="id">amount</span>
</code></pre>
<ul>
<li>We could also write it with inline. That's a powerful feature and works for all types having * defined. For now, we use explicit return types and implicit</li>
</ul>
<p>Currying: Makes it simper</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs5', 15)" onmouseover="showTip(event, 'fs5', 15)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs6', 16)" onmouseover="showTip(event, 'fs6', 16)" class="id">amount</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 17)" onmouseover="showTip(event, 'fs4', 17)" class="vt">float</span> <span class="o">=</span> <span class="o">(*)</span> <span onmouseout="hideTip(event, 'fs6', 18)" onmouseover="showTip(event, 'fs6', 18)" class="id">amount</span>
</code></pre>
<p>Currying is extremely important for us, and we will understand why when it comes to composing our functions.</p>
<p>Again, we could leave out amount, having defined just an alias for the (*) function:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs7', 19)" onmouseover="showTip(event, 'fs7', 19)" class="fn">amp</span> <span class="o">=</span> <span class="o">(*)</span>
</code></pre>
<p>In the ongoing samples, we will use the first variant <code>fsharp let amp amount input : float = input * amount</code> so that we have some meaningful names for our arguments (for multiplication, the order of arguments dowsn't matter, but there are a lot of other functions where precedence matters (TODO: wirklich precedence?)). SO let's stick with the first version.</p>
</excurs>
<p>TODO: Currying erklären mit Blockschaltbild und der Hintereinanderlegung der Parameter mit kleinen Kästen drumherum; Currying ist eine Art Factory für andere Funktionen.</p>
<p>Sample: [in] -&gt; [out] mit einfachen Werten</p>
<h3>Another example: Hard Limiter</h3>
<p>Now that we have our amplifier, we want to have the ability to "limit" a signal to a certain value. Again, there are a lot of ways to do this in a "nice" sounding way, but we will use a very simple technique that leads to a very harsh sounding distortion when the input signal gets limited. The limiter looks like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// float -&gt; float -&gt; float</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs8', 20)" onmouseover="showTip(event, 'fs8', 20)" class="fn">limit</span> <span onmouseout="hideTip(event, 'fs9', 21)" onmouseover="showTip(event, 'fs9', 21)" class="id">threshold</span> <span onmouseout="hideTip(event, 'fs3', 22)" onmouseover="showTip(event, 'fs3', 22)" class="id">input</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 23)" onmouseover="showTip(event, 'fs4', 23)" class="vt">float</span> <span class="o">=</span>
    <span class="k">if</span> <span onmouseout="hideTip(event, 'fs3', 24)" onmouseover="showTip(event, 'fs3', 24)" class="id">input</span> <span class="o">&gt;</span> <span onmouseout="hideTip(event, 'fs9', 25)" onmouseover="showTip(event, 'fs9', 25)" class="id">threshold</span> <span class="k">then</span> <span onmouseout="hideTip(event, 'fs9', 26)" onmouseover="showTip(event, 'fs9', 26)" class="id">threshold</span>
    <span class="k">else</span> <span class="k">if</span> <span onmouseout="hideTip(event, 'fs3', 27)" onmouseover="showTip(event, 'fs3', 27)" class="id">input</span> <span class="o">&lt;</span> <span class="o">-</span><span onmouseout="hideTip(event, 'fs9', 28)" onmouseover="showTip(event, 'fs9', 28)" class="id">threshold</span> <span class="k">then</span> <span class="o">-</span><span onmouseout="hideTip(event, 'fs9', 29)" onmouseover="showTip(event, 'fs9', 29)" class="id">threshold</span>
    <span class="k">else</span> <span onmouseout="hideTip(event, 'fs3', 30)" onmouseover="showTip(event, 'fs3', 30)" class="id">input</span>
</code></pre>
<p>TODO: Blockschaltbild; Currying</p>
<p>Side Note: * Signale sind symmetrisch (schwingen um die Null-Linie). Das muss oft beachtet werden, wenn wir Algorithmen programmieren.</p>
<h3>Applying the processing functions</h3>
<p>TODO: Erklären:
<em> We have an audio runtime. That runtime expects functions in the form of float -&gt; float. Recipe:
</em> Input sequence
<em> processing function
</em> Seq
* Currently, we are not interested in applying our functions to get a result, this comes later. We focus on writing (and composing) processing / generator functions.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">[</span> <span class="n">0.1</span><span class="pn">;</span> <span class="n">0.2</span><span class="pn">;</span> <span class="n">0.8</span><span class="pn">;</span> <span class="o">-</span><span class="n">0.2</span><span class="pn">;</span> <span class="o">-</span><span class="n">0.7</span> <span class="pn">]</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 31)" onmouseover="showTip(event, 'fs10', 31)" class="m">Seq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs11', 32)" onmouseover="showTip(event, 'fs11', 32)" class="id">map</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs8', 33)" onmouseover="showTip(event, 'fs8', 33)" class="fn">limit</span> <span class="n">0.5</span><span class="pn">)</span>
<span class="c">// output: [0.1; 0.2; 0.5; -0.2; -0.5]</span>
</code></pre>
<p>Test this in FSI!</p>
<p>// TODO: Amp mit einem nicht linearen SKalierung machen, so dass das Beispiel nicht komplett trivial ist und wir erkennen können, dass es sich lohnt, diese Funktion zu schreiben. Diese "Übertragungskurve" dann noch zeichnen.</p>
<h2>Composing stateless processing functions</h2>
<h3>Serial Composition</h3>
<p>The amplify and limit functions are so small that we won't break them into smaller pieces for reusing them. They are kind of "atoms" in our context. But of course, we want to do the opposite: Compose them to larger, higher-level functions (that themselves can be composed again, to higher-level functions, and so on).</p>
<p>Let's say we want to build some nice distortion effect that is defined in this way:</p>
<p><img src="./Folie1.tif" alt="Block diagram A" /></p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 34)" onmouseover="showTip(event, 'fs12', 34)" class="fn">distort</span> <span onmouseout="hideTip(event, 'fs13', 35)" onmouseover="showTip(event, 'fs13', 35)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs14', 36)" onmouseover="showTip(event, 'fs14', 36)" class="id">i</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 37)" onmouseover="showTip(event, 'fs15', 37)" class="id">amplified</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 38)" onmouseover="showTip(event, 'fs7', 38)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 39)" onmouseover="showTip(event, 'fs13', 39)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs14', 40)" onmouseover="showTip(event, 'fs14', 40)" class="id">i</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs16', 41)" onmouseover="showTip(event, 'fs16', 41)" class="id">limited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 42)" onmouseover="showTip(event, 'fs8', 42)" class="fn">limit</span> <span class="n">1.0</span> <span onmouseout="hideTip(event, 'fs15', 43)" onmouseover="showTip(event, 'fs15', 43)" class="id">amplified</span>
    <span onmouseout="hideTip(event, 'fs16', 44)" onmouseover="showTip(event, 'fs16', 44)" class="id">limited</span>
</code></pre>
<p>The "drive" parameter controls how much distortion we want: 0 means no distortion; 1 means: a lot of distortion. We achieve this by a feeding the input into our amplifier. The output of the amp is then fed into a limiter. Let's call this technique of somposition <em>serial composition</em>.</p>
<p>We use explicit identifier ("amplified", "result") and evaluate our amp and limit functions. This can be a useful technique e.g. when we want to re-use the "amplified" value in a more complex scenario (which we will see shortly). For serial composition, there are alternatives that we can use to make our code more "compact":</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs17', 45)" onmouseover="showTip(event, 'fs17', 45)" class="fn">distort1</span> <span onmouseout="hideTip(event, 'fs13', 46)" onmouseover="showTip(event, 'fs13', 46)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 47)" onmouseover="showTip(event, 'fs3', 47)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 48)" onmouseover="showTip(event, 'fs8', 48)" class="fn">limit</span> <span class="n">1.0</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs7', 49)" onmouseover="showTip(event, 'fs7', 49)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 50)" onmouseover="showTip(event, 'fs13', 50)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 51)" onmouseover="showTip(event, 'fs3', 51)" class="id">input</span><span class="pn">)</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs18', 52)" onmouseover="showTip(event, 'fs18', 52)" class="fn">distort2</span> <span onmouseout="hideTip(event, 'fs13', 53)" onmouseover="showTip(event, 'fs13', 53)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 54)" onmouseover="showTip(event, 'fs3', 54)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 55)" onmouseover="showTip(event, 'fs7', 55)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 56)" onmouseover="showTip(event, 'fs13', 56)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 57)" onmouseover="showTip(event, 'fs3', 57)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 58)" onmouseover="showTip(event, 'fs8', 58)" class="fn">limit</span> <span class="n">1.0</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 59)" onmouseover="showTip(event, 'fs19', 59)" class="fn">distort3</span> <span onmouseout="hideTip(event, 'fs13', 60)" onmouseover="showTip(event, 'fs13', 60)" class="id">drive</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 61)" onmouseover="showTip(event, 'fs7', 61)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 62)" onmouseover="showTip(event, 'fs13', 62)" class="id">drive</span> <span class="o">&gt;</span><span class="pn">&gt;</span> <span onmouseout="hideTip(event, 'fs8', 63)" onmouseover="showTip(event, 'fs8', 63)" class="fn">limit</span> <span class="n">1.0</span>
</code></pre>
<p>1)
...inline the expressions. This is a bit sad because the signal flow is reversed: It is written limit, then amp. But the order of evaluation is amp, then limit. To make our code look more like the actual signal flow, we can use...</p>
<p>2)
...the pipe operator. The pipe operator is explained [here; TODO: Exkurs] and dows basically this: It applies the function on the left side and uses it's result to feed it to the function on the right side. How can that work?</p>
<p>[Bild: (float -&gt; float) |&gt; (float -&gt; float)]</p>
<p>Remember the previous chapter, it was remarked that currying was very important. Now we can see why: We said that we are interested in functions of form <em>float -&gt; float</em>, and now it's clear why: It enables us to compose functions in always the same manner. But when we review our amp function (and also the limit function), we see that they are float -&gt; float -&gt; float. This is because they not only transform an input value to an output value; they also require an additional parameter to control their behavior.</p>
<p>[TODO: weiterschreiben und Currying erklären; auch mit inneren Lambdas]</p>
<p>So, curryin can also be seen as a way of providing "factories for other functions". And it is important that we design our "factory functions" in a way that all parameters come first, then followed by the input value to have a float-&gt;float function at the end. When things get more complex in the following section, the technique of factory functions will help us a lot.</p>
<p>3)
Erklären; Blockschaltbild. This is nice, because it is just a "Bauanleitung" for a signal flow. Which means: We don't have to care about evaluating things. And we do not have to specify an "i" (input) explicitly; this "ergibt sich" from the composition itself.</p>
<p>[TODO: Depending on the character of the circuit, we will use a mix of all 4 forms.]</p>
<h3>Parallel Composition (Branch and Merge)</h3>
<p>TODO: Parallel doesn't (necessarily) mean parallel execution. This can be, but doesn't have to be.</p>
<p>Now that we understand what serial composition is, we know that it is useful to have functions of type float-&gt;float, and we understand that serial composition of these functions can be done by using the <em>&gt;&gt;</em> or <em>|&gt;</em> operators.</p>
<p>Let's extend our sample in a way where the techniques of serial composition is not sufficient.</p>
<p>The distortion effect we just engineered sounds nice, and we want to be able to "blend it in" together with a low-pass filtered version of the original signal. This low-pass signal shall be used for distortion, too. Visualizing this in a block diagram is easy [TODO: inhaltlich nicht korrekt (siehe Codebeispiel); viel mehr erklären]:</p>
<p><img src="./Folie3.tif" alt="Block diagram B" /></p>
<p>Some things to note:</p>
<ul>
<li>The output value of "amp" is used in 2 following branches.</li>
<li>The output values of the 2 branches are then aggregated by the "mix" block.</li>
<li>The output value can then be processed further by the "fadeIn" block.</li>
<li>And finally, we have an output gain to lower the signal's strength.</li>
</ul>
<p>Now we will look at a technique how we can map this behavior to F# code.</p>
<p>Think about what "branching" means: "Use an evaluated value in more than 1 place in the rest of a computation".</p>
<p>As usual, there are a lot of ways to achieve this, and I recommend taking some time and thinking about how this could be done. In our sample, we will use a very simple recipe: Each time we need branching, we bind an evaluated value to an identifier:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 64)" onmouseover="showTip(event, 'fs20', 64)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs13', 65)" onmouseover="showTip(event, 'fs13', 65)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 66)" onmouseover="showTip(event, 'fs3', 66)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 67)" onmouseover="showTip(event, 'fs21', 67)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 68)" onmouseover="showTip(event, 'fs3', 68)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 69)" onmouseover="showTip(event, 'fs7', 69)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 70)" onmouseover="showTip(event, 'fs13', 70)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 71)" onmouseover="showTip(event, 'fs22', 71)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 72)" onmouseover="showTip(event, 'fs21', 72)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 73)" onmouseover="showTip(event, 'fs8', 73)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 74)" onmouseover="showTip(event, 'fs23', 74)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 75)" onmouseover="showTip(event, 'fs21', 75)" class="id">amped</span> <span class="o">|&gt;</span> <span class="id">lowPass</span> <span class="n">0.2</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs24', 76)" onmouseover="showTip(event, 'fs24', 76)" class="id">mixed</span> <span class="o">=</span> <span class="id">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 77)" onmouseover="showTip(event, 'fs22', 77)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs23', 78)" onmouseover="showTip(event, 'fs23', 78)" class="id">softLimited</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 79)" onmouseover="showTip(event, 'fs25', 79)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs24', 80)" onmouseover="showTip(event, 'fs24', 80)" class="id">mixed</span> <span class="o">|&gt;</span> <span class="id">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 81)" onmouseover="showTip(event, 'fs26', 81)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 82)" onmouseover="showTip(event, 'fs7', 82)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 83)" onmouseover="showTip(event, 'fs25', 83)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs26', 84)" onmouseover="showTip(event, 'fs26', 84)" class="id">gained</span>
</code></pre>
<p>By introducing the "amped" identifier, we are able to use it's value in more than one place in the rest of our computation. Merging is nothing more that feeding evaluated branches into an appropriate function. Note that in the code above, there comes the "mix 0.5" first, then the 2 branches. This is reversed to what is done in the block diagram. In appendix, there are alternatives that let the "mix 0.5" appear after the branches. TODO: See appendix (||&gt; bzw. ^&gt;)</p>
<h4>A note on "lowPass" and "fadeIn:</h4>
<p>Note that for now, we don't have a low pass filter, so we just use a placeholder function that works like a normal stateless processing function of type <code>float -&gt; float</code>:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 85)" onmouseover="showTip(event, 'fs27', 85)" class="fn">lowPass</span> <span onmouseout="hideTip(event, 'fs28', 86)" onmouseover="showTip(event, 'fs28', 86)" class="id">frq</span> <span onmouseout="hideTip(event, 'fs3', 87)" onmouseover="showTip(event, 'fs3', 87)" class="id">input</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 88)" onmouseover="showTip(event, 'fs4', 88)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 89)" onmouseover="showTip(event, 'fs3', 89)" class="id">input</span> <span class="c">// just a dummy - for now...</span>
</code></pre>
<p>The same is for fadeIn:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs29', 90)" onmouseover="showTip(event, 'fs29', 90)" class="fn">fadeIn</span> <span onmouseout="hideTip(event, 'fs30', 91)" onmouseover="showTip(event, 'fs30', 91)" class="id">stepSize</span> <span onmouseout="hideTip(event, 'fs3', 92)" onmouseover="showTip(event, 'fs3', 92)" class="id">input</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 93)" onmouseover="showTip(event, 'fs4', 93)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 94)" onmouseover="showTip(event, 'fs3', 94)" class="id">input</span> <span class="c">// just a dummy - for now...</span>
</code></pre>
<h4>A note on "mix":</h4>
<p>As we can see, we need a "mix" function that has a "abRatio" parameter to control the amount of original and processed signal in the final output. 0 means: only signal a; 1 means: only signal b.</p>
<p>The function is this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs31', 95)" onmouseover="showTip(event, 'fs31', 95)" class="fn">mix</span> <span onmouseout="hideTip(event, 'fs32', 96)" onmouseover="showTip(event, 'fs32', 96)" class="id">abRatio</span> <span onmouseout="hideTip(event, 'fs33', 97)" onmouseover="showTip(event, 'fs33', 97)" class="id">a</span> <span onmouseout="hideTip(event, 'fs34', 98)" onmouseover="showTip(event, 'fs34', 98)" class="id">b</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 99)" onmouseover="showTip(event, 'fs4', 99)" class="vt">float</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs33', 100)" onmouseover="showTip(event, 'fs33', 100)" class="id">a</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs32', 101)" onmouseover="showTip(event, 'fs32', 101)" class="id">abRatio</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs34', 102)" onmouseover="showTip(event, 'fs34', 102)" class="id">b</span> <span class="o">*</span> <span class="pn">(</span><span class="n">1.0</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs32', 103)" onmouseover="showTip(event, 'fs32', 103)" class="id">abRatio</span><span class="pn">)</span>
</code></pre>
<p>again test it with:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs31', 104)" onmouseover="showTip(event, 'fs31', 104)" class="fn">mix</span> <span class="n">0.0</span> <span class="n">0.3</span> <span class="n">0.8</span> <span class="o">=</span> <span class="n">0.3</span>  <span class="c">// true</span>
<span onmouseout="hideTip(event, 'fs31', 105)" onmouseover="showTip(event, 'fs31', 105)" class="fn">mix</span> <span class="n">0.5</span> <span class="n">0.3</span> <span class="n">0.8</span> <span class="o">=</span> <span class="n">0.55</span> <span class="c">// true</span>
<span onmouseout="hideTip(event, 'fs31', 106)" onmouseover="showTip(event, 'fs31', 106)" class="fn">mix</span> <span class="n">1.0</span> <span class="n">0.3</span> <span class="n">0.8</span> <span class="o">=</span> <span class="n">0.8</span>  <span class="c">// true</span>
</code></pre>
<!-- 
As we see, the function is not float->float anymore after all parameters have been applied; it is float->float->float. This is understandable because it needs 2 inputs instead of one. As a consequence, we cannot use "mix" as a processor for our audio runtime. But we can use it inside of a processor as an element in our computation:  -->
<statement>
Our rule is: Each time we branch a signal, we give it a name (there are alternative ways of branching that don't need identifiers (TODO: Alternative: arrows)).
</statement>
<h4>A note on the signature of "blendedDistortion"</h4>
<p>TODO: It's again float -&gt; float. This is important because we can pass this function to our "audio runtime".</p>
<h2>Writing Stateful Processing Functions</h2>
<p>In the previous chapters, we wrote and composed pure (stateless) functions. This means that processing a signal (= a sequence of values) was made up of the following "recipe" (see chapter 1):</p>
<ul>
<li>We have a sequence of input values.</li>
<li>We have a processing function.</li>
<li>That function is curried, so that after application of all parameters values, a function of float-&gt;float remains.</li>
<li>We have a "runtime" that generates an output sequence by mapping each value in the input sequence to a value in the output sequence by applying the processor function to an the input value.</li>
</ul>
<h3>Revisit Low Pass Filter</h3>
<p>In the last chapter, we treated the "Low Pass Filter" function as if it was pure, which means: From evaluation cycle to cycle, it doesn't "remember" anything; there is no information preserved between evaluations of the same function. In case of a filter, this cannot work, because filters need more than a single value: They deal with frequencies, and the concept of frequency requires a timespan: It's about how a sequence of values change ofer time. It's like with stock prices: You cannot say if there was a crash or if the market is hot by just looking at the current value. You need to look at the development of a price during a certain timespan. And, there are more things: Some filters only need some past input values (FIR; finite impulse response). But there are other filter designs that depend on their past output values (IIR; infinite impulse response). So we need a mechanism that preserves past input, past output (and maybe past intermediate) values.</p>
<h4>Very Brief theory of a low pass filter</h4>
<p>TODO: tl;dr version anbieten und den Rest hier in den Anhang.</p>
<p>The most simple way of designing an electronic low pass is using a resistor and a condensor in series, which is then connected to a currency that represents the input signal. The output signal is the currency of the condensor. So why is that a low pass filter?</p>
<p>TODO: Bild</p>
<p>First, the resistor: It works like a valve in a water pipe: it limits the possibility of electrons to flow around. So when you connect the poles of a battery to each other, you will get a shortcut, because the electrons can go from one pole to the other without any obstacle (and releasing the battery's energy in a very short amount of time). But if you connect the poles to a resistor (e.g. a glowing lamp), the electron flow is limited (thus releasing the battery'S energy in a much longer timespan).</p>
<p>Second, the condensor: Basically, it works like a battery - it can store and release energy - only much faster. It is made up of 2 poles (e.g. metal plates). Each plate can be charged up with a certain amount of electrons; the more electrons it has, the higher the currency measured between the 2 plates. Connecting a battery to each plate, the electrons will flow from the 1 pole of the battery to the connected plate of the condensor, and the electrons from the other condencor plate will flow to the other pole of the battery. <em>After some time</em> (which depends on the dimension of the resistor), the condensor has the same currency as the battery, and it is then fully loaded. If you switch the connected battery poles (+ <> -), the condensor will first unload and then load again with switched currency direction, until it is in balance with the battery again.</p>
<p>Since the currency represents our input signal, we can say:</p>
<ul>
<li>High frequency is a fast change of currency.</li>
<li>High frequency is a slow change of currency.</li>
</ul>
<p>So when the input currency changes very quickly (high frequency), the condensor has not enough time to fill itself up with electrons, and if we measure it's currency, it will be almost zero. When the input currency changes slowly, the condensor has time for it's load and unload cycle, so we will be able to measure a currency (which equal approximately the input signal when the input frequency change is 0).</p>
<p>And that's out low pass filter: Low input frequencys can be measured at the condensor output, high frequencies have no effect on the measured condensor output currency.</p>
<p>The key point for this is: The condensor brings the time into the game! It has state, which is made up of the "current electron load". The next moment's output value is made up of the last moment's internal value and a current external input value.</p>
<p>How can that be modeled?</p>
<h4>State in the block diagram</h4>
<p>Let's describe the characteristics of this low pass filter in a textual way:</p>
<ol>
<li>An instance of low pass filter has state that represents the load amount. In our case, that state is proportional to the output value (like the amount of electrons is proportional to the output currency of the condensor).</li>
<li>
<p>The "calculation recipe" for the output value from one moment to the next moment is this:</p>
<ul>
<li>Take the output value from the last evaluation (which we call "lastOut").</li>
<li>Take the difference between lastOut and the current input.</li>
<li>Multiply that difference with a given time constant (to slow down the load time and thus adjusting the cutoff frequency).</li>
<li>The current output value is that difference subtracted from lastOut.</li>
</ul>
</li>
</ol>
<p>That's it. Think about it: The bigger the difference between current input and the last output value, the faster the condensor "loads up". The smaller the time constant gets, the slower the system reacts to input value changes - a low pass filter!</p>
<p>Let's see how we can implement it in a block diagram:</p>
<p><img src="./lpf_inside.tif" alt="Low pass filter" /></p>
<p>One interesting thing to notice: There is no explicit state in the way that we store or memorize values. Instead, the state is modeled as "output value delayed by 1 sample" ("t-1" block), which is then fed back into the next evaluation of the whole function. <strong>This is a key point</strong> because we can model any kind of local state in that way - no matter how that state structured (it doesn't have to be a simple <code>float</code>- it could be anything). A abstract "block with state" can then be modeled like this:</p>
<p><img src="./block_with_state_and_params.tif" alt="Block with state and parameters" /></p>
<p>Beside the output value, there is an output state. And beside the input value, there comes an input state that is the output state from the last evaluation (plus curried function parameters - as usual).</p>
<p>In the following chapters, we will have a look on ways of writing and composing such functions, and we will understand that these ways provide less or more compfort for the user who wants to express signal processing computations.</p>
<p>We start with an object oriented programming approach.</p>
<!-- 
TODO:
    * Kondensator modellieren mit Rückkopplung
    * Rückkopplung ist "intern" - Kasten drum; black box
    * Dann: Verwendung
<p>OOP:
<em> Es ist ok, das so mit mutable zu schreiben.
</em> Aber: Die Verwendung ist doof, weil: Wir <em>brauchen</em> eine Referenz.
<em> Identity in imperative lang is made by an address. Accessing the address is made by a name.
</em> BlockDiag: Identity (of the concrete LP filter instance) is made by it's location in the computation.
--&gt;</p>
<h2>Composing Stateful Objects</h2>
<p>As the name already implies, we are first going to use an approach that is called "Object Oriented Programming". What is that?</p>
<p>"Object oriented programming (OOP) is the thing with classes."</p>
<p>IMHO, that's not true (at least, it's not the key point). It's true that many object oriented programming languages have a class based type system - but that's not the essence of OOP. Another definition of what OOP might be is when 3 things occure together:</p>
<ul>
<li>References: Data is held in objects that have a referential identity (not a value-based identity).</li>
<li>Mutability: Object values can change over time, while it's identity remains (objects are mutable).</li>
<li>Encapsulation: Data access is protected via methods to help ensuring consistency during runtime (encapsulation of local state).</li>
</ul>
<p>These three characteristics can be seen as features, but at the same time, one has to deal with their consequences, and this has significant impact on how code is written and used. The upcoming OOP-samples use non-class techniques with functions as objects and closures that capture mutable values. The approach is still object-oriented by the definition from above and it could be easily transformed into code with classes, leading to the same insights. But no matter if you use class-based or non-class-based OOP approach, they differ fundamentally from a pure functional approach where we have no effects (no mutation) and only values (no references).</p>
<h3>"Low Pass" and "Fade In" in OOP</h3>
<h4>Implementation</h4>
<p>Here is our implementation of the low pass in F# with OOP techniques:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs35', 107)" onmouseover="showTip(event, 'fs35', 107)" class="fn">lowPassCtor</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, 'fs36', 108)" onmouseover="showTip(event, 'fs36', 108)" class="mv">lastOut</span> <span class="o">=</span> <span class="n">0.0</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs37', 109)" onmouseover="showTip(event, 'fs37', 109)" class="id">timeConstant</span> <span onmouseout="hideTip(event, 'fs3', 110)" onmouseover="showTip(event, 'fs3', 110)" class="id">input</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs38', 111)" onmouseover="showTip(event, 'fs38', 111)" class="id">diff</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs36', 112)" onmouseover="showTip(event, 'fs36', 112)" class="mv">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs3', 113)" onmouseover="showTip(event, 'fs3', 113)" class="id">input</span>
        <span onmouseout="hideTip(event, 'fs36', 114)" onmouseover="showTip(event, 'fs36', 114)" class="mv">lastOut</span> <span class="k">&lt;-</span> <span onmouseout="hideTip(event, 'fs36', 115)" onmouseover="showTip(event, 'fs36', 115)" class="mv">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs38', 116)" onmouseover="showTip(event, 'fs38', 116)" class="id">diff</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs37', 117)" onmouseover="showTip(event, 'fs37', 117)" class="id">timeConstant</span>
        <span onmouseout="hideTip(event, 'fs36', 118)" onmouseover="showTip(event, 'fs36', 118)" class="mv">lastOut</span>
</code></pre>
<p>What we have here:</p>
<ul>
<li>The "lowPassCtor" is a factory function that evaluates to another function.</li>
<li>This resulting function can be evaluated giving a timeConstant parameter and an input value (it is again a function of <code>float -&gt; float</code> after applying all parameters).</li>
<li>It captures a mutable "lastOut" value, that is initialized once when the lowPassCtor factory is called. That value changes each time the resulting function is evaluated.</li>
</ul>
<p>The same is for "fade in":</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs39', 119)" onmouseover="showTip(event, 'fs39', 119)" class="fn">fadeInCtor</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, 'fs40', 120)" onmouseover="showTip(event, 'fs40', 120)" class="mv">lastValue</span> <span class="o">=</span> <span class="n">0.0</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs41', 121)" onmouseover="showTip(event, 'fs41', 121)" class="id">stepSize</span> <span onmouseout="hideTip(event, 'fs3', 122)" onmouseover="showTip(event, 'fs3', 122)" class="id">input</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs42', 123)" onmouseover="showTip(event, 'fs42', 123)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 124)" onmouseover="showTip(event, 'fs3', 124)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs40', 125)" onmouseover="showTip(event, 'fs40', 125)" class="mv">lastValue</span>
        <span onmouseout="hideTip(event, 'fs40', 126)" onmouseover="showTip(event, 'fs40', 126)" class="mv">lastValue</span> <span class="k">&lt;-</span> <span onmouseout="hideTip(event, 'fs43', 127)" onmouseover="showTip(event, 'fs43', 127)" class="fn">min</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs40', 128)" onmouseover="showTip(event, 'fs40', 128)" class="mv">lastValue</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs41', 129)" onmouseover="showTip(event, 'fs41', 129)" class="id">stepSize</span><span class="pn">)</span> <span class="n">1.0</span>
        <span onmouseout="hideTip(event, 'fs42', 130)" onmouseover="showTip(event, 'fs42', 130)" class="id">result</span>
</code></pre>
<h4>Usage</h4>
<p>In chapter 3 (TODO), we have already seen how we <em>would like</em> to use the low pass filter: Like a pure function. Here is again how:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// that compiles, but doesn&#39;t work.    </span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 131)" onmouseover="showTip(event, 'fs20', 131)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs13', 132)" onmouseover="showTip(event, 'fs13', 132)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 133)" onmouseover="showTip(event, 'fs3', 133)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 134)" onmouseover="showTip(event, 'fs21', 134)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 135)" onmouseover="showTip(event, 'fs3', 135)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 136)" onmouseover="showTip(event, 'fs7', 136)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 137)" onmouseover="showTip(event, 'fs13', 137)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 138)" onmouseover="showTip(event, 'fs22', 138)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 139)" onmouseover="showTip(event, 'fs21', 139)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 140)" onmouseover="showTip(event, 'fs8', 140)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs44', 141)" onmouseover="showTip(event, 'fs44', 141)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 142)" onmouseover="showTip(event, 'fs21', 142)" class="id">amped</span> <span class="o">|&gt;</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs35', 143)" onmouseover="showTip(event, 'fs35', 143)" class="fn">lowPassCtor</span><span class="pn">(</span><span class="pn">)</span><span class="pn">)</span> <span class="n">8000.0</span>   <span class="c">// we would like to use lowPassCtor</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 144)" onmouseover="showTip(event, 'fs45', 144)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 145)" onmouseover="showTip(event, 'fs31', 145)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 146)" onmouseover="showTip(event, 'fs22', 146)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs44', 147)" onmouseover="showTip(event, 'fs44', 147)" class="id">softLimited</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 148)" onmouseover="showTip(event, 'fs25', 148)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs45', 149)" onmouseover="showTip(event, 'fs45', 149)" class="id">mixed</span> <span class="o">|&gt;</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs39', 150)" onmouseover="showTip(event, 'fs39', 150)" class="fn">fadeInCtor</span><span class="pn">(</span><span class="pn">)</span><span class="pn">)</span> <span class="n">0.1</span>           <span class="c">// we would like to use fadeInCtor</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 151)" onmouseover="showTip(event, 'fs26', 151)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 152)" onmouseover="showTip(event, 'fs7', 152)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 153)" onmouseover="showTip(event, 'fs25', 153)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs26', 154)" onmouseover="showTip(event, 'fs26', 154)" class="id">gained</span>
</code></pre>
<p>But this won't work anymore. We cannot just insert "lowPassCtor" in a pure computation. But why not - the compiler allows that? This true, but the ""blendedDistortion" function itself is pure: When it gets evaluated multiple times, it would always create a "new" lowPass by calling the lowPassCtor function, with lowPass's "mutable lastOut" field set to 0.0: It would never calculate anything useful.</p>
<!-- Solving this issue is basically easy, but: TODO: Usually, you don't deal with a single stateful block. Instead, you have a lot of them. And it's a burden to the user managing all these that: He needs to create these instance up front, remove them in case he doesn't need them anymore, bind these function pointers (=references) to identifiers that is again captured in a closure, so that he can finally use them in the actual code he want to write. Anyway, we do it for now: We change our blendedDistortion processing function to a factory function (analog to the lowPassCtor): -->
<p>This issue can be solved by creating a "low pass" instance up front, and capture that reference in a closure. Doing so, we have to change our blendedDistortion processing function to a factory function (analog to the lowPassCtor):</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs46', 155)" onmouseover="showTip(event, 'fs46', 155)" class="fn">blendedDistortionCtor</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>

    <span class="c">// create and hold references to stateful objects</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs47', 156)" onmouseover="showTip(event, 'fs47', 156)" class="fn">lowPassInstance</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs35', 157)" onmouseover="showTip(event, 'fs35', 157)" class="fn">lowPassCtor</span><span class="pn">(</span><span class="pn">)</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs48', 158)" onmouseover="showTip(event, 'fs48', 158)" class="fn">fadeInInstance</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs39', 159)" onmouseover="showTip(event, 'fs39', 159)" class="fn">fadeInCtor</span><span class="pn">(</span><span class="pn">)</span>

    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs13', 160)" onmouseover="showTip(event, 'fs13', 160)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 161)" onmouseover="showTip(event, 'fs3', 161)" class="id">input</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 162)" onmouseover="showTip(event, 'fs21', 162)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 163)" onmouseover="showTip(event, 'fs3', 163)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 164)" onmouseover="showTip(event, 'fs7', 164)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 165)" onmouseover="showTip(event, 'fs13', 165)" class="id">drive</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 166)" onmouseover="showTip(event, 'fs22', 166)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 167)" onmouseover="showTip(event, 'fs21', 167)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 168)" onmouseover="showTip(event, 'fs8', 168)" class="fn">limit</span> <span class="n">0.7</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs44', 169)" onmouseover="showTip(event, 'fs44', 169)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 170)" onmouseover="showTip(event, 'fs21', 170)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs47', 171)" onmouseover="showTip(event, 'fs47', 171)" class="fn">lowPassInstance</span> <span class="n">8000.0</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 172)" onmouseover="showTip(event, 'fs45', 172)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 173)" onmouseover="showTip(event, 'fs31', 173)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 174)" onmouseover="showTip(event, 'fs22', 174)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs44', 175)" onmouseover="showTip(event, 'fs44', 175)" class="id">softLimited</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 176)" onmouseover="showTip(event, 'fs25', 176)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs45', 177)" onmouseover="showTip(event, 'fs45', 177)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs48', 178)" onmouseover="showTip(event, 'fs48', 178)" class="fn">fadeInInstance</span> <span class="n">0.1</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 179)" onmouseover="showTip(event, 'fs26', 179)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 180)" onmouseover="showTip(event, 'fs7', 180)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 181)" onmouseover="showTip(event, 'fs25', 181)" class="id">fadedIn</span>
        <span onmouseout="hideTip(event, 'fs26', 182)" onmouseover="showTip(event, 'fs26', 182)" class="id">gained</span>
</code></pre>
<p>That works! But it's a burden for the user: Every time a stateful block is needed, it has to be declared before it can be used inside of the computation, and the instance has to be removed when it is not needed anymore. When authoring more complex effects or synthesizers, this can be a major pain point: The user's focus is modeling a DSP computation, and not instance management. Since instance management is something that has to be done, it draws away attention from the primary goal and interrupts the workflow of the programmer.</p>
<p>So what can be done to automate instance management?</p>
<p>Looking again at the block diagram [TODO], there is one important thing to notice: Blocks themselves are not explicitly instanciated and then referenced by an identifier in the computation; they just sit in the place where they are used; they are kind of "inlined", even if they are based on their own local state.</p>
<p>So it seems that in contrast to OOP, block diagrams work like this:</p>
<statement>A function with state is not identified by a reference, but by it's position inside of a computation.</statement>
<p>This is also the case when composing pure functions, and this is what we want to achieve:</p>
<p><strong>Finding a way of treating stateful functions as if they were pure functions!</strong></p>
<p>How can we do that?</p>
<p>We have to switch the way <code>references</code> are defined, from:</p>
<blockquote>
<p>A reference is made up of a unique address in a global address space.</p>
</blockquote>
<p>to:</p>
<blockquote>
<p>A reference is made up of
<em> a data structure which is implicitly defined by a computation,
</em> plus a local offset inside that computation.</p>
</blockquote>
<p>Reaching this goal means: The user does not have to deal with instance management, because the aspect of local state would simply result from the way a computation is built by the user.</p>
<h2>Writing Stateful Processing Functions (2)</h2>
<p>First, let's look again at the block diagram that defines a stateful function:</p>
<p><img src="./block_with_state.tif" alt="Block with state" /></p>
<p>Notice that the feedback of state is the key point: How can that be achieved? To find an answer, let's just ignore it for a moment. We assume that there will be something that can handle this issue for us. What remains is a function with "state in" and "state out" beside the actual in and out values:</p>
<p><img src="./block_with_state_no_feedback.tif" alt="block_with_state_no_feedback" /></p>
<p>Assuming that some mechsnism passes in previous state and records output state (that gets passed in as previous state at the next evaluation, and so on), we can rewrite the object oriented low pass filter code from (TODO: Chapter 4) by transforming it to a pure function:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// float -&gt; float -&gt; float -&gt; float * float</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs49', 183)" onmouseover="showTip(event, 'fs49', 183)" class="fn">lowPass</span> <span onmouseout="hideTip(event, 'fs37', 184)" onmouseover="showTip(event, 'fs37', 184)" class="id">timeConstant</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs3', 185)" onmouseover="showTip(event, 'fs3', 185)" class="id">input</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 186)" onmouseover="showTip(event, 'fs4', 186)" class="vt">float</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs50', 187)" onmouseover="showTip(event, 'fs50', 187)" class="id">lastOut</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs38', 188)" onmouseover="showTip(event, 'fs38', 188)" class="id">diff</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs50', 189)" onmouseover="showTip(event, 'fs50', 189)" class="id">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs3', 190)" onmouseover="showTip(event, 'fs3', 190)" class="id">input</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs51', 191)" onmouseover="showTip(event, 'fs51', 191)" class="id">out</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs50', 192)" onmouseover="showTip(event, 'fs50', 192)" class="id">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs38', 193)" onmouseover="showTip(event, 'fs38', 193)" class="id">diff</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs37', 194)" onmouseover="showTip(event, 'fs37', 194)" class="id">timeConstant</span>
        <span class="c">// the output state **is in this case** equals the output value</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs52', 195)" onmouseover="showTip(event, 'fs52', 195)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs51', 196)" onmouseover="showTip(event, 'fs51', 196)" class="id">out</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs52', 197)" onmouseover="showTip(event, 'fs52', 197)" class="id">newState</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs51', 198)" onmouseover="showTip(event, 'fs51', 198)" class="id">out</span><span class="pn">)</span>
</code></pre>
<p>What have we done:</p>
<ul>
<li>There is no mutable state anymore, since the previous state gets passed in as a function paratemer. Benefit: We don't need a "lowPassCtor" function anymore!</li>
<li><p>After application of the timeConstant parameter <em>and</em> the actual input value, the remaining function has the signarure: <code>float -&gt; float * float</code>: Previous state comes in, resulting in a tuple that "packs" output state and an actual output value together.</p></li>
</ul>
<hint>You have propably seen that we curried the most inner function "by hand". Instead, we could have written one single function like ```let lowPass timeConstant (input: float) lastOut = ...``` </hint>
<h3>Abstracting Instanciation</h3>
<p>Like stateless functions, we want to compose many of these stateful functions to build more high level computations. Since we not only want to compose blocks that work like a low pass filter (with float as state), we generalize the function, so that in the end, we are looking for a way to compose functions that look like this:</p>
<p><code>'state -&gt; 'state * float</code></p>
<p>Since <code>'state * float</code> tuple is a significant thing which we will need more often, let's transform it to a named record type:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs53', 199)" onmouseover="showTip(event, 'fs53', 199)" class="rt">BlockOutput</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="pn">{</span> <span onmouseout="hideTip(event, 'fs54', 200)" onmouseover="showTip(event, 'fs54', 200)" class="id">value</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs4', 201)" onmouseover="showTip(event, 'fs4', 201)" class="vt">float</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs55', 202)" onmouseover="showTip(event, 'fs55', 202)" class="id">state</span><span class="pn">:</span> <span class="ta">&#39;</span><span class="id">state</span> <span class="pn">}</span>
</code></pre>
<p>Then, the function signature looks like this:
<code>'state -&gt; BlockOutput&lt;'state&gt;</code></p>
<p>Let's name that function, too:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs56', 203)" onmouseover="showTip(event, 'fs56', 203)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs56', 204)" onmouseover="showTip(event, 'fs56', 204)" class="uc">Block</span> <span class="k">of</span> <span class="pn">(</span><span class="ta">&#39;</span><span class="id">state</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs53', 205)" onmouseover="showTip(event, 'fs53', 205)" class="rt">BlockOutput</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span><span class="pn">)</span>
</code></pre>
<hint>
The ```Block``` type is a so-called **single case discriminated union**. I suggest you read TODO to understand how to construct and deconstruct unions, but you can try to figure it out by looking at the modified low pass filter code.
<p>TODO: Mehr - wir kann man Funktionen packen und entpacken - run...</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs57', 206)" onmouseover="showTip(event, 'fs57', 206)" class="fn">runB</span> <span onmouseout="hideTip(event, 'fs58', 207)" onmouseover="showTip(event, 'fs58', 207)" class="id">block</span> <span class="o">=</span> <span class="k">let</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs56', 208)" onmouseover="showTip(event, 'fs56', 208)" class="uc">Block</span> <span onmouseout="hideTip(event, 'fs59', 209)" onmouseover="showTip(event, 'fs59', 209)" class="fn">b</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs58', 210)" onmouseover="showTip(event, 'fs58', 210)" class="id">block</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs59', 211)" onmouseover="showTip(event, 'fs59', 211)" class="fn">b</span>
</code></pre>
</hint>
<h4>Generalizing float</h4>
<p>Since we might have signal values not always of type float, we can easily generalize the float, so that our types look like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs60', 212)" onmouseover="showTip(event, 'fs60', 212)" class="rt">BlockOutput</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="pn">{</span> <span onmouseout="hideTip(event, 'fs61', 213)" onmouseover="showTip(event, 'fs61', 213)" class="id">value</span><span class="pn">:</span> <span class="ta">&#39;</span><span onmouseout="hideTip(event, 'fs61', 214)" onmouseover="showTip(event, 'fs61', 214)" class="id">value</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs55', 215)" onmouseover="showTip(event, 'fs55', 215)" class="id">state</span><span class="pn">:</span> <span class="ta">&#39;</span><span onmouseout="hideTip(event, 'fs55', 216)" onmouseover="showTip(event, 'fs55', 216)" class="id">state</span> <span class="pn">}</span>

<span class="k">type</span> <span onmouseout="hideTip(event, 'fs62', 217)" onmouseover="showTip(event, 'fs62', 217)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="ta">&#39;</span><span class="id">state</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs60', 218)" onmouseover="showTip(event, 'fs60', 218)" class="rt">BlockOutput</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span>
</code></pre>
<h4>Re-Writing lowPass and fadeIn</h4>
<p>Having these 2 types in mind, we can use the OOP code and refactor is to <code>Block</code> functions that have a <code>BlockOutput</code> by eliminating the mutable variables and passing them in/out of our functions:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// float -&gt; float -&gt; Block&lt;float&gt;</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs63', 219)" onmouseover="showTip(event, 'fs63', 219)" class="fn">lowPass</span> <span onmouseout="hideTip(event, 'fs37', 220)" onmouseover="showTip(event, 'fs37', 220)" class="id">timeConstant</span> <span onmouseout="hideTip(event, 'fs3', 221)" onmouseover="showTip(event, 'fs3', 221)" class="id">input</span> <span class="o">=</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs50', 222)" onmouseover="showTip(event, 'fs50', 222)" class="id">lastOut</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs38', 223)" onmouseover="showTip(event, 'fs38', 223)" class="id">diff</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs50', 224)" onmouseover="showTip(event, 'fs50', 224)" class="id">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs3', 225)" onmouseover="showTip(event, 'fs3', 225)" class="id">input</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs51', 226)" onmouseover="showTip(event, 'fs51', 226)" class="id">out</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs50', 227)" onmouseover="showTip(event, 'fs50', 227)" class="id">lastOut</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs38', 228)" onmouseover="showTip(event, 'fs38', 228)" class="id">diff</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs37', 229)" onmouseover="showTip(event, 'fs37', 229)" class="id">timeConstant</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs52', 230)" onmouseover="showTip(event, 'fs52', 230)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs51', 231)" onmouseover="showTip(event, 'fs51', 231)" class="id">out</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs51', 232)" onmouseover="showTip(event, 'fs51', 232)" class="id">out</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 233)" onmouseover="showTip(event, 'fs52', 233)" class="id">newState</span> <span class="pn">}</span>
</code></pre>
<p>Now we can eliminate the mutable variable for the "fadeIn" function, too:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs64', 234)" onmouseover="showTip(event, 'fs64', 234)" class="fn">fadeIn</span> <span onmouseout="hideTip(event, 'fs41', 235)" onmouseover="showTip(event, 'fs41', 235)" class="id">stepSize</span> <span onmouseout="hideTip(event, 'fs3', 236)" onmouseover="showTip(event, 'fs3', 236)" class="id">input</span> <span class="o">=</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs65', 237)" onmouseover="showTip(event, 'fs65', 237)" class="id">lastValue</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs42', 238)" onmouseover="showTip(event, 'fs42', 238)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 239)" onmouseover="showTip(event, 'fs3', 239)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs65', 240)" onmouseover="showTip(event, 'fs65', 240)" class="id">lastValue</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs52', 241)" onmouseover="showTip(event, 'fs52', 241)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 242)" onmouseover="showTip(event, 'fs43', 242)" class="fn">min</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs65', 243)" onmouseover="showTip(event, 'fs65', 243)" class="id">lastValue</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs41', 244)" onmouseover="showTip(event, 'fs41', 244)" class="id">stepSize</span><span class="pn">)</span> <span class="n">1.0</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs42', 245)" onmouseover="showTip(event, 'fs42', 245)" class="id">result</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 246)" onmouseover="showTip(event, 'fs52', 246)" class="id">newState</span> <span class="pn">}</span>
</code></pre>
<p>Now we need a way of composing those functions: The composition must handle the "recording" of the output state and feeding it into the next evaluation's input, and this must be done for every block in the computation. This sounds like we just moved the key issue (instance management) into the composition layer. This is true - and beneficial - because we can "outsource" a recurring aspect of our programming model so that the user doesn't have to handle it anymore in a concrete way.</p>
<h3>Pick up and Delivery</h3>
<p>So how can a composition function "record and feed back" work? Remember: We do not want to give a "name" or "address" to our blocks - their identity shall be solely based on their place inside the computation. The composition function itself shall consequently also be pure.</p>
<p>Let's call the overall strategy "Pick Up and Delivery", and it shall work like this:</p>
<ul>
<li>In a whole computation, all blocks are evaluated one after another.</li>
<li>The actual value of an evaluated block is passed in the rest of the computation.</li>
<li>
<p><strong>Pick Up:</strong></p>
<p>The output states of the blocks are aggregated by accumulation: The output state of a block and the output state of a following block are packed together (in a tuple). This "state pack" shall be passed to the next block evaluation, that's output is then packed again with the state of that block, and so on. So in the end, we have:</p>
<p>state, packed together with the next state, that is packed together with next state, that is packed...</p>
</li>
<li>The final state pack that is emitted from the whole computation (alongside with the final actual output value) is then used as input state for the next evaluation cycle ("Delivery").</li>
<li>
<p><strong>Delivery:</strong></p>
<p>That nested state pack is then unpacked piece by piece, evaluation by evaluation - like a FIFO buffer. In that way, the local state of a block from the last evaluation is addressed and passed into the corresponsing block of the current evaluation.</p>
</li>
</ul>
<!-- What we are looking for is a strategy on how to evaluate a computation that is made up of stateful functions. And there is an analogy that is easy to understand: Evaluating a whole computation means that the emitted state of the stateful functions has to be collected somehow. Our  -->
<p>Since this article is all about synthesizers - let's synthesize our composition function according to the recipe from above:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs66', 247)" onmouseover="showTip(event, 'fs66', 247)" class="fn">bind</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs67', 248)" onmouseover="showTip(event, 'fs67', 248)" class="fn">currentBlock</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs62', 249)" onmouseover="showTip(event, 'fs62', 249)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueA</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateA</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs68', 250)" onmouseover="showTip(event, 'fs68', 250)" class="fn">rest</span><span class="pn">:</span> <span class="ta">&#39;</span><span class="id">valueA</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs62', 251)" onmouseover="showTip(event, 'fs62', 251)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueB</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateB</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs62', 252)" onmouseover="showTip(event, 'fs62', 252)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueB</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateA</span> <span class="pn">*</span> <span class="ta">&#39;</span><span class="id">stateB</span><span class="pn">&gt;</span> <span class="o">=</span>
    
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs69', 253)" onmouseover="showTip(event, 'fs69', 253)" class="id">previousStatePack</span> <span class="k">-&gt;</span>

        <span class="c">// Deconstruct state pack:</span>
        <span class="c">// state is a tuple of (&#39;stateA * &#39;stateB)</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs70', 254)" onmouseover="showTip(event, 'fs70', 254)" class="id">previousStateOfCurrentBlock</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs71', 255)" onmouseover="showTip(event, 'fs71', 255)" class="id">previousStateOfNextBlock</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs69', 256)" onmouseover="showTip(event, 'fs69', 256)" class="id">previousStatePack</span>

        <span class="c">// The result of currentBlock is made up of an actual value and a state that</span>
        <span class="c">// has to be &quot;recorded&quot; by packing it together with the state of the</span>
        <span class="c">// next block.</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs72', 257)" onmouseover="showTip(event, 'fs72', 257)" class="id">currentBlockOutput</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs67', 258)" onmouseover="showTip(event, 'fs67', 258)" class="fn">currentBlock</span> <span onmouseout="hideTip(event, 'fs70', 259)" onmouseover="showTip(event, 'fs70', 259)" class="id">previousStateOfCurrentBlock</span>

        <span class="c">// Continue evaluating the computation:</span>
        <span class="c">// passing the actual output value of currentBlock to the rest of the computation</span>
        <span class="c">// gives us access to the next block in the computation:</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs73', 260)" onmouseover="showTip(event, 'fs73', 260)" class="fn">nextBlock</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs68', 261)" onmouseover="showTip(event, 'fs68', 261)" class="fn">rest</span> <span onmouseout="hideTip(event, 'fs72', 262)" onmouseover="showTip(event, 'fs72', 262)" class="id">currentBlockOutput</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs74', 263)" onmouseover="showTip(event, 'fs74', 263)" class="id">value</span>

        <span class="c">// Evaluate the next block and build up the result of this bind function</span>
        <span class="c">// as a block, so that it can be used as a bindable element itself -</span>
        <span class="c">// but this time with state of 2 blocks packed together.</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs75', 264)" onmouseover="showTip(event, 'fs75', 264)" class="id">nextBlockOutput</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs73', 265)" onmouseover="showTip(event, 'fs73', 265)" class="fn">nextBlock</span> <span onmouseout="hideTip(event, 'fs71', 266)" onmouseover="showTip(event, 'fs71', 266)" class="id">previousStateOfNextBlock</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs75', 267)" onmouseover="showTip(event, 'fs75', 267)" class="id">nextBlockOutput</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs76', 268)" onmouseover="showTip(event, 'fs76', 268)" class="id">value</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs72', 269)" onmouseover="showTip(event, 'fs72', 269)" class="id">currentBlockOutput</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs77', 270)" onmouseover="showTip(event, 'fs77', 270)" class="id">state</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs75', 271)" onmouseover="showTip(event, 'fs75', 271)" class="id">nextBlockOutput</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs78', 272)" onmouseover="showTip(event, 'fs78', 272)" class="id">state</span> <span class="pn">}</span>
</code></pre>
<p>// TODO: Aspekte erklären:
<em> Nimmt einen Block
</em> und Den Rest
<em> und wird selbst wieder ein Block, der wiederum mit bind composed werden kann.
</em> Bind fungiert also wie ein "Hook", der zwischen Berechnungen platziert wird und sich um den State-Aspekt kümmert.
* Bind selbst verhält sich (dadurch, dass es selbst wieder ein Block ist) selbst wie ein composable part of the computation.</p>
<p>The last 2 points are essential: bind enables us to "nest" functions and therefor nest their state, and bind builds up a data context when it is used inside of the "rest functions". This means: A nested "rest functions" has access to all given values of it's enclosing functions.</p>
<p>TODO: Bild mit geschachtelten Funktionen</p>
<h3>Using Blocks</h3>
<p>Since here, we have 2 important things in our hands:</p>
<ul>
<li>We know how stateful functions look like, and we call them "Block" functions.</li>
<li>We have a way of composing these block functions which is implemented in the "bind" function.</li>
</ul>
<p>Having this in mind, we can modify our use case example "blendedDistortion" in way that it fits with "Blocks and bind".</p>
<p>Here it is in the desired form:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// that would be nice, but doesn&#39;t work.</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs20', 273)" onmouseover="showTip(event, 'fs20', 273)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs13', 274)" onmouseover="showTip(event, 'fs13', 274)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 275)" onmouseover="showTip(event, 'fs3', 275)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 276)" onmouseover="showTip(event, 'fs21', 276)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 277)" onmouseover="showTip(event, 'fs3', 277)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 278)" onmouseover="showTip(event, 'fs7', 278)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 279)" onmouseover="showTip(event, 'fs13', 279)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 280)" onmouseover="showTip(event, 'fs22', 280)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 281)" onmouseover="showTip(event, 'fs21', 281)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 282)" onmouseover="showTip(event, 'fs8', 282)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs79', 283)" onmouseover="showTip(event, 'fs79', 283)" class="fn">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 284)" onmouseover="showTip(event, 'fs21', 284)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs63', 285)" onmouseover="showTip(event, 'fs63', 285)" class="fn">lowPass</span> <span class="n">0.2</span>      <span class="c">// we would like to use lowPass</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 286)" onmouseover="showTip(event, 'fs45', 286)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 287)" onmouseover="showTip(event, 'fs31', 287)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 288)" onmouseover="showTip(event, 'fs22', 288)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs79', 289)" onmouseover="showTip(event, 'fs79', 289)" class="fn">softLimited</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs80', 290)" onmouseover="showTip(event, 'fs80', 290)" class="fn">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs45', 291)" onmouseover="showTip(event, 'fs45', 291)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs64', 292)" onmouseover="showTip(event, 'fs64', 292)" class="fn">fadeIn</span> <span class="n">0.1</span>           <span class="c">// we would like to use fadeIn</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 293)" onmouseover="showTip(event, 'fs26', 293)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 294)" onmouseover="showTip(event, 'fs7', 294)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs80', 295)" onmouseover="showTip(event, 'fs80', 295)" class="fn">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs26', 296)" onmouseover="showTip(event, 'fs26', 296)" class="id">gained</span>
</code></pre>
<p>Here, we treat lowPass and fadeIn as a pure function - which is what we wanted - but which also doesn't work. We then used OOP that solved the issue, but forced us to create and manage references to instances.</p>
<p>Now that we have introduced Blocks and the "Pick Up and Delivery" strategy (implemented by the 'bind' combinator function), let's see how far we come.</p>
<p>We defined that bind takes a Block and the "rest of the computation". Since in a functional language, "rest of computation" is a expression, we defined it as as function of the form <code>float -&gt; Block&lt;'state&gt;</code>. TODO: Warum?</p>
<p>In order to be able to do so, we have to
<em> "break up" the code sample from above into pieces of "rest functions",
</em> in the desired form (<code>float -&gt; Block&lt;'state&gt;</code>),
<em> and do that every time a value from a Block is needed,
</em> and use 'bind' to compose the pieces.</p>
<p>Let's do it!</p>
<hint>
If you are already familiar with monads and/or F# computation expressions, you can skip this chapter. Otherwise, keep reading. A very good alternative source that explains monadic (and other ways of) composition can be found [here].
</hint>
<hint>
Our modified "blendedDistortion" sample is used to:
</hint>
<ul>
<li>explain how "bind" is finally used;</li>
<li>understand in which way it relates to stateless computations;</li>
<li>see how we can simplify the syntax by using F#'s computation expressions.</li>
</ul>
<p>Later (in chapter TODO), we will build up another, more comprehensible example with a focus on user's perspective, rather than on the aspects of composition itself.</p>
<h2>Rewrite blendedDistortion with "bind"</h2>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs81', 297)" onmouseover="showTip(event, 'fs81', 297)" class="fn">blendedDistortion1</span> <span onmouseout="hideTip(event, 'fs13', 298)" onmouseover="showTip(event, 'fs13', 298)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 299)" onmouseover="showTip(event, 'fs3', 299)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 300)" onmouseover="showTip(event, 'fs21', 300)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 301)" onmouseover="showTip(event, 'fs3', 301)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 302)" onmouseover="showTip(event, 'fs7', 302)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 303)" onmouseover="showTip(event, 'fs13', 303)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 304)" onmouseover="showTip(event, 'fs22', 304)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 305)" onmouseover="showTip(event, 'fs21', 305)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 306)" onmouseover="showTip(event, 'fs8', 306)" class="fn">limit</span> <span class="n">0.7</span>
    <span onmouseout="hideTip(event, 'fs66', 307)" onmouseover="showTip(event, 'fs66', 307)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs21', 308)" onmouseover="showTip(event, 'fs21', 308)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs63', 309)" onmouseover="showTip(event, 'fs63', 309)" class="fn">lowPass</span> <span class="n">0.2</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs44', 310)" onmouseover="showTip(event, 'fs44', 310)" class="id">softLimited</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 311)" onmouseover="showTip(event, 'fs45', 311)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 312)" onmouseover="showTip(event, 'fs31', 312)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 313)" onmouseover="showTip(event, 'fs22', 313)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs44', 314)" onmouseover="showTip(event, 'fs44', 314)" class="id">softLimited</span>
        <span onmouseout="hideTip(event, 'fs66', 315)" onmouseover="showTip(event, 'fs66', 315)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs45', 316)" onmouseover="showTip(event, 'fs45', 316)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs64', 317)" onmouseover="showTip(event, 'fs64', 317)" class="fn">fadeIn</span> <span class="n">0.1</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 318)" onmouseover="showTip(event, 'fs25', 318)" class="id">fadedIn</span> <span class="k">-&gt;</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 319)" onmouseover="showTip(event, 'fs26', 319)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 320)" onmouseover="showTip(event, 'fs7', 320)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 321)" onmouseover="showTip(event, 'fs25', 321)" class="id">fadedIn</span>
            <span onmouseout="hideTip(event, 'fs26', 322)" onmouseover="showTip(event, 'fs26', 322)" class="id">gained</span><span class="pn">)</span><span class="pn">)</span>
</code></pre>
<p>That doesn't look like the desired result (and it wouldn't compile - but let's keep that aside for a moment)! But with a little bit of tweaking indentation, we can make it look a little more readable:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs82', 323)" onmouseover="showTip(event, 'fs82', 323)" class="fn">blendedDistortion2</span> <span onmouseout="hideTip(event, 'fs13', 324)" onmouseover="showTip(event, 'fs13', 324)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 325)" onmouseover="showTip(event, 'fs3', 325)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 326)" onmouseover="showTip(event, 'fs21', 326)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 327)" onmouseover="showTip(event, 'fs3', 327)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 328)" onmouseover="showTip(event, 'fs7', 328)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 329)" onmouseover="showTip(event, 'fs13', 329)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 330)" onmouseover="showTip(event, 'fs22', 330)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 331)" onmouseover="showTip(event, 'fs21', 331)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 332)" onmouseover="showTip(event, 'fs8', 332)" class="fn">limit</span> <span class="n">0.7</span>
    <span onmouseout="hideTip(event, 'fs66', 333)" onmouseover="showTip(event, 'fs66', 333)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs21', 334)" onmouseover="showTip(event, 'fs21', 334)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs63', 335)" onmouseover="showTip(event, 'fs63', 335)" class="fn">lowPass</span> <span class="n">0.2</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs44', 336)" onmouseover="showTip(event, 'fs44', 336)" class="id">softLimited</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 337)" onmouseover="showTip(event, 'fs45', 337)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 338)" onmouseover="showTip(event, 'fs31', 338)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 339)" onmouseover="showTip(event, 'fs22', 339)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs44', 340)" onmouseover="showTip(event, 'fs44', 340)" class="id">softLimited</span>
    <span onmouseout="hideTip(event, 'fs66', 341)" onmouseover="showTip(event, 'fs66', 341)" class="fn">bind</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs45', 342)" onmouseover="showTip(event, 'fs45', 342)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs64', 343)" onmouseover="showTip(event, 'fs64', 343)" class="fn">fadeIn</span> <span class="n">0.1</span><span class="pn">)</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 344)" onmouseover="showTip(event, 'fs25', 344)" class="id">fadedIn</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 345)" onmouseover="showTip(event, 'fs26', 345)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 346)" onmouseover="showTip(event, 'fs7', 346)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 347)" onmouseover="showTip(event, 'fs25', 347)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs26', 348)" onmouseover="showTip(event, 'fs26', 348)" class="id">gained</span><span class="pn">)</span><span class="pn">)</span>
</code></pre>
<p>Better! Now compare this code with the desired code from above: Every time we use a lowPass or fadeIn, there's no let binding anymore, but a bind, that takes exactly the expression on the right side of the let binding. The second parameter of bind is then the "rest of the computation", coded as a lambda function, that has a parameter with the identifier name of the let binding. Hard to read - but look at this picture:</p>
<p>[// TODO: Bild so wie in der Vortragspräsi]</p>
<p>We can introduce a prefix style operator as an alias for bind:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="pn">(</span><span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs66', 349)" onmouseover="showTip(event, 'fs66', 349)" class="fn">bind</span>
</code></pre>
<p>...and remove the parenthesis:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs83', 350)" onmouseover="showTip(event, 'fs83', 350)" class="fn">blendedDistortion3</span> <span onmouseout="hideTip(event, 'fs13', 351)" onmouseover="showTip(event, 'fs13', 351)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 352)" onmouseover="showTip(event, 'fs3', 352)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 353)" onmouseover="showTip(event, 'fs21', 353)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 354)" onmouseover="showTip(event, 'fs3', 354)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 355)" onmouseover="showTip(event, 'fs7', 355)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 356)" onmouseover="showTip(event, 'fs13', 356)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 357)" onmouseover="showTip(event, 'fs22', 357)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 358)" onmouseover="showTip(event, 'fs21', 358)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 359)" onmouseover="showTip(event, 'fs8', 359)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs21', 360)" onmouseover="showTip(event, 'fs21', 360)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs63', 361)" onmouseover="showTip(event, 'fs63', 361)" class="fn">lowPass</span> <span class="n">0.2</span><span class="pn">)</span> <span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs44', 362)" onmouseover="showTip(event, 'fs44', 362)" class="id">softLimited</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 363)" onmouseover="showTip(event, 'fs45', 363)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 364)" onmouseover="showTip(event, 'fs31', 364)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 365)" onmouseover="showTip(event, 'fs22', 365)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs44', 366)" onmouseover="showTip(event, 'fs44', 366)" class="id">softLimited</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs45', 367)" onmouseover="showTip(event, 'fs45', 367)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs64', 368)" onmouseover="showTip(event, 'fs64', 368)" class="fn">fadeIn</span> <span class="n">0.1</span><span class="pn">)</span> <span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 369)" onmouseover="showTip(event, 'fs25', 369)" class="id">fadedIn</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 370)" onmouseover="showTip(event, 'fs26', 370)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 371)" onmouseover="showTip(event, 'fs7', 371)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 372)" onmouseover="showTip(event, 'fs25', 372)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs26', 373)" onmouseover="showTip(event, 'fs26', 373)" class="id">gained</span>
</code></pre>
<p>Now we are pretty close to the desired code, except that the identifiers of the lambdas are coming after the expression, but we will get rid of that, too, in a minute.</p>
<p>There is one thing to notice here: The code wouldn't compile. Remember that we defined bind in a way that it get's passed the "rest of the computation" as a function that evaluates to a Block? Look at the last lambda function: It evaluates to a float, not to a Block! But why? The answer is easy: It has no state, because the "mix" function is a stateless function, thus it evaluates to a pure float value and not to a Block. Solving this is easy, because we can turn a float value into a <code>fsharp Block&lt;unit&gt;</code> like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// &quot;Return&quot; function</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs84', 374)" onmouseover="showTip(event, 'fs84', 374)" class="fn">returnB</span> <span onmouseout="hideTip(event, 'fs85', 375)" onmouseover="showTip(event, 'fs85', 375)" class="id">x</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs86', 376)" onmouseover="showTip(event, 'fs86', 376)" class="fn">blockFunction</span> <span onmouseout="hideTip(event, 'fs87', 377)" onmouseover="showTip(event, 'fs87', 377)" class="id">unusedState</span> <span class="o">=</span> <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs85', 378)" onmouseover="showTip(event, 'fs85', 378)" class="id">x</span><span class="pn">;</span> <span class="id">state</span> <span class="o">=</span> <span class="pn">(</span><span class="pn">)</span> <span class="pn">}</span>
    <span onmouseout="hideTip(event, 'fs62', 379)" onmouseover="showTip(event, 'fs62', 379)" class="uc">Block</span> <span onmouseout="hideTip(event, 'fs86', 380)" onmouseover="showTip(event, 'fs86', 380)" class="fn">blockFunction</span>
</code></pre>
<p>The whole blendedDistortion function then looks like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs83', 381)" onmouseover="showTip(event, 'fs83', 381)" class="fn">blendedDistortion3</span> <span onmouseout="hideTip(event, 'fs13', 382)" onmouseover="showTip(event, 'fs13', 382)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 383)" onmouseover="showTip(event, 'fs3', 383)" class="id">input</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 384)" onmouseover="showTip(event, 'fs21', 384)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 385)" onmouseover="showTip(event, 'fs3', 385)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 386)" onmouseover="showTip(event, 'fs7', 386)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 387)" onmouseover="showTip(event, 'fs13', 387)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 388)" onmouseover="showTip(event, 'fs22', 388)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 389)" onmouseover="showTip(event, 'fs21', 389)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 390)" onmouseover="showTip(event, 'fs8', 390)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs21', 391)" onmouseover="showTip(event, 'fs21', 391)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs63', 392)" onmouseover="showTip(event, 'fs63', 392)" class="fn">lowPass</span> <span class="n">0.2</span><span class="pn">)</span> <span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs44', 393)" onmouseover="showTip(event, 'fs44', 393)" class="id">softLimited</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 394)" onmouseover="showTip(event, 'fs45', 394)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 395)" onmouseover="showTip(event, 'fs31', 395)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 396)" onmouseover="showTip(event, 'fs22', 396)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs44', 397)" onmouseover="showTip(event, 'fs44', 397)" class="id">softLimited</span>
    <span class="pn">(</span><span onmouseout="hideTip(event, 'fs45', 398)" onmouseover="showTip(event, 'fs45', 398)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs64', 399)" onmouseover="showTip(event, 'fs64', 399)" class="fn">fadeIn</span> <span class="n">0.1</span><span class="pn">)</span> <span class="o">&gt;</span><span class="pn">&gt;</span><span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs25', 400)" onmouseover="showTip(event, 'fs25', 400)" class="id">fadedIn</span> <span class="k">-&gt;</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 401)" onmouseover="showTip(event, 'fs26', 401)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 402)" onmouseover="showTip(event, 'fs7', 402)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 403)" onmouseover="showTip(event, 'fs25', 403)" class="id">fadedIn</span>
    <span onmouseout="hideTip(event, 'fs84', 404)" onmouseover="showTip(event, 'fs84', 404)" class="fn">returnB</span> <span onmouseout="hideTip(event, 'fs26', 405)" onmouseover="showTip(event, 'fs26', 405)" class="id">gained</span>
</code></pre>
<h3>Using F# language support for bind and return</h3>
<p>The syntax with our lambdas is close to the desired syntax, but we can get even closer. Luckily, what we did is so generic that F# (and a lot of other languages) has support for this kind of composition.</p>
<p>TODO: Ausformulieren; ggf. in den Anhang</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs88', 406)" onmouseover="showTip(event, 'fs88', 406)" class="rt">Patch</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs89', 407)" onmouseover="showTip(event, 'fs89', 407)" class="id">this</span><span class="pn">.</span><span class="fn">Bind</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs90', 408)" onmouseover="showTip(event, 'fs90', 408)" class="fn">block</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs91', 409)" onmouseover="showTip(event, 'fs91', 409)" class="fn">rest</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs66', 410)" onmouseover="showTip(event, 'fs66', 410)" class="fn">bind</span> <span onmouseout="hideTip(event, 'fs90', 411)" onmouseover="showTip(event, 'fs90', 411)" class="fn">block</span> <span onmouseout="hideTip(event, 'fs91', 412)" onmouseover="showTip(event, 'fs91', 412)" class="fn">rest</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs89', 413)" onmouseover="showTip(event, 'fs89', 413)" class="id">this</span><span class="pn">.</span><span class="fn">Return</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs85', 414)" onmouseover="showTip(event, 'fs85', 414)" class="id">x</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs84', 415)" onmouseover="showTip(event, 'fs84', 415)" class="fn">returnB</span> <span onmouseout="hideTip(event, 'fs85', 416)" onmouseover="showTip(event, 'fs85', 416)" class="id">x</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs92', 417)" onmouseover="showTip(event, 'fs92', 417)" class="id">patch</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs88', 418)" onmouseover="showTip(event, 'fs88', 418)" class="rt">Patch</span><span class="pn">(</span><span class="pn">)</span>
</code></pre>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs93', 419)" onmouseover="showTip(event, 'fs93', 419)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs13', 420)" onmouseover="showTip(event, 'fs13', 420)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 421)" onmouseover="showTip(event, 'fs3', 421)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs92', 422)" onmouseover="showTip(event, 'fs92', 422)" class="k">patch</span> <span class="pn">{</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 423)" onmouseover="showTip(event, 'fs21', 423)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 424)" onmouseover="showTip(event, 'fs3', 424)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 425)" onmouseover="showTip(event, 'fs7', 425)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 426)" onmouseover="showTip(event, 'fs13', 426)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 427)" onmouseover="showTip(event, 'fs22', 427)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 428)" onmouseover="showTip(event, 'fs21', 428)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 429)" onmouseover="showTip(event, 'fs8', 429)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs44', 430)" onmouseover="showTip(event, 'fs44', 430)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 431)" onmouseover="showTip(event, 'fs21', 431)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs63', 432)" onmouseover="showTip(event, 'fs63', 432)" class="fn">lowPass</span> <span class="n">0.2</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 433)" onmouseover="showTip(event, 'fs45', 433)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 434)" onmouseover="showTip(event, 'fs31', 434)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 435)" onmouseover="showTip(event, 'fs22', 435)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs44', 436)" onmouseover="showTip(event, 'fs44', 436)" class="id">softLimited</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs25', 437)" onmouseover="showTip(event, 'fs25', 437)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs45', 438)" onmouseover="showTip(event, 'fs45', 438)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs64', 439)" onmouseover="showTip(event, 'fs64', 439)" class="fn">fadeIn</span> <span class="n">0.1</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 440)" onmouseover="showTip(event, 'fs26', 440)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 441)" onmouseover="showTip(event, 'fs7', 441)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 442)" onmouseover="showTip(event, 'fs25', 442)" class="id">fadedIn</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs26', 443)" onmouseover="showTip(event, 'fs26', 443)" class="id">gained</span>
<span class="pn">}</span>
</code></pre>
<p>This looks really close to what we wanted to achieve. We only have to wrap our code in the "patch" computation, and use let! instead of let every time we deal with <code>Blocks</code> instead of pure functions.</p>
<p>TODO: looking at the signature (tuples...)
Initial values
Inline composition
SinOsc
Modulation</p>
<h2>Evaluating Stateful Functions</h2>
<p>In the previous chapter, we learned that we can compose stateful <code>Block</code> functions easily by using the <code>patch</code> computation expression and <code>let!</code> instead of <code>let</code> when we want to bind the output value of a <code>Block</code> function to an identifier and use it in the rest of our computation.</p>
<p>But at the end, we are not interested in state - we need the pure output values of our computation to send them to the soundcard's buffer. For us, it will be enough just having these values available as sequence.</p>
<h3>The Signature of State</h3>
<p>Having a look at the <code>blendedDistortion</code> function again, there is an interesting aspect about the signature of it's state:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// float -&gt; float -&gt; Block&lt;float, float * (float * unit)&gt;</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs94', 444)" onmouseover="showTip(event, 'fs94', 444)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs95', 445)" onmouseover="showTip(event, 'fs95', 445)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs96', 446)" onmouseover="showTip(event, 'fs96', 446)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs92', 447)" onmouseover="showTip(event, 'fs92', 447)" class="id">patch</span> <span class="pn">{</span> <span class="c">(*...*)</span> <span class="pn">}</span>
</code></pre>
<p>The first 2 floats are drive and input. After applying these, we get a Block that deals with float signal values. It's state signature is then <code>float * (float * unit)</code>.</p>
<p>Where does this come from?</p>
<p>This is the nested tuple that is completely infered from the structure of the <code>blendedDistortion</code> computation expression:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs93', 448)" onmouseover="showTip(event, 'fs93', 448)" class="fn">blendedDistortion</span> <span onmouseout="hideTip(event, 'fs13', 449)" onmouseover="showTip(event, 'fs13', 449)" class="id">drive</span> <span onmouseout="hideTip(event, 'fs3', 450)" onmouseover="showTip(event, 'fs3', 450)" class="id">input</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs92', 451)" onmouseover="showTip(event, 'fs92', 451)" class="k">patch</span> <span class="pn">{</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 452)" onmouseover="showTip(event, 'fs21', 452)" class="id">amped</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 453)" onmouseover="showTip(event, 'fs3', 453)" class="id">input</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs7', 454)" onmouseover="showTip(event, 'fs7', 454)" class="fn">amp</span> <span onmouseout="hideTip(event, 'fs13', 455)" onmouseover="showTip(event, 'fs13', 455)" class="id">drive</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 456)" onmouseover="showTip(event, 'fs22', 456)" class="id">hardLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 457)" onmouseover="showTip(event, 'fs21', 457)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs8', 458)" onmouseover="showTip(event, 'fs8', 458)" class="fn">limit</span> <span class="n">0.7</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs44', 459)" onmouseover="showTip(event, 'fs44', 459)" class="id">softLimited</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 460)" onmouseover="showTip(event, 'fs21', 460)" class="id">amped</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs63', 461)" onmouseover="showTip(event, 'fs63', 461)" class="fn">lowPass</span> <span class="n">0.2</span>       <span class="c">// lowPass has float as state</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 462)" onmouseover="showTip(event, 'fs45', 462)" class="id">mixed</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs31', 463)" onmouseover="showTip(event, 'fs31', 463)" class="fn">mix</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs22', 464)" onmouseover="showTip(event, 'fs22', 464)" class="id">hardLimited</span> <span onmouseout="hideTip(event, 'fs44', 465)" onmouseover="showTip(event, 'fs44', 465)" class="id">softLimited</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs25', 466)" onmouseover="showTip(event, 'fs25', 466)" class="id">fadedIn</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs45', 467)" onmouseover="showTip(event, 'fs45', 467)" class="id">mixed</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs64', 468)" onmouseover="showTip(event, 'fs64', 468)" class="fn">fadeIn</span> <span class="n">0.1</span>            <span class="c">// fadeIn has float as state</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs26', 469)" onmouseover="showTip(event, 'fs26', 469)" class="id">gained</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 470)" onmouseover="showTip(event, 'fs7', 470)" class="fn">amp</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs25', 471)" onmouseover="showTip(event, 'fs25', 471)" class="id">fadedIn</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs26', 472)" onmouseover="showTip(event, 'fs26', 472)" class="id">gained</span>                                 <span class="c">// return (which is returnB) has unit as state</span>
</code></pre>
<p>So the F# compiler understands how the state of the whole computation has to look like, just by "looking" at how the computation is defined. There is no explicit type annotation needed that would be given by the user. It is all infered for the user by the F# compiler.</p>
<p>But our goal was to evaluate the computation for a given set of input values. To achieve that, we have to evaluate the <code>Block</code> function that we get from blendedDistortion. So let's have a look at the <code>Block</code> type again:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs62', 473)" onmouseover="showTip(event, 'fs62', 473)" class="id">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="id">&#39;</span><span class="id">state</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs60', 474)" onmouseover="showTip(event, 'fs60', 474)" class="id">BlockOutput</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="id">&#39;</span><span class="id">state</span><span class="pn">&gt;</span>
</code></pre>
<p>A <code>Block</code> needs (of course) state - the previous state - passed in to be able to evaluate it's next state and value. At the beginning of an evaluation cycle, what's the previous state then? There is none; so we need an initial state in form of <code>float * (float * unit)</code>.</p>
<pre class="fssnip highlighted"><code lang="fsharp">    <span class="c">// we have to create some initial state to kick off the computation.</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs97', 475)" onmouseover="showTip(event, 'fs97', 475)" class="id">initialState</span> <span class="o">=</span> <span class="n">0.0</span><span class="pn">,</span> <span class="pn">(</span><span class="n">0.0</span><span class="pn">,</span> <span class="pn">(</span><span class="pn">)</span><span class="pn">)</span>
    
    <span class="c">// for simplification, we pass in constant drive and input values to blendedDistortion.</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs98', 476)" onmouseover="showTip(event, 'fs98', 476)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs93', 477)" onmouseover="showTip(event, 'fs93', 477)" class="fn">blendedDistortion</span> <span class="n">1.5</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs97', 478)" onmouseover="showTip(event, 'fs97', 478)" class="id">initialState</span>
</code></pre>
<p>The fact that we have to write initial state for a computation seems kind of annoying. Now imagine you are in a real world scenario where you reuse block in block, building more and more high level blocks. And another thing: You might not even know what is an appropriate initial value for blocks you didn't write. So providing initial values might be your concern, but could also be the concern of another author. Thus, we need a mechanism that enables us to:</p>
<ul>
<li>omit intial state and</li>
<li>define it either on block-declaration side or</li>
<li>let it be defined inside of a block itself.</li>
</ul>
<h3>Optional Initial State</h3>
<p>We can achieve this by making state optional. In that case, the block author can decide if initial state values are a curried part of his block function, or if they shall be handled completely inside the block function so that they are hard-coded and not parametrizable.</p>
<p>This means we have to change the signature of our <code>Block</code> type:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs62', 479)" onmouseover="showTip(event, 'fs62', 479)" class="id">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">state</span><span class="pn">&gt;</span> <span class="o">=</span> <span class="id">&#39;</span><span class="id">state</span> <span onmouseout="hideTip(event, 'fs99', 480)" onmouseover="showTip(event, 'fs99', 480)" class="id">option</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs60', 481)" onmouseover="showTip(event, 'fs60', 481)" class="id">BlockOutput</span><span class="pn">&lt;</span><span class="id">&#39;</span><span class="id">value</span><span class="pn">,</span> <span class="id">&#39;</span><span class="id">state</span><span class="pn">&gt;</span>
</code></pre>
<p>Instead of a <code>'state</code> parameter, a block expects an optional <code>'state</code> parameter.</p>
<p>Now, our <code>bind</code> function has to be adapter. Since <code>bind</code> is just a kind of relais between functions that has to unpack and forward a previousely packed state tuple, the modification is quite local and easy to understand:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs66', 482)" onmouseover="showTip(event, 'fs66', 482)" class="fn">bind</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs67', 483)" onmouseover="showTip(event, 'fs67', 483)" class="fn">currentBlock</span><span class="pn">:</span> <span onmouseout="hideTip(event, 'fs62', 484)" onmouseover="showTip(event, 'fs62', 484)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueA</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateA</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">(</span><span onmouseout="hideTip(event, 'fs68', 485)" onmouseover="showTip(event, 'fs68', 485)" class="fn">rest</span><span class="pn">:</span> <span class="ta">&#39;</span><span class="id">valueA</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs62', 486)" onmouseover="showTip(event, 'fs62', 486)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueB</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateB</span><span class="pn">&gt;</span><span class="pn">)</span>
        <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs62', 487)" onmouseover="showTip(event, 'fs62', 487)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">valueB</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">stateA</span> <span class="pn">*</span> <span class="ta">&#39;</span><span class="id">stateB</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs69', 488)" onmouseover="showTip(event, 'fs69', 488)" class="id">previousStatePack</span> <span class="k">-&gt;</span>

        <span class="c">// Deconstruct state pack:</span>
        <span class="c">// state is a tuple of: (&#39;stateA * &#39;stateB) option</span>
        <span class="c">// that gets transformed to: &#39;stateA option * &#39;stateB option</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs100', 489)" onmouseover="showTip(event, 'fs100', 489)" class="id">previousStateOfCurrentBlock</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs101', 490)" onmouseover="showTip(event, 'fs101', 490)" class="id">previousStateOfNextBlock</span> <span class="o">=</span>
            <span class="k">match</span> <span onmouseout="hideTip(event, 'fs69', 491)" onmouseover="showTip(event, 'fs69', 491)" class="id">previousStatePack</span> <span class="k">with</span>
            <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs102', 492)" onmouseover="showTip(event, 'fs102', 492)" class="id">None</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs102', 493)" onmouseover="showTip(event, 'fs102', 493)" class="id">None</span><span class="pn">,</span><span onmouseout="hideTip(event, 'fs102', 494)" onmouseover="showTip(event, 'fs102', 494)" class="id">None</span>
            <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs103', 495)" onmouseover="showTip(event, 'fs103', 495)" class="id">Some</span> <span class="pn">(</span><span class="id">stateA</span><span class="pn">,</span><span class="id">stateB</span><span class="pn">)</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs103', 496)" onmouseover="showTip(event, 'fs103', 496)" class="id">Some</span> <span class="id">stateA</span><span class="pn">,</span> <span onmouseout="hideTip(event, 'fs103', 497)" onmouseover="showTip(event, 'fs103', 497)" class="id">Some</span> <span class="id">stateB</span>

        <span class="c">// no modifications from here:</span>
        <span class="c">// previousStateOfCurrentBlock and previousStateOfNextBlock are now</span>
        <span class="c">// both optional, but block who use it can deal with that.</span>
</code></pre>
<p>They key point here is that an incoming tuple of <code>('stateA * 'stateB) option</code> gets transformed to a tuple of <code>'stateA option * 'stateB option</code>. The two tuple elements can then be passed to thir corresponding <code>currentBlock</code> and <code>nextBlock</code> inside bind.</p>
<p>The only thing that is missing is the adaption of the block functions themselves, namely "lowPass" and "fadeIn":</p>
<p>Since we assume that there is only 1 meaningful initial value for lowPass, we always want to default it to 0.0:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs104', 498)" onmouseover="showTip(event, 'fs104', 498)" class="fn">lowPass</span> <span onmouseout="hideTip(event, 'fs37', 499)" onmouseover="showTip(event, 'fs37', 499)" class="id">timeConstant</span> <span onmouseout="hideTip(event, 'fs3', 500)" onmouseover="showTip(event, 'fs3', 500)" class="id">input</span> <span class="o">=</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs105', 501)" onmouseover="showTip(event, 'fs105', 501)" class="id">lastOut</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs106', 502)" onmouseover="showTip(event, 'fs106', 502)" class="id">state</span> <span class="o">=</span> <span class="k">match</span> <span onmouseout="hideTip(event, 'fs105', 503)" onmouseover="showTip(event, 'fs105', 503)" class="id">lastOut</span> <span class="k">with</span> 
                    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs102', 504)" onmouseover="showTip(event, 'fs102', 504)" class="uc">None</span> <span class="k">-&gt;</span> <span class="n">0.0</span>      <span class="c">// initial value hard coded to 0.0</span>
                    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs103', 505)" onmouseover="showTip(event, 'fs103', 505)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs107', 506)" onmouseover="showTip(event, 'fs107', 506)" class="id">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs107', 507)" onmouseover="showTip(event, 'fs107', 507)" class="id">v</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs38', 508)" onmouseover="showTip(event, 'fs38', 508)" class="id">diff</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs106', 509)" onmouseover="showTip(event, 'fs106', 509)" class="id">state</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs3', 510)" onmouseover="showTip(event, 'fs3', 510)" class="id">input</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs51', 511)" onmouseover="showTip(event, 'fs51', 511)" class="id">out</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs106', 512)" onmouseover="showTip(event, 'fs106', 512)" class="id">state</span> <span class="o">-</span> <span onmouseout="hideTip(event, 'fs38', 513)" onmouseover="showTip(event, 'fs38', 513)" class="id">diff</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs37', 514)" onmouseover="showTip(event, 'fs37', 514)" class="id">timeConstant</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs52', 515)" onmouseover="showTip(event, 'fs52', 515)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs51', 516)" onmouseover="showTip(event, 'fs51', 516)" class="id">out</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs51', 517)" onmouseover="showTip(event, 'fs51', 517)" class="id">out</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs106', 518)" onmouseover="showTip(event, 'fs106', 518)" class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 519)" onmouseover="showTip(event, 'fs52', 519)" class="id">newState</span> <span class="pn">}</span>
</code></pre>
<p>For our fadeIn, we want the user to specify an initial value, since it might be that he doesn't want to fade from silence, but from half loudness:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs108', 520)" onmouseover="showTip(event, 'fs108', 520)" class="fn">fadeIn</span> <span onmouseout="hideTip(event, 'fs41', 521)" onmouseover="showTip(event, 'fs41', 521)" class="id">stepSize</span> <span onmouseout="hideTip(event, 'fs109', 522)" onmouseover="showTip(event, 'fs109', 522)" class="id">initial</span> <span onmouseout="hideTip(event, 'fs3', 523)" onmouseover="showTip(event, 'fs3', 523)" class="id">input</span> <span class="o">=</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs110', 524)" onmouseover="showTip(event, 'fs110', 524)" class="id">lastValue</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs106', 525)" onmouseover="showTip(event, 'fs106', 525)" class="id">state</span> <span class="o">=</span> <span class="k">match</span> <span onmouseout="hideTip(event, 'fs110', 526)" onmouseover="showTip(event, 'fs110', 526)" class="id">lastValue</span> <span class="k">with</span> 
                    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs102', 527)" onmouseover="showTip(event, 'fs102', 527)" class="uc">None</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs109', 528)" onmouseover="showTip(event, 'fs109', 528)" class="id">initial</span>      <span class="c">// initial value can be specified</span>
                    <span class="pn">|</span> <span onmouseout="hideTip(event, 'fs103', 529)" onmouseover="showTip(event, 'fs103', 529)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs107', 530)" onmouseover="showTip(event, 'fs107', 530)" class="id">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs107', 531)" onmouseover="showTip(event, 'fs107', 531)" class="id">v</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs42', 532)" onmouseover="showTip(event, 'fs42', 532)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 533)" onmouseover="showTip(event, 'fs3', 533)" class="id">input</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs106', 534)" onmouseover="showTip(event, 'fs106', 534)" class="id">state</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs52', 535)" onmouseover="showTip(event, 'fs52', 535)" class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 536)" onmouseover="showTip(event, 'fs43', 536)" class="fn">min</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs106', 537)" onmouseover="showTip(event, 'fs106', 537)" class="id">state</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'fs41', 538)" onmouseover="showTip(event, 'fs41', 538)" class="id">stepSize</span><span class="pn">)</span> <span class="n">1.0</span>
        <span class="pn">{</span> <span class="id">value</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs42', 539)" onmouseover="showTip(event, 'fs42', 539)" class="id">result</span><span class="pn">;</span> <span onmouseout="hideTip(event, 'fs106', 540)" onmouseover="showTip(event, 'fs106', 540)" class="id">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 541)" onmouseover="showTip(event, 'fs52', 541)" class="id">newState</span> <span class="pn">}</span>
</code></pre>
<p>Now we have reached our goal: We can pass initial values in place where they are needed and omit them when the author wants to specify them on his own.</p>
<p>So finally, we can just pass in <code>None</code> as initial state, so that code looks like this:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// for simplification, we pass in constant drive and input values to blendedDistortion.</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs111', 542)" onmouseover="showTip(event, 'fs111', 542)" class="id">result</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs93', 543)" onmouseover="showTip(event, 'fs93', 543)" class="fn">blendedDistortion</span> <span class="n">1.5</span> <span class="n">0.5</span> <span onmouseout="hideTip(event, 'fs102', 544)" onmouseover="showTip(event, 'fs102', 544)" class="uc">None</span>
</code></pre>
<h3>Sequential Evaluation</h3>
<p>In the code above, we evaluates a block 1 time. This gives one <code>BlockResult</code> value, that contains the actual value and the accumulated state of that evaluation. Since we are not interested in a single value, but in a sequence of values for producing sound, we need to repeat the pattern from above.</p>
<p>Assuming we have a sequence that produces random values (it's actually a list in F#, but it doesn't necessarily have to be a list; a sequence of values would be suficcient):</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs112', 545)" onmouseover="showTip(event, 'fs112', 545)" class="id">inputValues</span> <span class="o">=</span> <span class="pn">[</span> <span class="n">0.0</span><span class="pn">;</span> <span class="n">0.2</span><span class="pn">;</span> <span class="n">0.4</span><span class="pn">;</span> <span class="n">0.6</span><span class="pn">;</span> <span class="n">0.8</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">1.0</span><span class="pn">;</span> <span class="n">0.8</span><span class="pn">;</span> <span class="n">0.6</span><span class="pn">;</span> <span class="n">0.4</span><span class="pn">;</span> <span class="n">0.2</span><span class="pn">;</span> <span class="n">0.0</span> <span class="pn">]</span>
</code></pre>
<p><img src="./inputValues.png" alt="Input Values" /></p>
<p>Now we want to apply out blendedDistortion function to the inputValues sequence.</p>
<hint>
Note that a `seq` in F# corresponds to `IEnumerable` in .NET. This means that by just defining a sequence, no data is stored in memory until the sequence is evaluated (e.g. by iterating over it). A sequence can be infinite and can be viewed as a stream of values.
</hint>
<p>Now we need a mechanism for mapping over a sequence of input values to a sequence of output values. Before we write code, keep one thing in mind: At the end, we have to provide a callback to an audio backend. This callback is called multiple times. The purpose of the callback is to take an input sequence (in case of an effect) and produce an output sequence of values. Since the callback is called multiple times, it has to store it's state somewhere. Since the callback resides at the boundary of our functional system and the I/O world, we will store the latest state in a mutable variable that is captured by a closure. Have a look:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// (&#39;vIn -&gt; Block&lt;&#39;vOut,&#39;s&gt;) -&gt; (seq&lt;&#39;vIn&gt; -&gt; seq&lt;BlockOutput&lt;&#39;vOut, &#39;s&gt;&gt;)</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs113', 546)" onmouseover="showTip(event, 'fs113', 546)" class="fn">createEvaluatorWithStateAndValues</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs114', 547)" onmouseover="showTip(event, 'fs114', 547)" class="fn">blockWithInput</span><span class="pn">:</span> <span class="ta">&#39;</span><span class="id">vIn</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs62', 548)" onmouseover="showTip(event, 'fs62', 548)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">vOut</span><span class="pn">,</span><span class="ta">&#39;</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, 'fs115', 549)" onmouseover="showTip(event, 'fs115', 549)" class="mv">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs102', 550)" onmouseover="showTip(event, 'fs102', 550)" class="uc">None</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs116', 551)" onmouseover="showTip(event, 'fs116', 551)" class="id">inputValues</span> <span class="k">-&gt;</span>
        <span onmouseout="hideTip(event, 'fs117', 552)" onmouseover="showTip(event, 'fs117', 552)" class="k">seq</span> <span class="pn">{</span>
            <span class="k">for</span> <span onmouseout="hideTip(event, 'fs118', 553)" onmouseover="showTip(event, 'fs118', 553)" class="id">i</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs116', 554)" onmouseover="showTip(event, 'fs116', 554)" class="id">inputValues</span> <span class="k">-&gt;</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, 'fs119', 555)" onmouseover="showTip(event, 'fs119', 555)" class="fn">block</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs114', 556)" onmouseover="showTip(event, 'fs114', 556)" class="fn">blockWithInput</span> <span onmouseout="hideTip(event, 'fs118', 557)" onmouseover="showTip(event, 'fs118', 557)" class="id">i</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, 'fs120', 558)" onmouseover="showTip(event, 'fs120', 558)" class="id">result</span> <span class="o">=</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs57', 559)" onmouseover="showTip(event, 'fs57', 559)" class="fn">runB</span> <span onmouseout="hideTip(event, 'fs119', 560)" onmouseover="showTip(event, 'fs119', 560)" class="fn">block</span><span class="pn">)</span> <span onmouseout="hideTip(event, 'fs115', 561)" onmouseover="showTip(event, 'fs115', 561)" class="mv">state</span>
                <span onmouseout="hideTip(event, 'fs115', 562)" onmouseover="showTip(event, 'fs115', 562)" class="mv">state</span> <span class="k">&lt;-</span> <span onmouseout="hideTip(event, 'fs103', 563)" onmouseover="showTip(event, 'fs103', 563)" class="uc">Some</span> <span onmouseout="hideTip(event, 'fs120', 564)" onmouseover="showTip(event, 'fs120', 564)" class="id">result</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs121', 565)" onmouseover="showTip(event, 'fs121', 565)" class="id">state</span>
                <span onmouseout="hideTip(event, 'fs120', 566)" onmouseover="showTip(event, 'fs120', 566)" class="id">result</span>
        <span class="pn">}</span>
</code></pre>
<p>The <code>createEvaluatorWithStateAndValues</code> function takes itself a function. A single input value can be passed to that function, that evaluates to a block. That block can then be evaluated itself. It produces state that is assigned to the variable and the value that is yielded (together with the state) to our output sequence. This whole mechanism is wrapped in a function that takes an input array. This is the callback that could finally be passed to an audio backend. It can be evaluated multiple times, receiving the input buffer from the soundcard, maps it's values over with the given block function and outputs a sequence of values that is taken by the audio backend.</p>
<hint>
In the following chapter TODO, 
</hint>
<p>Using this function</p>
<p>There is also a version that emits not values and state, but only values:</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// (&#39;vIn -&gt; Block&lt;&#39;vOut,&#39;s&gt;) -&gt; (seq&lt;&#39;vIn&gt; -&gt; seq&lt;&#39;vOut&gt;)</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs122', 567)" onmouseover="showTip(event, 'fs122', 567)" class="fn">createEvaluatorWithValues</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs114', 568)" onmouseover="showTip(event, 'fs114', 568)" class="fn">blockWithInput</span><span class="pn">:</span> <span class="ta">&#39;</span><span class="id">vIn</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs62', 569)" onmouseover="showTip(event, 'fs62', 569)" class="rt">Block</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">vOut</span><span class="pn">,</span><span class="ta">&#39;</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs123', 570)" onmouseover="showTip(event, 'fs123', 570)" class="fn">stateAndValueEvaluator</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs113', 571)" onmouseover="showTip(event, 'fs113', 571)" class="fn">createEvaluatorWithStateAndValues</span> <span onmouseout="hideTip(event, 'fs114', 572)" onmouseover="showTip(event, 'fs114', 572)" class="fn">blockWithInput</span>
    <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs116', 573)" onmouseover="showTip(event, 'fs116', 573)" class="id">inputValues</span> <span class="k">-&gt;</span>
        <span onmouseout="hideTip(event, 'fs123', 574)" onmouseover="showTip(event, 'fs123', 574)" class="fn">stateAndValueEvaluator</span> <span onmouseout="hideTip(event, 'fs116', 575)" onmouseover="showTip(event, 'fs116', 575)" class="id">inputValues</span>
        <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 576)" onmouseover="showTip(event, 'fs10', 576)" class="m">Seq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs11', 577)" onmouseover="showTip(event, 'fs11', 577)" class="id">map</span> <span class="pn">(</span><span class="k">fun</span> <span onmouseout="hideTip(event, 'fs124', 578)" onmouseover="showTip(event, 'fs124', 578)" class="id">stateAndValue</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs124', 579)" onmouseover="showTip(event, 'fs124', 579)" class="id">stateAndValue</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs54', 580)" onmouseover="showTip(event, 'fs54', 580)" class="id">value</span><span class="pn">)</span>
</code></pre>
<p>The <code>createEvaluatorWithValues</code> function simply maps the <code>BlockOutput</code> values to just a sequence of pure values.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs125', 581)" onmouseover="showTip(event, 'fs125', 581)" class="fn">evaluate</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs93', 582)" onmouseover="showTip(event, 'fs93', 582)" class="fn">blendedDistortion</span> <span class="n">1.5</span> <span class="o">|&gt;</span> <span class="id">createEvaluator</span>

<span class="c">// cycle 1</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs126', 583)" onmouseover="showTip(event, 'fs126', 583)" class="id">outputValues1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs125', 584)" onmouseover="showTip(event, 'fs125', 584)" class="fn">evaluate</span> <span onmouseout="hideTip(event, 'fs112', 585)" onmouseover="showTip(event, 'fs112', 585)" class="id">inputValues</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs10', 586)" onmouseover="showTip(event, 'fs10', 586)" class="m">Seq</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs127', 587)" onmouseover="showTip(event, 'fs127', 587)" class="id">toList</span>

<span class="c">// // ...</span>
<span class="c">// // cycle 2</span>
<span class="c">// let outputValues2 = evaluate newInputValues |&gt; Seq.toList</span>
<span class="c">// // ...</span>
<span class="c">// // cycle 3</span>
<span class="c">// let outputValues3 = evaluate evenNewerInputValues |&gt; Seq.toList</span>
<span class="c">// // ...</span>
</code></pre>
<h1>A Comprehensible Example</h1>

        <div class="tip" id="fs1">val amp : amount:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs2">val amount : float</div>
<div class="tip" id="fs3">val input : float</div>
<div class="tip" id="fs4">Multiple items<br />val float : value:&#39;T -&gt; float (requires member op_Explicit)<br /><br />--------------------<br />type float = System.Double<br /><br />--------------------<br />type float&lt;&#39;Measure&gt; = float</div>
<div class="tip" id="fs5">val amp : amount:int -&gt; float</div>
<div class="tip" id="fs6">val amount : int</div>
<div class="tip" id="fs7">val amp : (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs8">val limit : threshold:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs9">val threshold : float</div>
<div class="tip" id="fs10">module Seq<br /><br />from Microsoft.FSharp.Collections</div>
<div class="tip" id="fs11">val map : mapping:(&#39;T -&gt; &#39;U) -&gt; source:seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;U&gt;</div>
<div class="tip" id="fs12">val distort : drive:float -&gt; i:float -&gt; float</div>
<div class="tip" id="fs13">val drive : float</div>
<div class="tip" id="fs14">val i : float</div>
<div class="tip" id="fs15">val amplified : float</div>
<div class="tip" id="fs16">val limited : float</div>
<div class="tip" id="fs17">val distort1 : drive:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs18">val distort2 : drive:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs19">val distort3 : drive:float -&gt; (float -&gt; float)</div>
<div class="tip" id="fs20">val blendedDistortion : drive:float -&gt; input:float -&gt; float</div>
<div class="tip" id="fs21">val amped : float</div>
<div class="tip" id="fs22">val hardLimited : float</div>
<div class="tip" id="fs23">val softLimited : obj</div>
<div class="tip" id="fs24">val mixed : obj</div>
<div class="tip" id="fs25">val fadedIn : float</div>
<div class="tip" id="fs26">val gained : float</div>
<div class="tip" id="fs27">val lowPass : frq:&#39;a -&gt; input:float -&gt; float</div>
<div class="tip" id="fs28">val frq : &#39;a</div>
<div class="tip" id="fs29">val fadeIn : stepSize:&#39;a -&gt; input:float -&gt; float</div>
<div class="tip" id="fs30">val stepSize : &#39;a</div>
<div class="tip" id="fs31">val mix : abRatio:float -&gt; a:float -&gt; b:float -&gt; float</div>
<div class="tip" id="fs32">val abRatio : float</div>
<div class="tip" id="fs33">val a : float</div>
<div class="tip" id="fs34">val b : float</div>
<div class="tip" id="fs35">val lowPassCtor : unit -&gt; (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs36">val mutable lastOut : float</div>
<div class="tip" id="fs37">val timeConstant : float</div>
<div class="tip" id="fs38">val diff : float</div>
<div class="tip" id="fs39">val fadeInCtor : unit -&gt; (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs40">val mutable lastValue : float</div>
<div class="tip" id="fs41">val stepSize : float</div>
<div class="tip" id="fs42">val result : float</div>
<div class="tip" id="fs43">val min : e1:&#39;T -&gt; e2:&#39;T -&gt; &#39;T (requires comparison)</div>
<div class="tip" id="fs44">val softLimited : float</div>
<div class="tip" id="fs45">val mixed : float</div>
<div class="tip" id="fs46">val blendedDistortionCtor : unit -&gt; (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs47">val lowPassInstance : (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs48">val fadeInInstance : (float -&gt; float -&gt; float)</div>
<div class="tip" id="fs49">val lowPass : timeConstant:float -&gt; input:float -&gt; lastOut:float -&gt; float * float</div>
<div class="tip" id="fs50">val lastOut : float</div>
<div class="tip" id="fs51">val out : float</div>
<div class="tip" id="fs52">val newState : float</div>
<div class="tip" id="fs53">type BlockOutput&lt;&#39;state&gt; =<br />&#160;&#160;{value: float;<br />&#160;&#160;&#160;state: &#39;state;}</div>
<div class="tip" id="fs54">BlockOutput.value: float</div>
<div class="tip" id="fs55">BlockOutput.state: &#39;state</div>
<div class="tip" id="fs56">Multiple items<br />union case Block.Block: (&#39;state -&gt; BlockOutput&lt;&#39;state&gt;) -&gt; Block&lt;&#39;state&gt;<br /><br />--------------------<br />type Block&lt;&#39;state&gt; = | Block of (&#39;state -&gt; BlockOutput&lt;&#39;state&gt;)</div>
<div class="tip" id="fs57">val runB : block:Block&lt;&#39;a&gt; -&gt; (&#39;a -&gt; BlockOutput&lt;&#39;a&gt;)</div>
<div class="tip" id="fs58">val block : Block&lt;&#39;a&gt;</div>
<div class="tip" id="fs59">val b : (&#39;a -&gt; BlockOutput&lt;&#39;a&gt;)</div>
<div class="tip" id="fs60">Multiple items<br />type BlockOutput&lt;&#39;state&gt; =<br />&#160;&#160;{value: float;<br />&#160;&#160;&#160;state: &#39;state;}<br /><br />--------------------<br />type BlockOutput&lt;&#39;value,&#39;state&gt; =<br />&#160;&#160;{value: &#39;value;<br />&#160;&#160;&#160;state: &#39;state;}</div>
<div class="tip" id="fs61">BlockOutput.value: &#39;value</div>
<div class="tip" id="fs62">Multiple items<br />union case Block.Block: (&#39;state -&gt; BlockOutput&lt;&#39;state&gt;) -&gt; Block&lt;&#39;state&gt;<br /><br />--------------------<br />type Block&lt;&#39;state&gt; = | Block of (&#39;state -&gt; BlockOutput&lt;&#39;state&gt;)<br /><br />--------------------<br />type Block&lt;&#39;value,&#39;state&gt; = &#39;state -&gt; BlockOutput&lt;&#39;value,&#39;state&gt;</div>
<div class="tip" id="fs63">val lowPass : timeConstant:float -&gt; input:float -&gt; lastOut:float -&gt; BlockOutput&lt;float,float&gt;</div>
<div class="tip" id="fs64">val fadeIn : stepSize:float -&gt; input:float -&gt; lastValue:float -&gt; BlockOutput&lt;float,float&gt;</div>
<div class="tip" id="fs65">val lastValue : float</div>
<div class="tip" id="fs66">val bind : currentBlock:Block&lt;&#39;valueA,&#39;stateA&gt; -&gt; rest:(&#39;valueA -&gt; Block&lt;&#39;valueB,&#39;stateB&gt;) -&gt; &#39;stateA * &#39;stateB -&gt; BlockOutput&lt;&#39;valueB,(&#39;stateA * &#39;stateB)&gt;</div>
<div class="tip" id="fs67">val currentBlock : Block&lt;&#39;valueA,&#39;stateA&gt;</div>
<div class="tip" id="fs68">val rest : (&#39;valueA -&gt; Block&lt;&#39;valueB,&#39;stateB&gt;)</div>
<div class="tip" id="fs69">val previousStatePack : &#39;stateA * &#39;stateB</div>
<div class="tip" id="fs70">val previousStateOfCurrentBlock : &#39;stateA</div>
<div class="tip" id="fs71">val previousStateOfNextBlock : &#39;stateB</div>
<div class="tip" id="fs72">val currentBlockOutput : BlockOutput&lt;&#39;valueA,&#39;stateA&gt;</div>
<div class="tip" id="fs73">val nextBlock : Block&lt;&#39;valueB,&#39;stateB&gt;</div>
<div class="tip" id="fs74">BlockOutput.value: &#39;valueA</div>
<div class="tip" id="fs75">val nextBlockOutput : BlockOutput&lt;&#39;valueB,&#39;stateB&gt;</div>
<div class="tip" id="fs76">BlockOutput.value: &#39;valueB</div>
<div class="tip" id="fs77">BlockOutput.state: &#39;stateA</div>
<div class="tip" id="fs78">BlockOutput.state: &#39;stateB</div>
<div class="tip" id="fs79">val softLimited : (float -&gt; BlockOutput&lt;float,float&gt;)</div>
<div class="tip" id="fs80">val fadedIn : (float -&gt; BlockOutput&lt;float,float&gt;)</div>
<div class="tip" id="fs81">val blendedDistortion1 : drive:float -&gt; input:float -&gt; Block&lt;&#39;a,(float * (float * &#39;b))&gt;</div>
<div class="tip" id="fs82">val blendedDistortion2 : drive:float -&gt; input:float -&gt; Block&lt;&#39;a,(float * (float * &#39;b))&gt;</div>
<div class="tip" id="fs83">val blendedDistortion3 : drive:float -&gt; input:float -&gt; Block&lt;&#39;a,(float * (float * &#39;b))&gt;</div>
<div class="tip" id="fs84">val returnB : x:&#39;a -&gt; Block&lt;&#39;b&gt;</div>
<div class="tip" id="fs85">val x : &#39;a</div>
<div class="tip" id="fs86">val blockFunction : (&#39;c -&gt; BlockOutput&lt;&#39;a,unit&gt;)</div>
<div class="tip" id="fs87">val unusedState : &#39;c</div>
<div class="tip" id="fs88">Multiple items<br />type Patch =<br />&#160;&#160;new : unit -&gt; Patch<br />&#160;&#160;member Bind : block:Block&lt;&#39;c,&#39;d&gt; * rest:(&#39;c -&gt; Block&lt;&#39;e,&#39;f&gt;) -&gt; Block&lt;&#39;e,(&#39;d * &#39;f)&gt;<br />&#160;&#160;member Return : x:&#39;a -&gt; Block&lt;&#39;b&gt;<br /><br />--------------------<br />new : unit -&gt; Patch</div>
<div class="tip" id="fs89">val this : Patch</div>
<div class="tip" id="fs90">val block : Block&lt;&#39;c,&#39;d&gt;</div>
<div class="tip" id="fs91">val rest : (&#39;c -&gt; Block&lt;&#39;e,&#39;f&gt;)</div>
<div class="tip" id="fs92">val patch : Patch</div>
<div class="tip" id="fs93">val blendedDistortion : drive:float -&gt; input:float -&gt; Block&lt;&#39;a,(float * (float * &#39;b))&gt;</div>
<div class="tip" id="fs94">val blendedDistortion : drive:&#39;a -&gt; input:&#39;b -&gt; &#39;c</div>
<div class="tip" id="fs95">val drive : &#39;a</div>
<div class="tip" id="fs96">val input : &#39;b</div>
<div class="tip" id="fs97">val initialState : float * (float * unit)</div>
<div class="tip" id="fs98">val result : BlockOutput&lt;obj,(float * (float * unit))&gt;</div>
<div class="tip" id="fs99">type &#39;T option = Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs100">val previousStateOfCurrentBlock : obj</div>
<div class="tip" id="fs101">val previousStateOfNextBlock : obj</div>
<div class="tip" id="fs102">union case Option.None: Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs103">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs104">val lowPass : timeConstant:float -&gt; input:float -&gt; lastOut:float option -&gt; BlockOutput&lt;float,float&gt;</div>
<div class="tip" id="fs105">val lastOut : float option</div>
<div class="tip" id="fs106">val state : float</div>
<div class="tip" id="fs107">val v : float</div>
<div class="tip" id="fs108">val fadeIn : stepSize:float -&gt; initial:float -&gt; input:float -&gt; lastValue:float option -&gt; BlockOutput&lt;float,float&gt;</div>
<div class="tip" id="fs109">val initial : float</div>
<div class="tip" id="fs110">val lastValue : float option</div>
<div class="tip" id="fs111">val result : BlockOutput&lt;obj,(float * (float * obj))&gt;</div>
<div class="tip" id="fs112">val inputValues : float list</div>
<div class="tip" id="fs113">val createEvaluatorWithStateAndValues : blockWithInput:(&#39;vIn -&gt; Block&lt;&#39;vOut,&#39;s&gt;) -&gt; (seq&lt;&#39;vIn&gt; -&gt; seq&lt;BlockOutput&lt;&#39;a option&gt;&gt;)</div>
<div class="tip" id="fs114">val blockWithInput : (&#39;vIn -&gt; Block&lt;&#39;vOut,&#39;s&gt;)</div>
<div class="tip" id="fs115">val mutable state : &#39;a option</div>
<div class="tip" id="fs116">val inputValues : seq&lt;&#39;vIn&gt;</div>
<div class="tip" id="fs117">Multiple items<br />val seq : sequence:seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />--------------------<br />type seq&lt;&#39;T&gt; = System.Collections.Generic.IEnumerable&lt;&#39;T&gt;</div>
<div class="tip" id="fs118">val i : &#39;vIn</div>
<div class="tip" id="fs119">val block : Block&lt;&#39;vOut,&#39;s&gt;</div>
<div class="tip" id="fs120">val result : BlockOutput&lt;&#39;a option&gt;</div>
<div class="tip" id="fs121">BlockOutput.state: &#39;a option</div>
<div class="tip" id="fs122">val createEvaluatorWithValues : blockWithInput:(&#39;vIn -&gt; Block&lt;&#39;vOut,&#39;s&gt;) -&gt; (seq&lt;&#39;vIn&gt; -&gt; seq&lt;float&gt;)</div>
<div class="tip" id="fs123">val stateAndValueEvaluator : (seq&lt;&#39;vIn&gt; -&gt; seq&lt;BlockOutput&lt;obj option&gt;&gt;)</div>
<div class="tip" id="fs124">val stateAndValue : BlockOutput&lt;obj option&gt;</div>
<div class="tip" id="fs125">val evaluate : (float list -&gt; seq&lt;obj&gt;)</div>
<div class="tip" id="fs126">val outputValues1 : obj list</div>
<div class="tip" id="fs127">val toList : source:seq&lt;&#39;T&gt; -&gt; &#39;T list</div>

      </div>
      <div class="span1"></div>
    </div>

  </div>
</body>

</html>